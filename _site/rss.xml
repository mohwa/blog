<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
>

<channel>
    <title><![CDATA[Mohwa blog]]></title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <link href="/" />
    <description><![CDATA[]]></description>
    <lastBuildDate>Fri, 07 Aug 2015 13:47:06 +0900</lastBuildDate>
    <language>en-US</language>
    <generator uri="http://octopress.org/">Octopress</generator>

    
        <item>
            <title><![CDATA[ObjectPool in JS]]></title>
            <link>/designpattern/2015/08/07/objectpool-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 22:31:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/objectpool-inJS/</guid>
            <description>
                <![CDATA[1. 정의 생성된 객체들을 별도의 Pool 안에 저장 후 재사용 하는 방법으로, 불필요한 객체 생성 및 반환(GC에 의한)을 최소화하는 디자인 패턴중 하나 이다. 객체 재사용을 위해, 생성된 객체를 Pool 안에 저장시켜 놓는다. 새로운 객체가 필요할때는, 무조건 새로 생성하는것이 아니라, Pool 안에 반환된 객체가 존재한다면, 그 중 하나를 재사용 한다. 객체...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li><p>생성된 <strong>객체</strong>들을 별도의 <strong>Pool</strong> 안에 저장 후 <span style="color:#c11f1f">재사용</span> 하는 방법으로, 불필요한 객체 <strong>생성</strong> 및 <strong>반환</strong>(<strong>GC</strong>에 의한)을 <span style="color:#c11f1f">최소화</span>하는 <u><strong>디자인 패턴</strong></u>중 하나 이다.</p>

<ul>
<li><strong>객체</strong>  <span style="color:#c11f1f">재사용</span>을 위해, 생성된 <strong>객체</strong>를 <strong>Pool</strong> 안에 저장시켜 놓는다.</li>
<li><p>새로운 <strong>객체</strong>가 필요할때는, <u>무조건 새로 <span style="color:#c11f1f">생성</span></u>하는것이 아니라, <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>된 <strong>객체</strong>가 존재한다면, <u>그 중 하나를 <span style="color:#c11f1f">재사용</span> 한다.</u></p>

<ul>
<li><em>객체 <span style="color:#c11f1f">재사용</span>으로 Heap 메모리 사용을 <span style="color:#c11f1f">최소화</span>한다.</em></li>
</ul></li>
<li><p>사용(객체)이 끝난 후에는 <u>다시 <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>시킨다.</u></p></li>
</ul></li>
</ul>

<h2>2. 특징</h2>

<ul>
<li><p>정해진 <strong>범위</strong>내에서 개발자가 직접 <u><strong>Heap 메모리</strong>를 관리(객체 <span style="color:#c11f1f">생성</span> 및 <span style="color:#c11f1f">반환</span>)</u>할 수 있다.</p>

<ul>
<li><p><u><strong>객체 생성 비용</strong></u>을 줄일 수 있다.(Heap 메모리 사용을 줄일 수 있다)</p>

<ul>
<li><em>당연한 말이겠지만, 생성되는 객체 <span style="color:#c11f1f">크기</span> 및 그 <span style="color:#c11f1f">수</span>에 따라, <u>더 많은 비용을 줄일 수도 있다.</u></em></li>
</ul></li>
<li><p><strong>GC</strong> 를 통해 일어나는, <u>메모리 <span style="color:#c11f1f">반환</span>(반환 시 일어나는 일련의 작업들)) <strong>비용</strong>을 줄일 수 있다.</u></p>

<ul>
<li>보통 이 과정(메모리 반환 과정)을 처리하는 동안에는, <strong>프로그램 실행</strong> 이 중단된다.</li>
<li>또한, 이 과정은 <u>프로그램 실행 중 <span style="color:#c11f1f">임의의 시간</span>에, <span style="color:#c11f1f">임의의 시간동안</span> 언제라도 일어날 수 있다.</u></li>
<li>개발자는 이 <strong>과정</strong>을 <u><span style="color:#c11f1f">제어</span>할 수 없다.</u></li>
</ul>

<p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
</ul></li>
<li><p><span style="color:#c11f1f">재사용</span>되는 <strong>객체</strong>는 <u>모두 <strong>동일한 타입</strong>을 갖는다.</u></p></li>
</ul>

<h2>3. JS 로 동적 ObjetPool 구현해보기</h2>

<iframe height='540' scrolling='no' src='http://codepen.io/yanione/embed/jPdzWB/?height=540&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/jPdzWB/'>jPdzWB</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe>

<ul>
<li>일반적인 동적 <strong>Objet Pool</strong> 기능을 만드는 방법은 위 코드와 같이 크게 어렵지 않다.(물론 지원하는 기능의 범위에 따라, 구현 수준은 크게 달라질 수 있다)</li>
</ul>

<h2>4. ObjectPool 적용 테스트</h2>

<ul>
<li><p>Click 버튼을 <span style="color:#c11f1f">10</span>번 누른 후 <strong>Profiles(in Chrome Tool) 패널</strong>을 통해, <strong>Heap Memory</strong> 를 체크하면 <span style="color:#c11f1f">적용</span> <strong>유/무</strong>에 따른 결과를 얻을 수 있다.</p>

<ul>
<li><p><strong>Object Pool</strong> 적용 전</p>

<ul>
<li><p><span style="color:#c11f1f">Ball</span> 생성자 함수를 통해 객체를 <strong>300</strong>개 할당했다.</p>

<ul>
<li>30 * 10 = 300(무조건 새로운 객체를 Heap 메모리에 할당했다)</li>
</ul></li>
</ul>

<p><img src="/Users/sgjeon/blog_doc/img/ballHeap.jpg" alt=""></p></li>
<li><p><strong>Object Pool</strong> 적용 후</p>

<ul>
<li><p><span style="color:#c11f1f">$F</span> 생성자 함수를 통해 <strong>93</strong>개의 객체를 할당했다.</p>

<ul>
<li><span style="color:#c11f1f">$F</span>: <strong>Object Pool</strong> 라이브러리상에서 만든 생성자 함수.</li>
<li>적용 후에는 총 <strong>93</strong>개의 객체를 <span style="color:#c11f1f">할당</span>했으며, <strong>207</strong>개의 객체를 <span style="color:#c11f1f">재사용</span>하였다.</li>
</ul></li>
</ul>

<p><img src="/Users/sgjeon/blog_doc/img/ballHeap2.jpg" alt=""></p></li>
</ul></li>
</ul>

<h2>5. 정리하며</h2>

<ul>
<li><p>즉 지나친 객체 <span style="color:#c11f1f">생성</span> 및 <span style="color:#c11f1f">반환</span>을 <strong>최소화</strong> 하는것이, <strong>어플리케이션</strong>상에 <span style="color:#c11f1f">메모리 변동</span>을 줄이는 방법이며, 이로인해 사용자 경험까지 최적화할 수 있다.</p></li>
<li><p>일반적인 <strong>웹</strong>상에서는 적용할 일이 거의 없어보이지만, <strong>게임 어플리케이션</strong>이라면, 적용 범위가 꽤 많을 듯 하다.</p></li>
</ul>

<h2>6. 참고 URL</h2>

<ul>
<li><p><a href="http://ufx.kr/blog/591">액션스크립트의 객체 재사용을 위한 오브젝트 풀(Object Pool)</a></p></li>
<li><p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
<li><p><a href="http://beej.us/blog/data/object-pool/">Object Pools</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    

</channel>

</rss>