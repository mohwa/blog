<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <!-- viewport 설정 -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- keyword 설정 -->
    
    <!-- description 설정 -->
    

    <!-- open graph 설정 -->
    <meta property="og:type" content="mohwa blog">
    
    
    <!--<meta property="og:image" content="http://mysite.com/myimage.jpg">-->
    <meta property="og:url" content="/blog">

    <meta name="copyright" content="by mohwa" />

    <!--<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />-->

    <!-- google search console 설정 -->
    <link rel="alternate" hreflang="ko" href="http://mohwa.github.io" />
    <link rel="alternate" hreflang="ko" href="https://mohwa.github.io" />

    <link rel="stylesheet" href="/blog/assets/css/site.css" />
    <link rel="stylesheet" href="/blog/bower_components/highlightjs/styles/darkula.css">

    <script src="/blog/bower_components/jquery/dist/jquery.min.js" type="text/javascript"></script>
    <script src="/blog/bower_components/highlightjs/highlight.pack.min.js" type="text/javascript"></script>
    <script src="/blog/bower_components/purl/purl.js" type="text/javascript"></script>
    <!-- Script pointing to jekyll-search.js -->
    <script src="/blog/bower_components/simple-jekyll-search/dest/jekyll-search.js" type="text/javascript"></script>

    <title>Mohwa blog</title>

    <script type="text/javascript">

        // code highlight 적용
        // https://highlightjs.org/static/demo/
        $(document).ready(function() {
            $('pre code').each(function(i, block) {
                hljs.highlightBlock(block);
            });
        });
    </script>
</head>

<body>

  <div class="top-bar"></div>

  <div class="container">
    <div class="site">
      <header>
        <nav>
    <span style="float:left;">
        <a class="" href="/blog/">Home</a>
        <!--<a class="" href="/archive/">전체글</a>-->
        <!--<a class="" href="//github.com/nolboo/nolboo.github.io/wiki">번역글 위키</a>-->
    </span>
    <span style="float:right;">
        <div id="search-container" class="search-container">
            <input type="text" id="search-input" class="search-input" placeholder="search...">
        </div>
    </span>
</nav>

        <div class="pull-right right logo">
          <div class="name"></div>
          <!--<a href="/feed.xml"><img class="avatar" src="/images/rss.jpg" alt="RSS" /></a>-->
        </div>
      </header>
      <div class="separator"></div>
      <ul id="results-container" class="results-container"></ul>
      <!-- ./_layouts/default.html 파일에 정의된  영역으로 아래 내용들이 들어간다. -->
<section>
  <ul class="posts">
    <!-- This loops through the paginated posts -->
    
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/04/21/es6-object-literal/">ES6 object initializer</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-04-21">
                Apr 21, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <h2 id="1">1. 글에 대해</h2>

<ul>
<li>모든 결과는 <strong>Chrome 브라우저</strong>를 통해 테스트된 결과입니다.</li>
</ul>

<h2 id="2-object-initializer">2. object initializer</h2>

<ul>
<li><p>객체 <span style="color:#c11f1f">초기화</span>(or 생성)를 위한 표현법(or 식)으로 아래와 같은 것들이 존재한다.</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">new Object()</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a>, Object Literal</li>
</ul></li>
</ul>

<h2 id="3-es5-amp-object-initializer">3. <span style="color:#c11f1f">ES5</span> &amp; <span style="color:#c11f1f">Object Initializer</span></h2>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// &#39;use strict&#39;;</span>
<span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){}};</span>

    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// 1 2 function(){}</span>

    <span class="c1">// 변수 선언(및 할당)과 동시에, 객체 property 값을 초기화할 수 있다.</span>
    <span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">_x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">_y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">};</span>
    <span class="c1">// 단 &quot;Strict Mode&quot; 에서는 아래와 같은 예외가 발생하게된다.(주의!!)</span>
    <span class="c1">// Uncaught ReferenceError: _x is not defined</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o2</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">o2</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// 3 4</span>

    <span class="c1">// ES5 에서는 Object.defineProperty 를 통해서만, 접근자를 생성할 수 있다.</span>
    <span class="kd">var</span> <span class="nx">o4</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="c1">// id 접근자를 생성한다.</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o4</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="c1">// 접근자 property 에 수정 권한을 준다.(기본 값: false)</span>
        <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">get</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">return</span> <span class="nx">id</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="nx">set</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
            <span class="nx">id</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o4</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// &#39;&#39;</span>

    <span class="nx">o4</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione&#39;</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o4</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="4-es6-amp-object-initializer">4. <span style="color:#c11f1f">ES6</span> &amp; <span style="color:#c11f1f">Object Initializer</span></h2>

<ul>
<li><p>기본적인 사용 방법</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
    <span class="c1">// 선언된 변수명과 동일한 객체 property 명을 사용할 경우, 아래와 같이 표현할 수 있다.</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">z</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){},</span> <span class="nx">__proto__</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="c1">// property 할당 문법이 보다 간결해졌다.</span>
    <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">,</span> <span class="nx">__proto__</span><span class="p">};</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span> <span class="c1">// 1 2 function(){}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">);</span> <span class="c1">// null</span>

    <span class="c1">// ES6 에서는 객체 초기화 시, 접근자를 생성할 수 있다.</span>
    <span class="kd">let</span> <span class="nx">o3</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1">// 접근자 사용을위해, 접근자 property(__id__) 를 선언한다.</span>
        <span class="c1">// 접근자 property</span>
        <span class="nx">__id__</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="c1">// getter</span>
        <span class="nx">get</span> <span class="nx">id</span><span class="p">(){</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="c1">// setter</span>
        <span class="nx">set</span> <span class="nx">id</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o3</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// &#39;&#39;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o3</span><span class="p">.</span><span class="nx">__id__</span><span class="p">);</span> <span class="c1">// &#39;&#39;</span>

    <span class="nx">o3</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione&#39;</span><span class="p">;</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o3</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o3</span><span class="p">.</span><span class="nx">__id__</span><span class="p">);</span> <span class="c1">// yanione</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o3</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">o4</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1">// 메서드를 생성한다.</span>
        <span class="nx">method</span><span class="p">(){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="c1">// 문자열을 통해, property 명 조합할 수 있다.</span>
        <span class="p">[</span><span class="s1">&#39;me&#39;</span><span class="o">+</span> <span class="s1">&#39;thod1&#39;</span><span class="p">](){</span>
            <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="c1">// generator 를 생성할 수 있다.</span>
        <span class="o">*</span> <span class="nx">generator</span><span class="p">(</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">10</span><span class="p">){</span>

            <span class="c1">// 일반적인 동기화 구문</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
                <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="c1">// 전달된 generator 를 비동기로 호출하는 함수</span>
        <span class="nx">asyncAction</span><span class="p">(</span><span class="nx">generator</span><span class="p">,</span> <span class="nx">cb</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){},</span> <span class="nx">time</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">){</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">generator</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

            <span class="kd">let</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">v</span><span class="p">.</span><span class="nx">done</span><span class="p">){</span>
                <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">asyncAction</span><span class="p">(</span><span class="nx">generator</span><span class="p">,</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">time</span><span class="p">);</span>
                    <span class="nx">cb</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
                <span class="p">},</span> <span class="nx">time</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o4</span><span class="p">.</span><span class="nx">method</span><span class="p">());</span> <span class="c1">// 1</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o4</span><span class="p">.</span><span class="nx">method1</span><span class="p">());</span> <span class="c1">// 2</span>

    <span class="kd">let</span> <span class="nx">__generator__</span> <span class="o">=</span> <span class="nx">o4</span><span class="p">.</span><span class="nx">generator</span><span class="p">();</span>

    <span class="c1">// 동기화 구문을 포함한 generator 를 (재귀 호출을 위한)setTimeout 함수를 통해, 비동기로 호출한다.</span>
    <span class="c1">// 전달된 callback 함수를 1초 마다 호출하게된다.</span>
    <span class="nx">o4</span><span class="p">.</span><span class="nx">asyncAction</span><span class="p">(</span><span class="nx">__generator__</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// o object</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="c1">// 0 ~ 9</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">super</span> 키워드를 통해, 상속받은 객체 메서드를 호출할 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>

    <span class="kd">let</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">method1</span><span class="p">(){</span>
            <span class="c1">// super 키워드를 통해, 상속받은 객체 메서드를 호출할 수 있다.</span>
            <span class="kr">super</span><span class="p">.</span><span class="nx">method2</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kd">let</span> <span class="nx">o2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">method2</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;method2&#39;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">o1</span><span class="p">,</span> <span class="nx">o2</span><span class="p">);</span>

    <span class="nx">o1</span><span class="p">.</span><span class="nx">method1</span><span class="p">();</span>

<span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ES5</span> 의 __proto__ 내부 속성을 통해, <span style="color:#c11f1f">super</span> 키워드를 구현할 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
    <span class="kd">let</span> <span class="nx">o1</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">method1</span><span class="p">(){</span>
            <span class="c1">// getPrototypeOf 메서드는 chrome 5, IE 9 이상에서 지원한다(대부분의 브라우저에서 지원한다고 볼 수 있다)</span>
            <span class="c1">// getPrototypeOf 메서드를 통해, super 키워드를 구현할 수 있다.</span>
            <span class="c1">// Object.getPrototypeOf(this).method2() === this.__proto__.method2()</span>
            <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">method2</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kd">let</span> <span class="nx">o2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">method2</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;method2&#39;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// setPrototypeOf 메서드는 chrome 34, IE 11 이상에서만 지원한다.</span>
    <span class="c1">// Object.setPrototypeOf(o1, o2) === o1.__proto__ = o2;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">o1</span><span class="p">,</span> <span class="nx">o2</span><span class="p">);</span>

    <span class="nx">o1</span><span class="p">.</span><span class="nx">method1</span><span class="p">();</span>

<span class="p">}</span>
</code></pre></div></li>
</ul>

<h2 id="url">관련 URL</h2>

<ul>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Object_initializer">Object initializer</a><p></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super">super</a><p></p></li>
<li><p><a href="http://www.bsidesoft.com/?p=2053">[es6] Generator #1</a><p></p></li>
<li><p><a href="https://medium.com/@dduskim/es6-in-depth-let-and-const-%EB%B2%88%EC%97%AD-31028c086e72#.c48zfoehd">ES6 In Depth: let and const (번역)</a><p></p></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/04/21/es6-object-literal/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/03/24/es6-destructuring-assignment/">ES6 Destructuring assignment</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-03-24">
                Mar 24, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <h2 id="1">1. 글에 대해</h2>

<ul>
<li>모든 결과는 <strong>Chrome 브라우저</strong>(ver 49)를 통해 테스트된 결과입니다.</li>
</ul>

<h2 id="2-destructuring-assignment">2. Destructuring assignment(해체 할당)이란?</h2>

<ul>
<li><span style="color:#c11f1f">해체 할당</span>은, <strong>배열</strong> 또는 <strong>객체</strong> 리터럴과 유사한 <strong>문법</strong>으로, 변수에 값을 할당하는 <span style="color:#c11f1f">JS 표현식</span>중 하나이다.</li>
</ul>

<h2 id="3-array-destructing-assignment">3. <span style="color:#c11f1f">Array</span> destructing assignment(배열 해체 할당)</h2>

<ul>
<li><p><span style="color:#c11f1f">배열 해체 할당</span>을 통해, <strong>iterator</strong> 객체의 <strong>요소</strong>값을, <strong>변수</strong>에 할당시킬 수 있다. </p>

<ul>
<li><p>Array in <span style="color:#c11f1f">ES5</span></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="c1">// ES5 에서, 배열 객체 요소를 변수에 할당시키는 기본적인 방법이다.</span>
      <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

      <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p>Iterator in <span style="color:#c11f1f">ES6</span></p>

<ul>
<li><p><strong>기본적인</strong> 할당 방법</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

      <span class="c1">// (블록 스코프)변수 선언과, 해체 할당을 한줄로 표현할 수 있다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>

      <span class="c1">// 변수 선언이 생략된 x, y 속성은, 실행 코드 처리 시, globalEC.VO 의 속성으로 추가된다.</span>
      <span class="p">[</span><span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>

      <span class="c1">// globalEC.VO.x, globalEC.VO.y</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">_y</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">_x</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">_y</span><span class="p">);</span> <span class="c1">// 1 2 1 2</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p>변수 할당을 <strong>건너뛰는</strong> 방법</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>   
      <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>

      <span class="c1">// 아래와 같은 표현식을 통해, 변수 할당을 건너뛸 수 있다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">,</span> <span class="p">,</span> <span class="nx">z</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// 1 4</span>
  <span class="p">}</span>              
</code></pre></div></li>
<li><p><strong>나머지 연산자</strong>를 통한 해체 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

      <span class="c1">// y 변수에는, (할당될)배열 객체의 나머지 요소(2, 3)가 포함된 새로운 배열 객체([2, 3])가 할당된다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">...</span><span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 [2, 3]</span>

      <span class="kd">let</span> <span class="p">[</span><span class="nx">_x</span><span class="p">,</span> <span class="p">...</span><span class="nx">_y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>

      <span class="c1">// _y 변수에는, (할당될)배열 객체의 나머지 요소가 존재하지 않으므로, 빈 배열 객체가 할당된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="p">);</span> <span class="c1">// 1, []</span>
  <span class="p">}</span>              
</code></pre></div></li>
<li><p>(할당될)변수의 <strong>기본값</strong>을 지정할 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>

      <span class="c1">// y 변수에 기본값 2 를 지정한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>

      <span class="c1">// y 변수에 기본값 2 가 할당된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>

      <span class="c1">// _x 변수에 기본값 1 을 지정한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">_x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">undefined</span><span class="p">];</span>

      <span class="c1">// _x 변수에 기본값 1 이 할당된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_x</span><span class="p">);</span> <span class="c1">// 1</span>

      <span class="c1">// 함수 표현식을 기본값으로 사용할 수 있다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">__x</span> <span class="o">=</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">})()]</span> <span class="o">=</span> <span class="p">[];</span>

      <span class="c1">// __x 변수에 함수 표현식을 통해 반환받은 기본값 1이 할당된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">__x</span><span class="p">);</span> <span class="c1">// 1</span>

      <span class="c1">// ___x, ___y 변수에 각각 기본값 3, ___x 변수를 지정한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">___x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">___y</span> <span class="o">=</span> <span class="nx">___x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>

      <span class="c1">// ___x, ___y 변수에 각각 기본값 3, ___x 변수값이 할당된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">___x</span><span class="p">,</span> <span class="nx">___y</span><span class="p">);</span> <span class="c1">// 3 3</span>

      <span class="c1">// ____x, ____y 변수에 각각 기본값 3, ____x 변수를 지정한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">____x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">____y</span> <span class="o">=</span> <span class="nx">____x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">];</span>

      <span class="c1">// ____x, ____y 변수에 각각 배열 요소값 7, ____x 변수값이 할당된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">____x</span><span class="p">,</span> <span class="nx">____y</span><span class="p">);</span> <span class="c1">// 7 7</span>
  <span class="p">}</span>                
</code></pre></div></li>
<li><p><strong>중첩 배열</strong>에 대한, 해체 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
    <span class="c1">// 중첩 배열을 통한 해체 할당</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]];</span>

    <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="p">...</span><span class="nx">z</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>

    <span class="c1">// z 변수에는 (할당될)변수 객체의 나머지 요소(4, 5)가 포함된 새로운 배열[4, 5]이 할당된다.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// 1 3 [4, 5]</span>

    <span class="kd">let</span> <span class="p">[</span><span class="nx">_x</span><span class="p">,</span> <span class="p">...[</span><span class="nx">_y</span><span class="p">,</span> <span class="nx">_z</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

    <span class="c1">// (나머지 연산자의)피 연산자는 꼭 변수가 아니여도 된다.</span>
    <span class="c1">// 즉 나머지 연산자를 통해, 할당된 피연산자를 한번 더, 해체 할당하면 아래와 같은 결과가 반환된다.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="p">,</span> <span class="nx">_z</span><span class="p">);</span> <span class="c1">// 1 2 3</span>
  <span class="p">}</span>                
</code></pre></div></li>
<li><p><strong>함수 인자값</strong>을 통한, 해체 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>

      <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>

          <span class="c1">// y 변수에는 지정된 기본값인 2가 할당된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
      <span class="p">};</span>

      <span class="nx">A</span><span class="p">([</span><span class="mi">1</span><span class="p">]);</span>

      <span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">([</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>

          <span class="c1">// x, y 변수에는 지정된 기본값인 1, 2 가 할당된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
      <span class="p">};</span>

      <span class="nx">B</span><span class="p">();</span>

      <span class="kd">let</span> <span class="nx">C</span> <span class="o">=</span> <span class="p">([</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[])</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
      <span class="p">};</span>

      <span class="c1">// 전달된 인자값이 없는경우, 그에 대한 기본값인 &quot;빈 배열&quot; 객체가 할당되며, </span>
      <span class="c1">// 또 그 배열에 대한 기본값인 x = 1, y = 2 가 다시 할당되게된다.</span>
      <span class="nx">C</span><span class="p">();</span> <span class="c1">// 1 2</span>

      <span class="c1">// 지정된 기본값인 1, 2 가 할당된다.</span>
      <span class="nx">C</span><span class="p">([]);</span> <span class="c1">// 1 2</span>

      <span class="c1">// 전달된 인자값이 할당된다.</span>
      <span class="nx">C</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span> <span class="c1">// 3 4</span>

      <span class="c1">// block scope</span>
      <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;outer&#39;</span><span class="p">;</span>

      <span class="kd">let</span> <span class="nx">D</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">_x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>

          <span class="c1">// x 변수 선언 후, 2를 할당한다</span>
          <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;inner&#39;</span><span class="p">;</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_x</span><span class="p">);</span> <span class="c1">// outer</span>
      <span class="p">}</span>

      <span class="c1">// 전달된 인자값이 없는 경우, 지정된 기본값인 x 변수가 할당된다.</span>
      <span class="nx">D</span><span class="p">();</span>

      <span class="c1">// args 변수에는, 전달된 인자값이 모두 포함된 새로운 배열이 할당된다.</span>
      <span class="kd">let</span> <span class="nx">E</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>

          <span class="c1">// x, y 변수에 할당한다.</span>
          <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">;</span>

          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
      <span class="p">}</span>

      <span class="nx">E</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul></li>
<li><p>그 밖의 표현식     </p>

<ul>
<li><p><strong>문자열</strong> 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>

      <span class="c1">// 문자열이 할당될 경우에는, 해당 문자열을 암묵적으로 iterator 객체로 변환한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;xyz&#39;</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// x y z</span>

      <span class="c1">// 아래 코드는 동일한 결과를 반환한다.</span>
      <span class="c1">// let [_x, _y, _z] = new String(&#39;xyz&#39;)[Symbol.iterator]();</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><strong>new Set([])</strong></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="c1">// 생성된 set 객체를 통해, iterator 객체를 할당한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">__x</span><span class="p">,</span> <span class="nx">__y</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">__x</span><span class="p">,</span> <span class="nx">__y</span><span class="p">);</span> <span class="c1">// 1 2</span>

      <span class="c1">// let [__x, __y] = new Set([1, 2]).values();</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><strong>generator</strong> 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="c1">// generator 를 선언한다.       </span>
      <span class="kd">function</span><span class="o">*</span> <span class="nx">$$</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>

      <span class="c1">// 생성된 generator 를 할당한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">]</span> <span class="o">=</span> <span class="nx">$$</span><span class="p">();</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// 1 2 3</span>

      <span class="c1">// 객체 내부에 생성된 generator 를 할당한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
          <span class="c1">// generator 생성한다</span>
          <span class="o">*</span> <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
                  <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">};</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="p">);</span> <span class="c1">// 1 2</span>

      <span class="c1">// iterator 인터페이스를 구현한, iterator 객체를 할당한다.</span>
      <span class="kd">let</span> <span class="p">[</span><span class="nx">__x</span><span class="p">,</span> <span class="nx">__y</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">i</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
          <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
              <span class="c1">// iterator 객체를 반환</span>
              <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">next</span><span class="p">(){</span>
              <span class="k">return</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">i</span><span class="p">,</span> <span class="nx">done</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">};</span>
          <span class="p">}</span>
      <span class="p">};</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">__x</span><span class="p">,</span> <span class="nx">__y</span><span class="p">);</span> <span class="c1">// 1 2</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><strong>ETC</strong></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>

      <span class="c1">// 정규식을 통해, 반환된 iterator 객체를 할당한다.</span>
      <span class="kd">let</span> <span class="p">[,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">]</span> <span class="o">=</span> <span class="sr">/(\d+)\/*(\d+)\/*(\d+)/</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="s1">&#39;2016/03/01&#39;</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span> <span class="c1">// 2016 03 01</span>

      <span class="c1">// map 객체를 생성한다.</span>
      <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([</span>
          <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span>
          <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span>
          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
      <span class="p">]);</span>

      <span class="c1">// map 객체를 통해, 새로운 배열 객체를 생성한다.</span>
      <span class="kd">let</span> <span class="nx">_m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">([...</span><span class="nx">m</span><span class="p">].</span><span class="nx">map</span><span class="p">(([</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[</span><span class="nx">k</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nx">v</span><span class="p">];</span>
      <span class="p">}));</span>

      <span class="kd">let</span> <span class="nx">urls</span> <span class="o">=</span> <span class="p">[</span>
          <span class="s1">&#39;http://example.com/foo.html&#39;</span><span class="p">,</span>
          <span class="s1">&#39;http://example.com/bar.html&#39;</span><span class="p">,</span>
          <span class="s1">&#39;http://example.com/baz.html&#39;</span>
      <span class="p">];</span>

      <span class="c1">// Promise.all 메서드를 통해, 전달된 url 집합을 할당한다.</span>
      <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">urls</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">url</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">url</span><span class="p">;</span>
      <span class="p">})).</span><span class="nx">then</span><span class="p">(([</span><span class="nx">url1</span> <span class="o">=</span> <span class="nx">top</span><span class="p">.</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">,</span> <span class="nx">url2</span> <span class="o">=</span> <span class="nx">top</span><span class="p">.</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">,</span> <span class="nx">url3</span> <span class="o">=</span> <span class="nx">top</span><span class="p">.</span><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>

          <span class="c1">// 전달받은 배열 객체([&#39;http://example.com/foo.html&#39;, &#39;http://example.com/bar.html&#39;, &#39;http://example.com/baz.html&#39;])가 해체 할당된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">url1</span><span class="p">,</span> <span class="nx">url2</span><span class="p">,</span> <span class="nx">url3</span><span class="p">);</span>
      <span class="p">});</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul></li>
</ul></li>
</ul>

<h2 id="4-object-destructing-assignment">4. <span style="color:#c11f1f">Object</span> destructing assignment(객체 해체 할당)</h2>

<ul>
<li><p><span style="color:#c11f1f">객체 해체 할당</span>을 통해, 객체 <strong>속성</strong>값을, <strong>변수</strong>에 할당시킬 수 있다. </p>

<ul>
<li><p>Object in <span style="color:#c11f1f">ES5</span></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="c1">// ES5 에서, 객체 속성을 변수에 할당시키는 기본적인 방법이다.</span>
      <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span>

      <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
  <span class="p">}</span>                    
</code></pre></div></li>
<li><p>Object in <span style="color:#c11f1f">ES6</span></p>

<ul>
<li><p><strong>기본적인</strong> 할당 방법</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span>

      <span class="c1">// (블록 스코프)변수 선언과, 해체 할당을 한줄로 표현할 수 있다.</span>
      <span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>

      <span class="c1">// (할당될)변수 이름을 객체 속성 이름과 다르게 생성하고 싶을때에는, 아래와 같은 표현식을 사용할 수 있다.</span>
      <span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">_x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">_y</span><span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="p">);</span> <span class="c1">// 1 2 1 2</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p>(할당될)변수의 <strong>기본값</strong>을 지정할 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>

      <span class="c1">// y 변수에 기본값 2 를 지정한다.</span>
      <span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>

      <span class="c1">// _y 변수에 기본값 2 를 지정한다.</span>
      <span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">_x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">_y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="p">);</span> <span class="c1">// 1 2</span>

      <span class="c1">// 배열 요소가 존재하지 않을 경우, 그에 대한 기본값인 &quot;빈 객체&quot;가 할당되며,</span>
      <span class="c1">// 또 그 객체에 대한 기본값인 __y = 2 가 다시 할당된다.</span>
      <span class="kd">let</span> <span class="p">[{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">__x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">__y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span> <span class="o">=</span> <span class="p">{}]</span> <span class="o">=</span> <span class="p">[];</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">__x</span><span class="p">,</span> <span class="nx">__y</span><span class="p">);</span> <span class="c1">// undefined 2</span>

      <span class="c1">// 배열 요소가 존재하지 않을 경우, 그에 대한 기본값인 &quot;빈 객체&quot;가 할당되며,</span>
      <span class="c1">// 또 그 객체에 대한 기본값인 ___x = {x: 1}, ___y = 2 가 다시 할당된다.</span>
      <span class="kd">let</span> <span class="p">[{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">___x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">___y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">}]</span> <span class="o">=</span> <span class="p">[];</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">___x</span><span class="p">,</span> <span class="nx">___y</span><span class="p">);</span> <span class="c1">// 1 2</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><strong>중첩 객체</strong>에 대한, 해체 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="c1">// 중첩된 객체를 생성한다.</span>
      <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="p">{</span><span class="nx">_x</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">_y</span><span class="o">:</span> <span class="p">{</span><span class="nx">__x</span><span class="o">:</span> <span class="mi">3</span><span class="p">}}};</span>

      <span class="c1">// 중첩된 객체가 해체 할당된다.</span>
      <span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="p">{</span><span class="nx">_x</span><span class="p">,</span> <span class="nx">_y</span><span class="o">:</span> <span class="p">{</span><span class="nx">__x</span><span class="p">}}}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">_x</span><span class="p">,</span> <span class="nx">__x</span><span class="p">);</span> <span class="c1">// 1 2 3</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><strong>함수 인자값</strong>을 통한, 해체 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">({</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
      <span class="p">};</span>

      <span class="c1">// y 변수에는 기본값인 2가 할당된다.</span>
      <span class="nx">A</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>

      <span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">({</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
      <span class="p">};</span>

      <span class="c1">// 인자값이 전달되지않은 경우에도, 기본값인 {x: 1, y: 2} 가 할당된다.</span>
      <span class="nx">B</span><span class="p">();</span>

      <span class="kd">let</span> <span class="nx">C</span> <span class="o">=</span> <span class="p">({</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// 1 2</span>
      <span class="p">};</span>

      <span class="c1">// 인자값이 전달되지않은 경우에는, 그에 대한 기본값인 빈 객체가 할당되며,</span>
      <span class="c1">// 또 그 객체에 대한 기본값인 x = 1, y = 2 가 다시 할당된다.</span>
      <span class="nx">C</span><span class="p">();</span>

    <span class="c1">// 해체 할당을 통해 이와 같은 패턴이 적용될듯 하다.</span>
    <span class="kd">function</span> <span class="nx">ajax</span><span class="p">({</span><span class="nx">url</span> <span class="o">=</span> <span class="nx">top</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">,</span> <span class="nx">method</span> <span class="o">=</span> <span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nx">headers</span> <span class="o">=</span> <span class="p">{}}</span> <span class="o">=</span> <span class="p">{}){</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">url</span><span class="o">:</span> <span class="nx">url</span><span class="p">,</span>
            <span class="nx">method</span><span class="o">:</span> <span class="nx">method</span><span class="p">,</span>
            <span class="nx">headers</span><span class="o">:</span> <span class="nx">headers</span>
        <span class="p">};</span>
    <span class="p">};</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ajax</span><span class="p">());</span> <span class="c1">// {url: &quot;http://localhost:8080/sourceTest/es6/destructuring_assignment.html&quot;, method: &quot;GET&quot;, headers: Object}</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ajax</span><span class="p">({</span><span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;myUrl&#39;</span><span class="p">,</span> <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span><span class="nx">contentType</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">}}));</span> <span class="c1">// {url: &quot;myUrl&quot;, method: &quot;POST&quot;, headers: Object}                  </span>
  <span class="p">}</span>
</code></pre></div></li>
</ul></li>
<li><p>그 밖의 표현식     </p>

<ul>
<li><p>(할당)패턴 없이, 값을 할당할 경우에는 그 값을 <strong>객체</strong>로 변환 후, 해당 속성값을 할당시킨다</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">length</span><span class="o">:</span> <span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// [].length</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">toString</span><span class="o">:</span> <span class="nx">xx</span><span class="p">}</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">// {}.toString</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xx</span><span class="p">);</span> <span class="c1">// toString function object</span>

      <span class="c1">// 할당될 값에 (할당)패턴이 적용된 경우...</span>
      <span class="kd">let</span> <span class="p">{</span><span class="nx">toString</span><span class="o">:</span> <span class="nx">_xx</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nx">toString</span><span class="o">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c1">// {}.toString</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_xx</span><span class="p">);</span> <span class="c1">// 1                  </span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">length</span><span class="o">:</span> <span class="nx">xxx</span><span class="p">}</span> <span class="o">=</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">;</span> <span class="c1">// === new String(&#39;mohwa&#39;).length</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xxx</span><span class="p">);</span> <span class="c1">// 5</span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">toString</span><span class="o">:</span> <span class="nx">xxxx</span><span class="p">}</span> <span class="o">=</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">;</span> <span class="c1">// === new String(&#39;mohwa&#39;).toString</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xxxx</span><span class="p">);</span> <span class="c1">// toString function object</span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">toFixed</span><span class="o">:</span> <span class="nx">xxxxx</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// new Number(1).toFixed</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xxxxx</span><span class="p">);</span> <span class="c1">// toFixed function object</span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">valueOf</span><span class="o">:</span> <span class="nx">xxxxxx</span><span class="p">}</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// new Boolean(true).valueOf</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xxxxxx</span><span class="p">);</span> <span class="c1">// valueOf function object</span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">length</span><span class="o">:</span> <span class="nx">xxxxxxx</span><span class="p">}</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){};</span> <span class="c1">// function(x){}.length</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xxxxxxx</span><span class="p">);</span> <span class="c1">// 1</span>

      <span class="kd">let</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="nx">xxxxxxxx</span><span class="p">}</span> <span class="o">=</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">;</span> <span class="c1">// new String(&#39;mohwa&#39;).xx</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">xxxxxxxx</span><span class="p">);</span> <span class="c1">// undefined</span>

      <span class="c1">// undefined 와 null 값은 예외가 발생한다.</span>

      <span class="k">try</span><span class="p">{</span>
          <span class="kd">let</span> <span class="p">{</span><span class="nx">toString</span><span class="o">:</span> <span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// === undefined.toString</span>
      <span class="p">}</span>
      <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// Cannot match against &#39;undefined&#39; or &#39;null&#39;.</span>
      <span class="p">}</span>

      <span class="k">try</span><span class="p">{</span>
          <span class="kd">let</span> <span class="p">{</span><span class="nx">toString</span><span class="o">:</span> <span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// === null.toString</span>
      <span class="p">}</span>
      <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// Cannot match against &#39;undefined&#39; or &#39;null&#39;.</span>
      <span class="p">}</span>

  <span class="p">}</span>
</code></pre></div></li>
<li><p><strong>Symbol</strong> 을 통한 해체 할당</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">k</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">();</span>
      <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>

      <span class="kd">let</span> <span class="p">{[</span><span class="nx">k</span><span class="p">]</span><span class="o">:</span> <span class="nx">x</span><span class="p">}</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="p">}</span>        
</code></pre></div></li>
</ul></li>
</ul></li>
</ul>

<h2 id="url">관련 URL</h2>

<ul>
<li><p><a href="http://www.2ality.com/2015/01/es6-destructuring.html">Destructuring and parameter handling in ECMAScript 6</a><p></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring assignment</a><p></p></li>
<li><p><a href="http://hacks.mozilla.or.kr/2015/12/es6-in-depth-collections/">ES6 In Depth: 컬렉션 (Collections)</a><p></p></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/03/24/es6-destructuring-assignment/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/02/24/es6-const/">ES6 const</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-02-24">
                Feb 24, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <h2 id="1">1. 글에 대해</h2>

<ul>
<li>모든 결과는 <strong>Chrome 브라우저</strong>를 통해 테스트된 결과입니다.</li>
</ul>

<h2 id="2-const">2. const 키워드</h2>

<ul>
<li><span style="color:#c11f1f">const</span> 키워드는 <span style="color:#c11f1f">let</span> 키워드와 유사한 <strong>언어 매커니즘</strong>을 가지고있다.</li>
</ul>

<h2 id="3-es5-amp-const">3. <span style="color:#c11f1f">ES5</span> &amp; <span style="color:#c11f1f">const</span></h2>

<ul>
<li><h3 id="object-defineproperty-or-create-const">Object.<span style="color:#c11f1f">defineProperty</span> or <span style="color:#c11f1f">create</span> 메서드를 통해, <span style="color:#c11f1f">읽기전용</span> 속성을 생성할 수 있다(단 일반적인 방법으로 (속성)<strong>값</strong>을 <span style="color:#c11f1f">재 할당</span>시 <span style="color:#c11f1f">const</span> 키워드와 같은 예외가 발생하지는 않는다)</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global ec</span>

  <span class="c1">// globalEC.VO 객체에 읽기 전용 속성을 생성한다.(이떄 생성된 a 속성은 변수가 아니다)</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">});</span>

  <span class="c1">// VO 객체의 a 속성 값을 변경한다.</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// 읽기 전용 속성으로 값이 변경되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>

  <span class="c1">// writable 속성의 기본값은 false 이며, 반드시 속성을 정의할 필요는 없다.</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">//    writable: false,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">});</span>

  <span class="c1">// VO 객체의 b 속성 값을 변경한다.</span>
  <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// 읽기 전용 속성으로 값이 변경되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// 1</span>

  <span class="c1">// global ec</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// A function ec</span>

      <span class="c1">// AO 객체는 직접 접근할 수 없다. 즉 AO 객체의 읽기 전용 속성을 생성할 수 없다는 단점이 존재한다.</span>

      <span class="c1">// 하지만 ES6 의 const 키워드를 통해서는 생성 가능하다.</span>
      <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>

  <span class="p">})();</span>

  <span class="c1">// obj 객체에 읽기 전용 속성 생성하기</span>
  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="c1">// Object.defineProperty 메서드를 통해 생성하는 방법은 아래와 같다.</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">});</span>

  <span class="c1">// 속성값을 변경한다</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// 읽기 전용 속성으로 값이 변경되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>

  <span class="c1">// Object.create 메서드를 통해 생성하는 방법은 아래와 같다.</span>
  <span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">x</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>
      <span class="p">}</span>
  <span class="p">});</span>

  <span class="c1">// 속성값을 변경한다</span>
  <span class="nx">obj2</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// 읽기 전용 속성으로 값이 변경되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>

  <span class="c1">// 인스턴스의 속성을 읽기 전용으로 초기화하는 방법은 아래와 같다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

      <span class="c1">// 읽기 전용</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>
      <span class="p">});</span>

      <span class="c1">// 읽기/쓰기</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// 새로운 인스턴스를 생성한다.</span>
  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">;</span>

  <span class="c1">// 생성된 인스턴스의 속성값을 변경한다</span>
  <span class="nx">newAObject</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// 생성된 인스턴스의 속성값을 변경한다</span>
  <span class="nx">newAObject</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// 읽기 전용 속성으로 값이 변경되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>

  <span class="c1">// 읽기/쓰기 속성이며, 변경된 값인 2를 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></li>
<li><h3 id="object-defineproperty">Object.<span style="color:#c11f1f">defineProperty</span> 메서드를 통해, <span style="color:#c11f1f">읽기 전용</span> 속성을 <span style="color:#c11f1f">재 정의</span> 시, <span style="color:#c11f1f">재 정의</span>대한 <span style="color:#c11f1f">예외</span>가 발생하게된다.</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span>
  <span class="p">});</span>

  <span class="c1">// 단 Object.defineProperty 메서드를 통해 읽기 전용 속성을 재 정의 시, 재 정의에 대한 예외가 발생하게된다.</span>
  <span class="k">try</span><span class="p">{</span>

      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="mi">2</span>
      <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Cannot redefine property: a</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>

<h2 id="4-es6-amp-const">4. <span style="color:#c11f1f">ES6</span> &amp; <span style="color:#c11f1f">const</span></h2>

<ul>
<li><p><span style="color:#c11f1f">const</span> 키워드를 통해 선언된 <strong>상수</strong>는, 블럭 범위의 <span style="color:#c11f1f">Isolated Scope</span>(격리된 유효범위) 를 갖게된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="c1">// block scope</span>

      <span class="c1">// const 키워드를 통한 변수 선언</span>
      <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
      <span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="mi">1</span><span class="p">){</span>
      <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
          <span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">d</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">d</span><span class="o">++</span><span class="p">){</span>
      <span class="kr">const</span> <span class="nx">_d</span> <span class="o">=</span> <span class="nx">d</span><span class="p">;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_d</span><span class="p">);</span> <span class="c1">// 0, 1, 2</span>
  <span class="p">}</span>

  <span class="kr">const</span> <span class="nx">e</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 a 상수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// a is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 b 상수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// b is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 c 상수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// c is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 d 상수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_d</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// _d is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="c1">// 4</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">const</span> 키워드를 통해 선언된 <strong>상수</strong>의 <strong>유효 범위</strong>는 자신을 포함한 <span style="color:#c11f1f">블럭</span> 및 그 <span style="color:#c11f1f">내부 블럭</span>까지 유효하다. </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="p">{</span>
          <span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

          <span class="p">{</span>
              <span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

              <span class="p">{</span>
                  <span class="kr">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

                  <span class="c1">// 선언된 상수의 유효 범위는 자신을 포함한 블럭 및 그 내부 블럭까지 유효하다</span>
                  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span> <span class="c1">// 1, 2, 3, 4</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1;</span>

      <span class="c1">// 해당 블럭 Scope 에서는 b 상수에 접근할 수 없다.</span>
      <span class="k">try</span><span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="c1">// b is not defined</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
      <span class="p">}</span>

  <span class="p">}</span>
</code></pre></div></li>
<li><p>동일 블럭 범위에서, 동일한 <strong>식별자 이름</strong>으로 상수를 <span style="color:#c11f1f">재 선언</span>시 <span style="color:#c11f1f">예외</span>가 발생하게된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 동일 블럭 범위에서, 동일한 식별자 이름으로 변수를 재 선언시, 아래와 같은 예외가 발생하게된다.</span>

  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;obj&#39; has already been declared</span>

  <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="c1">// Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared</span>
      <span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
      <span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;i&#39; has already been declared</span>
  <span class="p">}</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
      <span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;c&#39; has already been declared</span>
  <span class="p">})();</span>

  <span class="c1">// 다른 식별자 이름으로 선언 시 예외가 발생하지 않는다.</span>
  <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span> <span class="c1">// 2</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">const</span> 키워드를 통해 선언된 상수 <strong>값</strong>을 <span style="color:#c11f1f">재 할당</span> 시 예외가 발생하게 된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// Uncaught TypeError: Assignment to constant variable.</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// 당연한 말이겠지만, 선언된 obj 객체의 속성까지 상수 범위가 적용되지는않는다.</span>
  <span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>

  <span class="c1">// x 속성은 읽기/쓰기 속성으로 선언되어있다.</span>

  <span class="c1">// Object {value: 1, writable: true, enumerable: true, configurable: true}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">));</span> 

  <span class="nx">obj</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">const</span> 키워드를 통해 선언된 <strong>상수</strong>는 <span style="color:#c11f1f">EC</span> 진입 및 실행 코드 처리 후에도 <span style="color:#c11f1f">VO</span> 의 새로운 속성으로 추가되지않는다..</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global ec 진입 시 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// a is not defined</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// 할당된 값을 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>

  <span class="c1">// 실행 코드 처리후에도 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div></li>
<li><p>동일 <span style="color:#c11f1f">VO</span>(AO) 범위에서, 동일한 <strong>식별자 이름</strong>으로 변수(or 함수) <span style="color:#c11f1f">선언</span> 시 <span style="color:#c11f1f">예외</span>가 발생하게 된다.(단 <span style="color:#c11f1f">const</span> 키워드를 통해 선언된 변수는 <span style="color:#c11f1f">VO</span> 의 속성으로 추가되지않는다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 테스트 1</span>
  <span class="c1">// global ec</span>
  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// globalEC.VO.a</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>

  <span class="c1">// 테스트 2</span>
  <span class="c1">// global ec</span>
  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">{</span>
      <span class="c1">// globalEC.VO.a</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="p">}</span>

  <span class="c1">// 테스트 3</span>
  <span class="c1">// global ec</span>
  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
      <span class="c1">// globalEC.VO.a</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="p">}</span>

  <span class="c1">// 테스트 4</span>
  <span class="c1">// global ec</span>
  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// globalEC.VO.a</span>
  <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="kd">function</span> <span class="nx">a</span><span class="p">(){</span>

      <span class="c1">// a function ec</span>
  <span class="p">}</span>

  <span class="c1">// 테스트 5</span>
  <span class="c1">// global ec</span>
  <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// A function ec</span>

      <span class="c1">// 이 경우 a 변수는 globalEC.VO 의 속성으로 추가되며, 마찬가지로 예외가 발생하게된다.</span>

      <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="p">})();</span>

  <span class="c1">// 테스트 6</span>
  <span class="c1">// global ec</span>
  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// function ec</span>

      <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="c1">// 이 경우 a 변수는 AFunctionEC.AO 의 속성으로 추가되며, 마찬가지로 예외가 발생하게된다.</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">})();</span>

  <span class="c1">// 테스트 7</span>
  <span class="c1">// global ec</span>
  <span class="kr">const</span> <span class="nx">a</span><span class="p">;</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// A function ec</span>

      <span class="c1">// 이 경우 a 변수는 AFunctionEC.AO 의 속성으로 추가되며, 예외가 발생하지않는다.</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// undefined</span>
  <span class="p">})();</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">루프</span>(for, while 등)문 내부에서 (<span style="color:#c11f1f">const</span> 키워드를 통해)선언된 변수는, <span style="color:#c11f1f">비동기 함수</span>안에서 각기 다른 <span style="color:#c11f1f">상수</span>를 <span style="color:#c11f1f">참조</span>하게된다.(즉 각 <span style="color:#c11f1f">루프</span>는 서로 다른 <span style="color:#c11f1f">상수</span>(값)를 가지게 된다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global scope</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// block scope</span>

      <span class="c1">// 루프문 내부에 const 키워드를 통해 선언된 상수</span>
      <span class="kr">const</span> <span class="nx">_i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>

      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

          <span class="c1">// 이 경우 _i 상수는 각기 다른 상수 값을 참조하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_i</span><span class="p">);</span> <span class="c1">// 0 ~ 9</span>

          <span class="c1">// var 키워드를 통해 선언된 i 변수는, 함수 Scope Chain 매커니즘에 의해 최종 증감값인 10을 참조하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 10</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 10;</span>

  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// block scope</span>

      <span class="kr">const</span> <span class="nx">_i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
      <span class="c1">// const 키워드를 통해 상수를 선언한다.</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// 이 경우 _i 상수는 각기 다른 변수 값을 참조하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_i</span><span class="p">);</span> <span class="c1">// 4 ~ 1</span>
      <span class="p">});</span>

      <span class="nx">i</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ES5 를 통한 구현은 아래와 같다.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>

      <span class="c1">// 루프 순회 시 (읽기 전용 속성)재 정의에 대한 예외가 발생하게 된다.</span>

      <span class="c1">// Uncaught TypeError: Cannot redefine property: _i</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;_i&#39;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nx">value</span><span class="o">:</span> <span class="nx">i</span>
      <span class="p">});</span>

      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_i</span><span class="p">);</span> <span class="c1">// 0 ... error</span>
      <span class="p">});</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">eval 함수</span>를 통해, 선언된 상수는 <span style="color:#c11f1f">local sandbox</span> 안에서 평가된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;const i = 1&#39;</span><span class="p">);</span>

  <span class="k">try</span><span class="p">{</span>
      <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// i is not defined</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>

<h2 id="url">관련 URL</h2>

<ul>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/const">const</a><p></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2016/02/23/es6-let/">let</a><p></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/14/vo-inJS/">Variable Object in JS</a><p></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/14/variable-inJS/">Variable in JS</a></p></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/02/24/es6-const/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/02/23/es6-let/">ES6 let</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-02-23">
                Feb 23, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <h2 id="1">1. 글에 대해</h2>

<ul>
<li>모든 결과는 <strong>Chrome 브라우저</strong>를 통해 테스트된 결과입니다.</li>
</ul>

<h2 id="2-es5-amp-var">2. <span style="color:#c11f1f">ES5</span> &amp; <span style="color:#c11f1f">var</span></h2>

<ul>
<li><h3 id="var"><span style="color:#c11f1f">var</span> 키워드를 통한 변수 선언</h3>

<ul>
<li><p><span style="color:#c11f1f">ES5</span> 는 오직 function execution context 내부에서만 <span style="color:#c11f1f">Isolated Scope</span>(격리된 유효범위) 를 가질 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global ec</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// A function ec</span>

      <span class="c1">// AFunctionEC.AO.a</span>
      <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="p">(</span><span class="kd">function</span> <span class="nx">B</span><span class="p">(){</span>

          <span class="c1">// B function ec</span>

          <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

          <span class="c1">// BFunctionEC.AO.a</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 2</span>
      <span class="p">})()</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="p">}</span>

  <span class="c1">// globalEC.VO.a</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 0</span>

  <span class="nx">A</span><span class="p">();</span>
</code></pre></div></li>
<li><p>즉 <span style="color:#c11f1f">ES5</span> 는 <strong>클래스 기반 언어</strong>인 C or C++ 처럼, 블럭 내부에 <span style="color:#c11f1f">Isolated Scope</span>(격리된 유효범위) 를 가질 수 없다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global ec</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>

      <span class="c1">// if 문 블럭 내부의 local context 를 갖지않는다.</span>
      <span class="c1">// 즉 선언된 변수 a 는 다른 값(1)으로 대치된다.</span>
      <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// globalEC.VO.a</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></li>
</ul></li>
</ul>

<h2 id="3-es6-amp-let">3. <span style="color:#c11f1f">ES6</span> &amp; <span style="color:#c11f1f">let</span></h2>

<ul>
<li><p><span style="color:#c11f1f">let</span> 키워드를 통해 선언된 <strong>변수</strong>는, 블럭 범위의 <span style="color:#c11f1f">Isolated Scope</span>(격리된 유효범위) 를 갖게된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global scope</span>

  <span class="p">{</span>
      <span class="c1">// block scope</span>

      <span class="c1">// let 키워드를 통한 변수 선언</span>
      <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
      <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="mi">1</span><span class="p">){</span>
      <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
          <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">d</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">d</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span> <span class="c1">// 0, 1, 2</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">e</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 a 변수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// a is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 b 변수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// b is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 c 변수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// c is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// 실행 코드 처리 시, 블록 범위에 선언된 d 변수는 선언되지 않았다는 예외가 발생하게 된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// d is not defined</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="c1">// 4</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">let</span> 키워드를 통해 선언된 <strong>변수</strong>의 <strong>유효 범위</strong>는 자신을 포함한 <span style="color:#c11f1f">블럭</span> 및 그 <span style="color:#c11f1f">내부 블럭</span>까지 유효하다. </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

          <span class="p">{</span>
              <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

              <span class="p">{</span>
                  <span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

                  <span class="c1">// 선언된 변수의 유효 범위는 자신을 포함한 블럭 및 그 내부 블럭까지 유효하다</span>
                  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span> <span class="c1">// 1, 2, 3, 4</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1;</span>

      <span class="c1">// 해당 블럭 Scope 에서는 b 변수에 접근할 수 없다.</span>
      <span class="k">try</span><span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="c1">// b is not defined</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
      <span class="p">}</span>

  <span class="p">}</span>
</code></pre></div></li>
<li><p>동일 블럭 범위에서, 동일한 <strong>식별자 이름</strong>으로 변수를 <span style="color:#c11f1f">재 선언</span>시 <span style="color:#c11f1f">예외</span>가 발생하게된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 동일 블럭 범위에서, 동일한 식별자 이름으로 변수를 재 선언시, 아래와 같은 예외가 발생하게된다.</span>

  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>
  <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>

  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">b</span><span class="p">;</span>
      <span class="c1">// Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared</span>
      <span class="kd">let</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
      <span class="kd">let</span> <span class="nx">i</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">i</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;i&#39; has already been declared</span>
  <span class="p">}</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
      <span class="kd">let</span> <span class="nx">c</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">c</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;c&#39; has already been declared</span>
  <span class="p">})();</span>

  <span class="c1">// 다른 식별자 이름으로 선언 시 예외가 발생하지 않는다.</span>
  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">c</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">d</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span> <span class="c1">// undefined</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">let</span> 키워드를 통해 선언된 <strong>변수</strong>는 <span style="color:#c11f1f">EC</span> 진입 및 실행 코드 처리 후에도 <span style="color:#c11f1f">VO</span> 의 새로운 속성으로 추가되지않는다.</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/20160223/let_1.png" alt=""></p>

<ul>
<li><p><em>변수(a)가 <strong>Scope</strong> 에는 존재하지만, 초기화 되지않는 이 단계를 가리켜 Temporal Dead Zone(일시적 사각 지대)라고 부르며, 관련 <strong>예외</strong> 또한 모두 구현되어있다.</em></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global ec 진입 시 VO 의 새로운 속성으로 추가되지않는다.</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// a is not defined</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 할당된 값을 반환한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>

<span class="c1">// 실행 코드 처리후에도 VO 의 새로운 속성으로 추가되지않는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div></li>
</ul></li>
<li><p>동일 <span style="color:#c11f1f">VO</span>(AO) 범위에서, 동일한 <strong>식별자 이름</strong>으로 변수(or 함수) <span style="color:#c11f1f">선언</span> 시 <span style="color:#c11f1f">예외</span>가 발생하게 된다.(단 <span style="color:#c11f1f">let</span> 키워드를 통해 선언된 변수는 <span style="color:#c11f1f">VO</span> 의 속성으로 추가되지않는다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 테스트 1</span>
  <span class="c1">// global ec</span>
  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>
  <span class="c1">// globalEC.VO.a</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>

  <span class="c1">// 테스트 2</span>
  <span class="c1">// global ec</span>
  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">{</span>
      <span class="c1">// globalEC.VO.a</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="p">}</span>

  <span class="c1">// 테스트 3</span>
  <span class="c1">// global ec</span>
  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
      <span class="c1">// globalEC.VO.a</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="p">}</span>

  <span class="c1">// 테스트 4</span>
  <span class="c1">// global ec</span>
  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>

  <span class="c1">// globalEC.VO.a</span>
  <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="kd">function</span> <span class="nx">a</span><span class="p">(){</span>

      <span class="c1">// a function ec</span>
  <span class="p">}</span>

  <span class="c1">// 테스트 5</span>
  <span class="c1">// global ec</span>
  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// A function ec</span>

      <span class="c1">// 이 경우 a 변수는 globalEC.VO 의 속성으로 추가되며, 마찬가지로 예외가 발생하게된다.</span>

      <span class="nx">a</span><span class="p">;</span> <span class="c1">// Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared</span>
  <span class="p">})();</span>

  <span class="c1">// 테스트 6            </span>
  <span class="c1">// global ec</span>
  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// function ec</span>

      <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>

      <span class="c1">// 이 경우 a 변수는 AFunctionEC.AO 의 속성으로 추가되며, 마찬가지로 예외가 발생하게된다.</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>
  <span class="p">})();</span>

  <span class="c1">// 테스트 7</span>
  <span class="c1">// global ec</span>
  <span class="kd">let</span> <span class="nx">a</span><span class="p">;</span>

  <span class="p">(</span><span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// A function ec</span>

      <span class="c1">// 이 경우 a 변수는 AFunctionEC.AO 의 속성으로 추가되며, 예외가 발생하지않는다.</span>
      <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// undefined</span>
  <span class="p">})();</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">루프</span>(for, while 등)문 내부에서 (<span style="color:#c11f1f">let</span> 키워드를 통해)선언된 변수는, <span style="color:#c11f1f">비동기 함수</span>안에서 각기 다른 <span style="color:#c11f1f">변수</span>를 <span style="color:#c11f1f">참조</span>하게된다.(즉 각 <span style="color:#c11f1f">루프</span>는 서로 다른 <span style="color:#c11f1f">변수</span>(값)를 가지게 된다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global scope</span>

  <span class="c1">// 루프 문 밖에서 let 키워드를 통해 선언된 변수</span>
  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// block scope</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// 이 경우 i 변수는 최종 증감값인 10 을 반환하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 10</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// global scope</span>

  <span class="c1">// 루프문 내부에 let 키워드를 통해 선언된 변수</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// block scope</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// 이 경우 i 변수는 각기 다른 변수 값을 참조하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 0 ~ 9</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// global scope</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// block scope</span>

      <span class="c1">// 루프문 내부에 let 키워드를 통해 선언된 변수</span>
      <span class="kd">let</span> <span class="nx">_i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>

      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// 이 경우 _i 변수는 각기 다른 변수 값을 참조하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_i</span><span class="p">);</span> <span class="c1">// 0 ~ 9</span>
          <span class="c1">// var 키워드를 통해 선언된 i 변수는, 함수 Scope Chain 매커니즘에 의해 최종 증감값인 10을 참조하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 10</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 10;</span>

  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// block scope</span>

      <span class="kd">let</span> <span class="nx">_i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
      <span class="c1">// let 키워드를 통해 변수를 선언한다.</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// 이 경우 _i 변수는 각기 다른 변수 값을 참조하게된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_i</span><span class="p">);</span> <span class="c1">// 4 ~ 1</span>
      <span class="p">});</span>

      <span class="nx">i</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 위 결과를 ES5 를 통해 구현한 방법은 아래와 같다.</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>

      <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">i</span><span class="p">){</span>

          <span class="c1">// Function.AO.i</span>
          <span class="c1">// bind 함수를 통해 바인딩된 AO.i 값을 참조하게 된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 0 ~ 9</span>
      <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">i</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// 최종 증감값인 10을 반환하게된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">// 10</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">eval 함수</span>를 통해, 선언된 변수(or 함수)는 <span style="color:#c11f1f">local sandbox</span> 안에서 평가된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;let i&#39;</span><span class="p">);</span>

  <span class="k">try</span><span class="p">{</span>
      <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// i is not defined</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>

<h2 id="url">관련 URL</h2>

<ul>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/let">let</a><p></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/14/vo-inJS/">Variable Object in JS</a><p></p></li>
<li><p><a href="http://exploringjs.com/es6/ch_variables.html#leanpub-auto-the-temporal-dead-zone">Variables and scoping</a><p></p></li>
<li><p><a href="https://medium.com/@dduskim/es6-in-depth-let-and-const-%EB%B2%88%EC%97%AD-31028c086e72#.c48zfoehd">ES6 In Depth: let and const(번역)</a><p></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/14/variable-inJS/">Variable in JS</a></p></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/02/23/es6-let/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/02/18/es6-arrow-function/">ES6 Arrow Function & This Test</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-02-18">
                Feb 18, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <h2 id="1">1. 글에 대해</h2>

<ul>
<li><p>이 글은 <span style="color:#c11f1f">ES5</span> 및 <span style="color:#c11f1f">ES6</span> <strong>Arrow Function</strong> 안에서 <span style="color:#c11f1f">this</span> 값이 어떤식으로 평가되는지에 대한 내용을 다루고있다.</p></li>
<li><p>또한 모든 결과는 <strong>Chrome 브라우저</strong>를 통해 테스트된 결과입니다.</p></li>
</ul>

<h2 id="2-es5-amp-this">2. <span style="color:#c11f1f">ES5</span> &amp; <span style="color:#c11f1f">this</span></h2>

<ul>
<li><h3 id="this"><span style="color:#c11f1f">this</span> 값 초기화 테스트</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 선언한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>

      <span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// this 는 undefined 로 초기화되며, undefined 는 this 로 평가될 수 없으므로, 암묵적으로 global Object 로 변환된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>  <span class="c1">// global Object</span>
      <span class="p">}</span>

      <span class="c1">// AO 에 포함된 내부 함수를 호출한다.</span>
      <span class="nx">B</span><span class="p">();</span> <span class="c1">// AO.B();</span>

      <span class="c1">// 초기화된 this 값을 반환한다.</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// this 는 undefined 로 초기화되며, undefined 는 this 로 평가될 수 없으므로, 암묵적으로 global Object 로 변환된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">());</span> <span class="c1">// global Object</span>

  <span class="c1">// this 는 생성된 인스턴스로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">A</span><span class="p">());</span> <span class="c1">// A Object</span>

  <span class="c1">// this 는 null 로 초기화되며, null 은 this 로 평가될 수 없으므로, 암묵적으로 global Object 로 변환된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">));</span> <span class="c1">// global Object</span>

  <span class="c1">// this 는 전달된 {x: 1} 객체로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">}));</span> <span class="c1">// Object {x: 1}</span>

  <span class="c1">// this 는 전달된 {x: 2} 객체로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">apply</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">2</span><span class="p">}));</span> <span class="c1">// Object {x: 2}</span>

  <span class="c1">// this 는 전달된 {x: 2} 객체로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">bind</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">})());</span> <span class="c1">// Object {x: 3}</span>
</code></pre></div></li>
<li><p>바인딩된 <strong>익명 함수</strong> 내부에서의 <span style="color:#c11f1f">this</span> 값</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 버튼 객체를 생성한다.</span>
  <span class="kd">var</span> <span class="nx">btnElem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#btn1&#39;</span><span class="p">);</span>

  <span class="c1">// 생성된 버튼 객체에 click 이벤트를 바인딩한다.</span>
  <span class="nx">btnElem</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>

      <span class="c1">// 이 경우 this 값은 target element 인 btnElem 객체를 가리킨다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// btnElem object        </span>
  <span class="p">});</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">bind</span> 함수를 통해 (바인딩된)함수 내부 <span style="color:#c11f1f">this</span> 값을 <strong>전역</strong> 스코프의 <span style="color:#c11f1f">this</span> 값으로 <span style="color:#c11f1f">초기화</span> 시킬 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 버튼 객체를 생성한다.</span>
  <span class="kd">var</span> <span class="nx">btnElem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#btn1&#39;</span><span class="p">);</span>

  <span class="c1">// 생성된 버튼 객체에 click 이벤트를 바인딩한다.</span>
  <span class="nx">btnElem</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>

      <span class="c1">// 이 경우 this 값은 bind 함수를 통해 초기화된 this 값을 가리킨다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// global object</span>
  <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
</code></pre></div></li>
<li><h3 id="this-in-strict-mode"><span style="color:#c11f1f">this</span> 값 초기화 테스트 in <span style="color:#c11f1f">Strict Mode</span></h3>

<ul>
<li><p><span style="color:#c11f1f">Strict Mode</span> 에서는 <span style="color:#c11f1f">this</span> 값이 <strong>null</strong>, 또는 <strong>undefined</strong> 인 경우, 암묵적으로 <span style="color:#c11f1f">global Object</span> 로 변환되지 않는다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 선언한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>

      <span class="c1">// Strict Mode 선언</span>
      <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>

      <span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// this 는 undefined 로 초기화된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>  <span class="c1">// undefined</span>
      <span class="p">}</span>

      <span class="c1">// AO 에 포함된 내부 함수를 호출한다.</span>
      <span class="nx">B</span><span class="p">();</span> <span class="c1">// AO.B();</span>

      <span class="c1">// 초기화된 this 값을 반환한다.</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// this 는 undefined 로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">());</span> <span class="c1">// undefined</span>

  <span class="c1">// this 는 global object 로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">A</span><span class="p">());</span>

  <span class="c1">// this 는 생성된 인스턴스로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">A</span><span class="p">());</span> <span class="c1">// A Object</span>

  <span class="c1">// this 는 null 로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">));</span> <span class="c1">// global Object</span>

  <span class="c1">// this 는 전달된 {x: 1} 객체로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">}));</span> <span class="c1">// Object {x: 1}</span>

  <span class="c1">// this 는 전달된 {x: 2} 객체로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">apply</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">2</span><span class="p">}));</span> <span class="c1">// Object {x: 2}</span>

  <span class="c1">// this 는 전달된 {x: 2} 객체로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">bind</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">})());</span> <span class="c1">// Object {x: 3}</span>
</code></pre></div></li>
</ul></li>
<li><h3 id="this-in-object"><span style="color:#c11f1f">this</span> 값 초기화 테스트 in <span style="color:#c11f1f">Object</span></h3>

<ul>
<li><p><strong>객체 메서드</strong>에서의 <span style="color:#c11f1f">this</span> 는 해당 메서드를 내부 프로퍼티로 소유한 <span style="color:#c11f1f">객체</span>를 가리킨다.  </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">x</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>

          <span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
              <span class="c1">// this 는 undefined 로 초기화되며, undefined 는 this 로 평가될 수 없으므로, 암묵적으로 global Object 로 변환된다.</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// global Object</span>
          <span class="p">}</span>

          <span class="c1">// AO 에 포함된 내부 함수를 호출한다.</span>
          <span class="nx">B</span><span class="p">();</span> <span class="c1">// AO.B();</span>

          <span class="c1">// 초기화된 this 값을 반환한다.</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// 이 경우 this 는 해당 함수를 내부 프로퍼티로 소유한 객체를 가리킨다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">x</span><span class="p">());</span> <span class="c1">// A Object</span>
</code></pre></div></li>
</ul></li>
</ul>

<h2 id="3-es6-arrow-function-amp-this">3. <span style="color:#c11f1f">ES6</span> Arrow Function &amp; <span style="color:#c11f1f">this</span></h2>

<ul>
<li><p>Arrow Function 은 자신만의 <span style="color:#c11f1f">this</span>, arguments, super, new.target 이 <span style="color:#c11f1f">할당</span>되지 않는다.</p></li>
<li><p>Arrow Function 의 <span style="color:#c11f1f">this</span> 값은 <u>함수가 위치한 지점을 둘러싼, 전역/함수 스코프</u>의 <span style="color:#c11f1f">this</span> 값을 가리키며, <span style="color:#c11f1f">바인딩</span>된 후 변하지 않는다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global execution context</span>

  <span class="c1">// Arrow Function 을 할당한다.</span>
  <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

      <span class="c1">// A function execution context</span>

      <span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

          <span class="c1">// B function execution context</span>

          <span class="c1">// 이 경우 this 는 (B)함수를 둘러싼, (A)함수 스코프의 this(global Object) 값으로 초기화된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="nx">B</span><span class="p">();</span>

      <span class="c1">// 초기화된 this 값을 반환한다.</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// this 는 global object 로 초기화된 후 변하지 않는다. </span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">());</span> <span class="c1">// global Object</span>

  <span class="c1">// this 는 global object 로 초기화된 후 변하지 않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">A</span><span class="p">());</span> <span class="c1">// global Object</span>

  <span class="c1">// new 연산자를 통해 새로운 인스턴스 생성 시 에러가 발생한다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">A</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Uncaught TypeError: () =&gt; this is not a constructor</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// this 는 global object 로 초기화된 후 변하지 않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">));</span> <span class="c1">// global Object</span>

  <span class="c1">// this 는 global object 로 초기화된 후 변하지 않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">}));</span> <span class="c1">// global Object</span>

  <span class="c1">// this 는 global object 로 초기화된 후 변하지 않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">apply</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">2</span><span class="p">}));</span> <span class="c1">// global Object</span>

  <span class="c1">// this 는 global object 로 초기화된 후 변하지 않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">bind</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">})());</span> <span class="c1">// global Object</span>
</code></pre></div></li>
<li><p>바인딩된 <strong>익명</strong> (Arrow)<strong>함수</strong> 내부에서의 <span style="color:#c11f1f">this</span> 값</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 버튼 객체를 생성한다.</span>
  <span class="kd">var</span> <span class="nx">btnElem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#btn1&#39;</span><span class="p">);</span>

  <span class="c1">// 생성된 버튼 객체에 click 이벤트를 바인딩한다.</span>
  <span class="nx">btnElem</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

      <span class="c1">// 이 경우 arrow function 의 this 값은 해당 함수를 둘러싼 전역 스코프의 this 값으로 초기화된다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// global Object</span>

      <span class="c1">// 버튼 객체를 통해 명시적으로 접근한다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">btnElem</span><span class="p">);</span>
  <span class="p">});</span>
</code></pre></div></li>
<li><p>함수 객체 내부에서의 <span style="color:#c11f1f">Arrow Function</span> 의 <span style="color:#c11f1f">this</span> 값</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// arrow function</span>
      <span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="c1">// 이 경우 this 는 (B)함수를 둘러싼, (A)함수 스코프의 this(global Object) 값으로 초기화된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// global Object</span>
      <span class="p">};</span>

      <span class="nx">B</span><span class="p">();</span>

      <span class="c1">// 초기화된 this 값을 반환한다.</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="c1">// this 는 global Object 로 초기화된다.</span>
  <span class="nx">A</span><span class="p">();</span>
</code></pre></div></li>
<li><p>생성자 함수 객체 내부에서의 <span style="color:#c11f1f">Arrow Function</span> 의 <span style="color:#c11f1f">this</span> 값(<span style="color:#c11f1f">Arrow Function</span> 의 <span style="color:#c11f1f">this</span> 값을 <strong>동적 바인딩</strong>하기위한 방법)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// arrow function</span>
      <span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="c1">// 이 경우 this 는 (B)함수를 둘러싼, (A)함수 스코프의 this(A Object) 값으로 초기화된다.</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// A Object</span>
      <span class="p">};</span>

      <span class="nx">B</span><span class="p">();</span>

      <span class="c1">// 초기화된 this 값을 반환한다.</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="c1">// this 는 생성된 인스턴스로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">A</span><span class="p">());</span> <span class="c1">// A Object</span>
</code></pre></div></li>
<li><p><strong>객체 메서드</strong>에서의 <span style="color:#c11f1f">this</span> 는 해당 메서드를 둘러싼, 전역 스코프의 <span style="color:#c11f1f">this</span> 값으로 초기화된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">normalMethod</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// A object</span>
      <span class="p">},</span>
      <span class="nx">arrowMethod</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// global object</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// 이 경우 this 는 해당 함수를 내부 프로퍼티로 소유한 객체를 가리킨다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">normalMethod</span><span class="p">());</span> <span class="c1">// A Object</span>

  <span class="c1">// 이 경우 this 는 (arrowMethod)함수를 둘러싼, 전역 스코프의 this(global Object) 값으로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">arrowMethod</span><span class="p">());</span> <span class="c1">// global Object</span>
</code></pre></div></li>
<li><p>Arrow Function 내부에서의 <span style="color:#c11f1f">this</span> 값 변경</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">arrowMethod</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

          <span class="kd">var</span> <span class="nx">bindFn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// A object</span>
          <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">A</span><span class="p">)();</span>

          <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">};</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">arrowMethod</span><span class="p">());</span> <span class="c1">// global Object</span>
</code></pre></div></li>
<li><p>그 밖의 테스트</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 객체를 반환하기 위해서는 괄호 연산자 또는 return 문을 사용해야한다.</span>
  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span> <span class="p">};</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">());</span> <span class="c1">// undefined</span>
  <span class="p">}</span>

  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">());</span> <span class="c1">// {x: 1} object</span>
  <span class="p">}</span>

  <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span> <span class="p">};</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">());</span> <span class="c1">// {x: 1} object</span>
  <span class="p">}</span>

  <span class="c1">// IIFE(즉시 실행 함수) 는 아래와 같이 표현될수 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((()</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)());</span> <span class="c1">// 1</span>
</code></pre></div></li>
</ul>

<h2 id="url">관련 URL</h2>

<ul>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/%EC%95%A0%EB%A1%9C%EC%9A%B0_%ED%8E%91%EC%85%98">애로우 펑션</a><p /></p></li>
<li><p><a href="http://codepen.io/somethingkindawierd/post/es6-arrow-functions-this">ES6 Arrow Functions &amp; this</a><p /></p></li>
<li><p><a href="https://github.com/wlzla000/JavaScript-documents/blob/master/ECMAScript%206%20Arrow%20functions(Korean).md">화살표 함수(arrow functions)</a><p /></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/br230269(v=vs.94).aspx">Strict 모드(JavaScript)</a><p /></p></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/02/18/es6-arrow-function/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/02/15/es6-class/">ES6 Class #1</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-02-15">
                Feb 15, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <h2 id="1">1. 글에 대해</h2>

<ul>
<li><p>이 글은 <a href="https://www.facebook.com/hika00?fref=nf">Hika Maeng 님</a>이 추천해주신 <a href="http://www.yes24.com/24/goods/23904865">ECMAScript 6 길들이기</a>라는 책과 개인적인 테스트를 통해 작성되었습니다.</p></li>
<li><p>또한 모든 결과는 <strong>Chrome 브라우저</strong>를 통해 테스트된 결과입니다.</p></li>
</ul>

<h2 id="2">2. 클래스 선언 및 표현식</h2>

<ul>
<li><h3 id="es6-es5">ES6 클래스는 ES5 가 가진 <span style="color:#c11f1f"><a href="http://mohwa.github.io/blog/javascript/2016/02/05/proto/">객체 지향 모델</a></span>을 좀더 <span style="color:#c11f1f">명시적</span>으로 다룰수 있도록 개선된 새로운 모델이다.<br></h3></li>
<li><h3 id=">클래스 선언식</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// [&#39;yanione&#39;]</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

              <span class="c1">// ES6 클래스 body 는 기본적으로 strict mode 위에서 동작한다.</span>

              <span class="c1">// &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode functions</span>
              <span class="c1">// or the arguments objects for calls to them</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 프로토타입 맴버 선언</span>
      <span class="nx">getId</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 선언된 클래스는 기존 함수 객체와 거의 유사한 구조를 가지고 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// 선언된 클래스는 function 데이터 타입을 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// function</span>

  <span class="c1">// 선언된 클래스의 constructor 속성은 Function (생성자)함수 객체를 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// Function function object</span>

  <span class="c1">// 선언된 클래스가 가진 원형 객체</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

  <span class="c1">// 선언된 클래스의 prototype 객체 프로퍼티는 getId 맴버를 포함하고 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span><span class="p">);</span> <span class="c1">// getId function object</span>

  <span class="c1">// newAObject 객체를 생성한다.</span>
  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

  <span class="c1">// newAObject 객체의 __proto__ (내부)속성은, A.prototype (원형)객체를 참조하고있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

  <span class="c1">// newAObject 객체의 prototype chain 에는 A.prototype 객체가 존재하므로 아래 코드를 통해 true 를 반환하게 된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// true</span>

  <span class="c1">// newAObject 객체의 (생성자)함수(클래스)인 A 함수(클래스) 객체를 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// A class</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">newAObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// function</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// yanione</span>

  <span class="c1">// newAObject 객체는, ES5 의 (생성자)함수 객체를 통해 생성된 객체와 동일한 구조를 가지고있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p>선언된 클래스 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-1.png" alt=""></p>

<p>newAObject 객체 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_05.png" alt=""></p>

<p><h2>정리</h2></p>

<ul>
<li><span style="color:#c11f1f">A</span> 클래스는 기존 <span style="color:#c11f1f">함수</span> 객체와 거의 <span style="color:#c11f1f">유사한 구조</span>를 가지고 있다.<p></li>
<li><span style="color:#c11f1f">A</span> 클래스는 <span style="color:#c11f1f">function</span> 데이터 타입을 <span style="color:#c11f1f">반환</span>한다.<p></li>
<li><span style="color:#c11f1f">A</span> 클래스의 prototype 객체 프로퍼티는 선언된 <span style="color:#c11f1f">프로토타입 맴버</span>인 getId 메서드를 포함하고 있다.<p></li>
<li>newAObject.constructor 속성은 (생성자)함수인 <span style="color:#c11f1f">A</span> 함수(클래스) 객체를 참조하고 있다.<p></li>
<li>newAObject 객체는, ES5 의 (생성자)<span style="color:#c11f1f">함수</span> 객체를 통해 생성된 객체와 <span style="color:#c11f1f">동일한 구조</span>를 가지고있다.<br><br><br><br></li>
</ul></li>
<li><h3 id=">그밖의 테스트</h3>

<ul>
<li><p>클래스 <span style="color:#c11f1f">선언식</span>은 <span style="color:#c11f1f">EC 진입</span> 및 <span style="color:#c11f1f">실행 코드 처리</span> 후에도 <span style="color:#c11f1f">VO</span> 의 새로운 속성으로 추가되지않는다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// ec 진입 시 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// A is not defined</span>
  <span class="p">}</span>

  <span class="c1">// 클래스 선언식</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 실행 코드 처리후에도 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// undefined </span>
</code></pre></div></li>
<li><p>일반적인 <span style="color:#c11f1f">함수 호출</span>의 경우 아래와 같은 <span style="color:#c11f1f">예외</span>가 발생하게된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 일반적인 함수 호출의 경우 아래와 같은 예외가 발생하게된다.</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// call, apply, bind 메서드를 통해 호출한 경우에도 동일한 에러가 발생하게된다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">({});</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">.</span><span class="nx">apply</span><span class="p">({});</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_A</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">bind</span><span class="p">({});</span>
      <span class="nx">_A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ES5</span> 에서 <span style="color:#c11f1f">ES6</span> 클래스와 같이, 일반적인 <span style="color:#c11f1f">함수 호출</span>을 <strong>막는 방법</strong>은 아래와 같다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

      <span class="c1">// this 값 내부 prototype chain 에 A.prototype 이 존재하지 않는 경우</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">)){</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Uncaught TypeError: Class constructors cannot be invoked without \&#39;new\&#39;&#39;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// 인스턴스 맴버를 정의한다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>

      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 일반적인 함수 호출의 경우, 초기화된 this 값(global Object) 내부 prototype chain 에는 A.prototype 이 존재하지 않는다.(즉 예외가 발생하게된다)</span>
  <span class="nx">A</span><span class="p">();</span> <span class="c1">// Uncaught TypeError: Class constructors cannot be invoked without new\</span>

  <span class="c1">// 하지만 call(or apply, bind) 메서드를 통해, A.prototype 이 포함한 객체를 전달할 경우, (new 연산자가 생략된)일반적인 함수 호출을 막을수는 없다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span><span class="nx">age</span><span class="o">:</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="mi">18</span><span class="p">}}),</span> <span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">));</span> <span class="c1">// Object {id: &quot;yanione&quot;, name: &quot;mohwa&quot;, age: 18}</span>
</code></pre></div></li>
<li><p>선언된 클래스와 동일한 <strong>식별자 이름</strong>으로 선언 시 아래와 같은 에러가 발생한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언식</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 선언된 클래스와 동일한 식별자 이름으로 선언 시 아래와 같은 에러가 발생한다.</span>

  <span class="c1">// Uncaught SyntaxError: Identifier &#39;A&#39; has already been declared</span>
  <span class="c1">// var A;</span>
</code></pre></div>
<p><br><br><br><br>                    </p></li>
</ul></li>
<li><h3 id=">클래스 표현식</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 표현식</span>
  <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span><span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// [&#39;yanione&#39;]</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

              <span class="c1">// ES6 클래스는 기본적으로 strict mode 위에서 동작한다.</span>

              <span class="c1">// &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode functions</span>
              <span class="c1">// or the arguments objects for calls to them</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 프로토타입 맴버 선언</span>
      <span class="nx">getId</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 표현식에서 클래스명은 생략 가능하다.</span>
  <span class="kd">var</span> <span class="nx">_A</span> <span class="o">=</span> <span class="kr">class</span><span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// [&#39;yanione&#39;]</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

              <span class="c1">// ES6 클래스는 기본적으로 strict mode 위에서 동작한다.</span>

              <span class="c1">// &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode functions</span>
              <span class="c1">// or the arguments objects for calls to them</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 프로토타입 맴버 선언</span>
      <span class="nx">getId</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>     

  <span class="c1">// 선언된 클래스는 기존 함수 객체와 거의 유사한 구조를 가지고 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// 일반적인 함수 호출의 경우 함수 선언식과 동일한 예외가 발생하게된다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">new_AObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">_A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">);</span>
</code></pre></div>
<p>선언된 클래스 내부(<em>이전 <span style="color:#c11f1f">클래스 선언식</span>과 달리 &lt;function scope&gt; 내부에 <span style="color:#c11f1f">Script 속성</span>이 포함되지 않았다</em>)</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-2.png" alt=""></p>

<p>(기명) 클래스 표현식 결과</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_14.png" alt=""></p>

<p>(익명) 클래스 표현식 결과</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">new_AObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">_A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_15.png" alt=""></p>

<p><h2>정리</h2></p>

<ul>
<li>클래스 표현식은 클래스명에 대한 <span style="color:#c11f1f">기명</span> / <span style="color:#c11f1f">익명</span> 표현이 가능하다.<br><br><br><br><br></li>
</ul></li>
<li><h3 id=">그밖의 테스트</h3>

<ul>
<li><p>클래스 <span style="color:#c11f1f">표현식</span>은 <span style="color:#c11f1f">EC 진입</span> 시 <span style="color:#c11f1f">VO</span> 의 새로운 속성으로 추가되지않는다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// ec 진입 시 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// A is not defined</span>
  <span class="p">}</span>

  <span class="c1">// 표현식에서 클래스명은 생략 가능하다.</span>
  <span class="kd">var</span> <span class="nx">_A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span><span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 실행 코드 처리 후</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// undefined</span>

  <span class="c1">// 선언된 _A 변수에 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">_A</span><span class="p">);</span> <span class="c1">// A class</span>
</code></pre></div></li>
<li><p>선언된 클래스를 (<span style="color:#c11f1f">new</span> 연산자를 생략 후)<span style="color:#c11f1f"> 호출</span> 하면 에러가 발생한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="k">try</span><span class="p">{</span>
      <span class="c1">// 함수 호출</span>
      <span class="nx">A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul></li>
</ul>

<h2 id="3">3. 접근자 선언</h2>

<ul>
<li><p>접근자 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
          <span class="c1">// 접근자 사용을 위해 내부 속성인 __id__ 속성을 선언한다.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 접근자 생성 시 A.prototype 객체 내부에는 id 속성과 get/set 접근자 메서드가 생성되어있다.</span>
      <span class="nx">get</span> <span class="nx">id</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">set</span> <span class="nx">id</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
          <span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// A class</span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="c1">// get</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>

  <span class="c1">// set</span>
  <span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione2&#39;</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione2</span>
</code></pre></div>
<p>접근자 생성시 A.prototype 객체 내부에는 <span style="color:#c11f1f">id</span> 속성과 get/set <span style="color:#c11f1f">접근자</span> 메서드가 생성되어있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_06.png" alt=""></p>

<p>newAObject 객체 내부(newAObject 객체의 <span style="color:#c11f1f">인스턴스 맴버</span>로 <span style="color:#c11f1f">id</span> 속성이 추가된것을 볼 수 있다)     </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_07.png" alt=""><br><br><br><br></p></li>
<li><p>ES5 <span style="color:#c11f1f">인스턴스 맴버</span>를 통한 <span style="color:#c11f1f">접근자</span> 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">__id__</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// 객체(this) prototype chain 에 A.prototype 이 존재하는지 않는 경우         </span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

      <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">__id__</span><span class="p">;</span>

      <span class="c1">// ES5 에서는 오직 Object.defineProperty 메서드를 통해서만 접근자를 생성할 수 있다.</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">id</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">id</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">new_AObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>

  <span class="nx">new_AObject</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione2&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione2</span>
</code></pre></div>
<p>newAObject 객체 내부(이 경우 선언된 <strong>접근자 프로퍼티</strong>에 대한, 모든 <span style="color:#c11f1f">접근자</span> 메서드들이 <span style="color:#c11f1f">인스턴스 맴버</span>로 포함되는 <span style="color:#c11f1f">단점</span>(메모리)이 존재한다)</p>

<ul>
<li><p>즉 <span style="color:#c11f1f">new</span> 연산자를 통해 생성되는, 모든 객체에 선언된 모든 <span style="color:#c11f1f">접근자</span> 메서드가 생성되며, 그로인해 메모리가 낭비되는 <span style="color:#c11f1f">단점</span>이 존재한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// new 연산자를 통해 생성되는 모든 객체(인스턴스)에 선언된, 접근자 메서드가 생성되며, 그로인해 메모리가 낭비되는 단점이 존재한다.</span>
  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">newAObject2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject2</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_09.png" alt=""><br><br><br><br></p></li>
</ul></li>
<li><p>ES5 <span style="color:#c11f1f">프로토타입 맴버</span>를 통한 <span style="color:#c11f1f">접근자</span> 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 선언한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// A.prototype 객체에 id 속성에 대한 get/set 접근자 메서드를 생성한다.</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,{</span>
      <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
          <span class="c1">// 내부 속성인 __id__ 속성을 통해 접근자에 접근한다.</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span>
      <span class="p">},</span>
      <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>
</code></pre></div>
<p>Object.defineProperty 메서드를 통한, 접근자 생성시 A.prototype 객체 내부에는 <span style="color:#c11f1f">id</span> 속성과 get/set <span style="color:#c11f1f">접근자</span> 메서드가 생성되어있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_0-7.png" alt=""></p>

<p>newAObject 객체 내부(이 경우 ES6 에서의 <span style="color:#c11f1f">접근자 생성</span>과 같이, 선언된 모든 <span style="color:#c11f1f">접근자 메서드</span>들이 A.prototype 객체에 <span style="color:#c11f1f">할당</span>되며, 이전에 가졌던 (메모리 낭비에 대한)<span style="color:#c11f1f">단점</span>을 피할 수 있다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_0-6.png" alt=""><br><br><br><br>        </p></li>
</ul>

<h2 id="4">4. 정적 메서드 선언</h2>

<ul>
<li><p>정적 메서드 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(){</span>
      <span class="p">}</span>

      <span class="c1">// 정적 메서드 선언</span>
      <span class="kr">static</span> <span class="nx">post</span><span class="p">(</span><span class="nx">url</span><span class="p">){</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">url</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// A.post 메서드는 function 데이터 타입을 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// function</span>

  <span class="c1">// 선언된 정적 메서드는 해당 클래스의 새로운 속성으로 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// post function object</span>

  <span class="c1">// A.post.constructor 속성은 Function (생성자)함수 객체를 참조하고있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// Function function object</span>

  <span class="c1">// A.post 정적 메서드는 prototype 객체 프로퍼티를 갖지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// undefined</span>

  <span class="c1">// (생성자)함수 객체로 호출 시 아래와 같은 에러가 발생한다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;http://mohwa.com&#39;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="cm">/*</span>
<span class="cm">       Uncaught TypeError: post(url){</span>
<span class="cm">       this.url = url;</span>
<span class="cm">       } is not a constructor</span>
<span class="cm">      */</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_10.png" alt=""><br><br><br><br>                  </p></li>
<li><p>ES5 를 통한 정적 메서드 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">post</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="p">};</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// A function object</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// post function object</span>

  <span class="c1">// (생성자)함수 객체로 호출 시 새로운 객체가 생성된다.</span>
  <span class="kd">var</span> <span class="nx">newAPostObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;http://mohwa.com&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAPostObject</span><span class="p">);</span>
</code></pre></div>
<p>A 함수 객체 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_11.png" alt=""><p></p>

<p>newAPostObject 객체 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-3.png" alt=""><br><br><br><br></p></li>
</ul>

<h2 id="5">5. 제네레이트 메서드 선언</h2>

<ul>
<li><p>제네레이트 메서드 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(){</span>
      <span class="p">}</span>

      <span class="c1">// 제네레이터 메서드 선언</span>
      <span class="o">*</span> <span class="nx">post</span><span class="p">(){</span>
          <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
          <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// 선언된 제네레이터 메서드는 A 클래스의 prototype 객체 프로퍼티에 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// post function object</span>

  <span class="c1">// 제네레이터 메서드의 (생성자)함수 객체로 GeneratorFunction 함수 객체를 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">post</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// GeneratorFunction function object </span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">generator</span> <span class="o">=</span> <span class="nx">newAObject</span><span class="p">.</span><span class="nx">post</span><span class="p">();</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// 1</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// 2</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// 3</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">done</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>
<p><span style="color:#c11f1f">A</span> 클래스 내부(선언된 제네레이터 메서드는 A 클래스의 prototype 객체 프로퍼티에 할당된다)</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-5.png" alt=""><p></p>

<p>newAObject 객체 내부(제네레이터 메서드의 (생성자)함수 객체로 <span style="color:#c11f1f">GeneratorFunction</span> 함수 객체를 반환한다)</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-4.png" alt=""><p>                   </p></li>
</ul>

<h2 id="6">6. 클래스 상속</h2>

<ul>
<li><p>ES6 에서는 <span style="color:#c11f1f">extends</span> 절 및 <span style="color:#c11f1f">super</span> 키워드를 통해 상속을 구현할 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
      <span class="c1">// 이 경우 this 는 new C 를 통해 생성된 객체를 가리킨다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// 클래스가 아닌 함수 객체에 대한 상속도 가능하다.</span>
  <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

          <span class="c1">// super 키워드를 통해 인스턴스 맴버 초기화 및 위임 과정이 발생한다.</span>
          <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>

          <span class="c1">// 이 경우 this 는 new C 를 통해 생성된 객체를 가리킨다.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">getName</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 클래스 상속</span>
  <span class="kr">class</span> <span class="nx">C</span> <span class="kr">extends</span> <span class="nx">B</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>

          <span class="c1">// super 키워드를 통해 인스턴스 맴버 초기화 및 위임 과정이 발생한다.</span>
          <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>

          <span class="c1">// 이 경우 this 는 new C 를 통해 생성된 객체를 가리킨다.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">getAge</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">,</span> <span class="mi">35</span><span class="p">));</span>
</code></pre></div></li>
<li><p><s><strong>chrome 48 버전</strong>의 결과</s></p>

<p><img src="/blog/assets/images/posts/20160203/class_12.png" alt=""><br><br><br><br></p></li>
<li><p><strong>chrome 49 버전</strong>을 통해 다시 확인해본결과, 이전 결과와 달라진것을 볼 수 있다.</p>

<ul>
<li><strong>인스턴스 이름</strong>이 <strong>A</strong> ==&gt; <strong>C</strong> 로 바뀐것은 맞는듯한데, 그 하위의 <strong>prototype chain 이름</strong>들이 상이?한듯 하다.(즉 <strong>C 인스턴스</strong>의 __proto__ 속성이 <strong>C.prototype</strong> 이 아닌, <strong>B.prototype</strong> 을 참조하고 있다고 출력하고 있다.(하지만 보여지는 <strong>prototype 객체</strong> 내부에는, <strong>C 클래스</strong>의 프로토타입 메서드인 <strong>getAge</strong> 를 포함하고 있는것을 볼 수 있다))</li>
</ul>

<p><img src="/blog/assets/images/posts/20160203/class_12_1.png" alt=""><br><br><br><br>                  </p></li>
<li><p><span style="color:#c11f1f">ES5</span> 를 통해 <span style="color:#c11f1f">클래스 상속</span>을 구현해본 예(ES6 에서의 <span style="color:#c11f1f">super</span> 키워드는 아래 <code>this.__proto__.constructor.call</code> 과 같은 일종의 <span style="color:#c11f1f"><a href="https://ko.wikipedia.org/wiki/%EB%A7%A4%ED%81%AC%EB%A1%9C_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">매크로</a></span> 구현으로 볼 수 있다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

      <span class="c1">// call 메서드를 통해 A (생성자)함수 객체(this.__proto__.__proto__.__proto__)가 가진 인스턴스 맴버를 초기화한다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span>  <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// B.prototype 객체 프로퍼티에 A.prototype (원형)객체를 포함한 새로운 객체를 할당한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">B</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">C</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>

      <span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>

      <span class="c1">// call 메서드를 통해 B (생성자)함수 객체(this.__proto__.__proto__)가 가진 인스턴스 맴버를 초기화한다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// C.prototype 객체 프로퍼티에 B.prototype (원형)객체를 포함한 새로운 객체를 할당한다.</span>
  <span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getAge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">C</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">newCObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">,</span> <span class="mi">35</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// yanione</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// mohwa</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">.</span><span class="nx">getAge</span><span class="p">());</span> <span class="c1">// 35</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_13.png" alt=""><br><br><br><br></p></li>
<li><p><strong>파생 클래스</strong>의 <strong>constructor</strong>(생성자) 내부에서는 반드시 <span style="color:#c11f1f">super</span> 키워드가 호출되어야한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// 클래스가 아닌 함수 객체에 대한 상속도 가능하다.</span>
  <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

          <span class="c1">// 파생 클래스의 constructor 내부에서는 super 키워드만을 사용(호출)하거나, this 키워드 사용전에 반드시 호출되어야한다.</span>
          <span class="c1">// 즉 constructor 내부에서는 super 키워드가 반드시 호출되어야한다.</span>
      <span class="p">}</span>

      <span class="nx">getName</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">try</span><span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// 아래와 같은 예외가 발생한다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// this is not defined</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">super</span> 키워드가 <span style="color:#c11f1f">this</span> 처리 후에 호출될 경우, 예외가 발생된다.(반드시 <span style="color:#c11f1f">this</span> 사용전에 호출되어야한다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// 클래스가 아닌 함수 객체에 대한 상속도 가능하다.</span>
  <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

          <span class="c1">// 반드시 this 사용전에 호출되어야한다.</span>
          <span class="c1">// super(id);</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
              <span class="c1">// Uncaught ReferenceError: this is not defined</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="c1">// 이 경우 super 키워드는 처리되지 않는다.</span>
          <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="nx">getName</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">));</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">super</span> 키워드를 통해, <strong>부모 클래스</strong>에 선언된 <span style="color:#c11f1f">static method</span> 에 접근 가능하다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kr">static</span> <span class="nx">x</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// 파생 클래스의 constructor 내부에서는 반드시 super 키워드가 호출되어야한다.</span>
      <span class="kr">super</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kr">static</span> <span class="nx">y</span><span class="p">()</span> <span class="p">{</span>

      <span class="c1">// static 메서드 내부 &quot;this&quot; 는 &quot;B class&quot; 와 동일하다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// B class</span>

      <span class="c1">// &quot;super&quot; 는 &quot;this.__proto__(A class)&quot; 와 동일하다.</span>

      <span class="c1">// 즉 this.__proto__.x() 메서드를 통해 호출 가능하다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x method</span>

      <span class="c1">// super 를 통한 접근</span>
      <span class="kr">super</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x method</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// var _B = new B();</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ES5</span> 를 통해, 위 <span style="color:#c11f1f">super</span> 키워드의 <strong>특성</strong>을 구현해본 예</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
  <span class="p">}</span>

  <span class="c1">// A 함수 객체의 x static method 를 생성한다.</span>
  <span class="nx">A</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="c1">// B 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">B</span><span class="p">(){</span>
  <span class="p">}</span>

  <span class="c1">// B 함수 객체의 y static method 를 생성한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="c1">// this(B function object).__proto__(A function object).x 메서드에 접근 가능하다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// === super.x();</span>
  <span class="p">};</span>

  <span class="c1">// B 함수 객체의 __proto__ 속성은 A 함수 객체를 참조하고있다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">A</span><span class="p">;</span>

  <span class="nx">B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span> <span class="c1">// x method</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">super</span> 키워드를 통해, 부모 클래스에 선언된 <span style="color:#c11f1f">prototype method</span> 에 접근 가능하다.                     </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">x</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>

      <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">y</span><span class="p">()</span> <span class="p">{</span>

      <span class="c1">// this.__proto__(B.prototype).__proto__(A.prototype).x()</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x method</span>

      <span class="c1">// super 키워드는 this.__proto__.__proto__ 와 같다.</span>
      <span class="kr">super</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// === this.__proto__.__proto__.x() === x method</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">_B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">_B</span><span class="p">);</span> <span class="c1">// {id: &quot;yanione&quot;, name: &quot;mohwa&quot;}</span>

  <span class="nx">_B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ES5</span> 를 통해, 위 <span style="color:#c11f1f">super</span> 키워드의 <strong>특성</strong>을 구현해본 예</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// A 함수 객체의 x static method 를 생성한다.</span>
  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="c1">// B 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

      <span class="c1">// this.__proto__.__proto__.constructor(A function object)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// B.prototype 에, A.prototype 을 원형으로 갖는 새로운 객체를 할당한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

  <span class="c1">// y prototype method 를 생성한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>

      <span class="c1">// this(B instance).__proto__(B.prototype).__proto__(A.prototype).x</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// === super.x 와 같다 === x method</span>
  <span class="p">};</span>

  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">B</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">_B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_B</span><span class="p">);</span> <span class="c1">// {id: &quot;yanione&quot;, name: &quot;mohwa&quot;}</span>

  <span class="nx">_B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
</code></pre></div></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/02/15/es6-class/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/02/05/proto/">__proto__ 속성과 프로토타입 위임 과정</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-02-05">
                Feb 5, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <h2 id="1">1. 글에 대해</h2>

<ul>
<li><p>이 글은 (JS 위임 과정의 이해를 돕기 위한 글이 아닌)최근 시작한 <a href="https://www.facebook.com/groups/es567/">ES567 스터디 그룹</a>의 연구 과제를 위해 작성된 글이다.</p>

<ul>
<li><em>그 이해를 돕기위한 내용은 이 <a href="http://mohwa.github.io/blog/javascript/2015/10/16/prototype/">글</a>을 참고할 수 있다.</em><p></li>
</ul></li>
<li><p>즉 글 전반적으로 <a href="http://krdic.naver.com/detail.nhn?docid=20817000">서술</a>된 글이 아닌, 테스트 코드와 그에 대한 주석을 통해 설명하고있다.</p></li>
</ul>

<h2 id="2">2. 위임(과정) 이란?</h2>

<ul>
<li><p>결국 객체들간의 <span style="color:#c11f1f">원형 복제 과정</span>을 말한다.(이 말을 잘 기억해두길 바란다)</p>

<ul>
<li><h3 id=">(생성자)<span style="color:#c11f1f">함수</span> (객체)를 통한 위임 과정</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="c1">// A 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

    <span class="c1">// function execution context</span>

<span class="p">}</span>

<span class="c1">// A 함수 객체의 prototype 프로퍼티로 포함된 원형 객체(이후 newAObject 객체로 위임될 객체이기도 하다)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="c1">// new 연산자와 A (생성자)함수 (객체)를 통해 새로운 객체가 생성된다.</span>
<span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">;</span>

<span class="c1">// newAObject 객체의 __proto__ (내부)속성은, A.prototype (원형)객체를 참조하고있다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// newAObject 객체의 (생성자)함수인 A 함수 (객체)를 반환한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// A function object</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// newAObject 객체의 prototype chain 에는 A.prototype 객체가 존재하므로 아래 코드를 통해 true 를 반환하게 된다.</span>

<span class="c1">// instanceof 연산자는 왼쪽 파라메터로 전달된 객체(newAObject)의 prototype chain 내부에, 오른쪽 파라메터로 전달된 함수 객체(A)의 prototype 프로퍼티가 존재한다면 true 를 반환하게된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// true</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_00.png" alt=""></p>

<h2 id=">정리</h2>

<ul>
<li>선언된 A 함수 객체는 <span style="color:#c11f1f">prototype</span> 이라는 (원형)<span style="color:#c11f1f">객체</span>를 가지고 있다.<p></li>
<li><span style="color:#c11f1f">new</span> 연산자를 통해 객체 생성시, A.prototype 객체는 newAObject 객체의 __proto__ (내부)속성으로 <span style="color:#c11f1f">위임</span>된다.<p></li>
<li>예상했던 결과와 같이, newAObject.constructor 속성은 (생성자)함수인 A 함수 객체를 참조하고 있다.<p></li>
</ul>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof 연산자</a><br><br><br><br></p></li>
<li><h3 id="object"><span style="color:#c11f1f">객체</span>(Object)를 통한 위임 과정</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// A 객체를 생성한다.</span>
<span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="nx">getId</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">setId</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// A.id 값을 초기화한다.</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">setId</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

<span class="c1">// B 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>

    <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// B.prototype 객체 프로퍼티에 getName 메서드를 할당한다.</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// B.prototype 객체가 가진 맴버들을, 위임할 객체(_A Object)에 추가하기위해, (임시)변수에 저장해둔다.</span>
<span class="kd">var</span> <span class="nx">__prototype__</span> <span class="o">=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="c1">// 위임할 A 객체를 복제한다.</span>
<span class="kd">var</span> <span class="nx">_A</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">id</span><span class="o">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
    <span class="nx">getId</span><span class="o">:</span> <span class="nx">A</span><span class="p">.</span><span class="nx">getId</span>
<span class="p">};</span>

<span class="c1">// 복제된 _A 객체를 B.prototype 객체 프로퍼티로 위임한다.</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">_A</span><span class="p">;</span>

<span class="c1">// __prototype__ 변수에 저장된 객체 맴버를, B.prototype 객체로 재 할당한다.</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="nx">__prototype__</span><span class="p">.</span><span class="nx">getName</span><span class="p">;</span>

<span class="c1">//B.prototype.constructor = B;</span>

<span class="c1">// newBObject 객체를 생성한다.</span>
<span class="kd">var</span> <span class="nx">newBObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

<span class="c1">// newBObject.__proto__ 속성은 B.prototype 객체를 참조하고 있다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// B.prototype 객체 프로퍼티는 복제된 _A 객체를 참조하고 있다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">_A</span><span class="p">);</span> <span class="c1">// true</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// yanione</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// mohwa</span>

<span class="c1">// instanceof 연산자 테스트</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="c1">// instanceof 연산자의 오른쪽 파라메터에는 반드시 함수 객체가 위치해야한다.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span> <span class="k">instanceof</span> <span class="nx">_A</span><span class="p">);</span> <span class="c1">// error</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="c1">// 에러가 발생한다.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// Expecting a function in instanceof check, but got #&lt;Object&gt;</span>
<span class="p">}</span>

<span class="c1">// newBObject 객체의 prototype chain 에는 B.prototype 객체가 존재하므로 아래 코드를 통해 true 를 반환하게 된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span> <span class="k">instanceof</span> <span class="nx">B</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// _A 객체의 위임 과정으로인해, newBObject.constructor 속성은 Object 함수 객체를 반환하게된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// Object function object</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_01.png" alt=""></p>

<h2 id=">정리</h2>

<ul>
<li><span style="color:#c11f1f">_A 객체</span>의 <span style="color:#c11f1f">위임</span> 과정으로인해, newBObject.constructor 속성은 (생성자)함수인 B 함수 객체가 아닌, <span style="color:#c11f1f">Object (생성자)함수 객체</span>를 참조하게된다.</li>
<li><p>위 상황을 <span style="color:#c11f1f">우회</span>(명확한 해결책은 아닌)하기 위해, 아래와 같은 코드를 추가할 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"> <span class="c1">// B.prototype 객체에 constructor 속성을 추가시킨다.</span>
 <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">B</span><span class="p">;</span>
</code></pre></div>
<p><br><br><br><br></p></li>
</ul></li>
<li><h3 id="new"><span style="color:#c11f1f">new</span> 연산자를 통한 위임 과정</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// A 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

    <span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// B 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>

    <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">__prototype__</span> <span class="o">=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

<span class="c1">// newAObject 객체를 B.prototype 객체 프로퍼티에 할당한다.</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">newAObject</span><span class="p">;</span>

<span class="c1">//B.prototype.constructor = B;</span>

<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="nx">__prototype__</span><span class="p">.</span><span class="nx">getName</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">newBObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

<span class="c1">// newBObject.__proto__.__proto__ 속성은 A.prototype 객체를 참조하고있다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// 즉 newBObject.__proto__.__proto__(A.prototype) 속성은 newAObject.__proto__(A.prototype) 속성과 동일하다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">newAObject</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">);</span> <span class="c1">// true</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// &#39;&#39;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// mohwa</span>

<span class="c1">// newBObject 객체의 prototype chain 에는 B.prototype 객체가 존재하므로 true 를 반환하게된다.</span>

<span class="c1">// newBObject.__proto__ === B.prototype</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span> <span class="k">instanceof</span> <span class="nx">B</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// newBObject 객체의 prototype chain 에는 A.prototype 객체도 존재하므로 true 를 반환하게된다.</span>

<span class="c1">// newBObject.__proto__.__proto__ === A.prototype</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// new A 객체의 위임 과정으로인해 newBObject.constructor 속성은 A 함수 객체를 참조하게된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// A function object</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_02.png" alt=""></p>

<h2 id=">정리</h2>

<ul>
<li>newBObject 객체 prototype chain 에는 <span style="color:#c11f1f">A.prototype 객체</span>와 <span style="color:#c11f1f">B.prototype 객체</span> 프로퍼티가 모두 존재하며, <span style="color:#c11f1f">instanceof 연산자</span>를 통해 모두 <span style="color:#c11f1f">true</span> 를 반환하게된다.<p></li>
<li><span style="color:#c11f1f">new A</span> 객체의 <span style="color:#c11f1f">위임</span> 과정으로인해, newBObject.constructor 속성은 B (생성자)함수 객체가 아닌, <span style="color:#c11f1f">A 함수</span> 객체를 참조하게된다.<br><br><br><br></li>
</ul></li>
<li><h3 id="object-create"><span style="color:#c11f1f">Object.create</span> 메서드를 통한 위임 과정</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// A 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

    <span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// B 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>

    <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">__prototype__</span> <span class="o">=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="c1">// Object.create 메서드를 통해 A.prototype 객체가 위임된, 새로운 객체가 생성된다.</span>
<span class="cm">/*</span>

<span class="cm">    {</span>
<span class="cm">       __proto__: A.prototype</span>
<span class="cm">    }</span>
<span class="cm">*/</span>
<span class="kd">var</span> <span class="nx">newObject</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="c1">// B.prototype 객체에 Object.create 메서드를 통해 생성된 객체를 할당한다.</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">newObject</span><span class="p">;</span>

<span class="c1">//B.prototype.constructor = B;</span>

<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="nx">__prototype__</span><span class="p">.</span><span class="nx">getName</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">newBObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// mohwa</span>

<span class="c1">// Object.create 메서드를 통한 위임 과정으로인해, newBObject.constructor 속성은 A 함수 객체를 참조하게된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// A function object</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_03.png" alt=""></p>

<h2 id=">정리</h2>

<ul>
<li><span style="color:#c11f1f">Object.create</span> 메서드를 통해 <span style="color:#c11f1f">new</span> 연산자를 통해서만 가능했던 <span style="color:#c11f1f">위임</span> 과정을 구현했다.<p></li>
<li><span style="color:#c11f1f">Object.create</span> 메서드를 통한 위임 과정으로인해, newBObject.constructor 속성은 B (생성자)함수 객체가 아닌, <span style="color:#c11f1f">A 함수</span> 객체를 참조하게된다.<p></li>
<li><span style="color:#c11f1f">Object.create</span> 메서드를 통한 위임 과정으로인해, 인스턴스 맴버인 <span style="color:#c11f1f">id</span> 속성을 초기화하지 못했다.(<em>반드시 <span style="color:#c11f1f">new</span> 연산자를 통해서만 인스턴스 맴버를 초기화할 수 있다</em>)<br><br><br><br></li>
</ul></li>
<li><h3 id="object-create">(인스턴스 맴버를 초기화하는)<span style="color:#c11f1f">Object.create</span> 메서드를 통한 위임 과정</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// A 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

    <span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// B 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

    <span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>

    <span class="c1">// call 메서드를 통해 A (생성자)함수 객체가 가진 인스턴스 맴버를 초기화한다.</span>
    <span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">__prototype__</span> <span class="o">=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">newObject</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

<span class="c1">// B.prototype 객체에 Object.create 메서드를 통해 생성된 객체를 할당한다.</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">newObject</span><span class="p">;</span>

<span class="c1">//B.prototype.constructor = B;</span>

<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="nx">__prototype__</span><span class="p">.</span><span class="nx">getName</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">newBObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// yanione</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// mohwa</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newBObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_04.png" alt=""></p>

<h2 id=">정리</h2>

<ul>
<li><span style="color:#c11f1f">call</span> 메서드를 통해 <span style="color:#c11f1f">B</span> (생성자)함수 객체 호출 시 생성된 <span style="color:#c11f1f">인스턴스 맴버</span>로, <span style="color:#c11f1f">A</span> (생성자) 함수 객체의 <span style="color:#c11f1f">인스턴스 맴버</span>인 <span style="color:#c11f1f">id</span> 속성이 초기화되었다.<p><br></li>
</ul></li>
</ul></li>
</ul>

<h2 id="url">관련 URL</h2>

<ul>
<li><p><a href="http://ddoong2.com/314">(객체지향) 비슷한것 같으면서도 다른 Attribute와 Property의 차이점</a><p /></p></li>
<li><p><a href="http://unikys.tistory.com/320">[속깊은 자바스크립트 강좌] 상속, new와 Object.create의 차이</a><p /></p></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/02/05/proto/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/02/01/select-box/">JQuery UI Select Box 구현</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-02-01">
                Feb 1, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <ul>
<li><p><a href="https://jqueryui.com/selectmenu/">JQuery UI</a> 에서 제공하고 있는 widgets 중 하나인 (Util)Selectmenu 를 구현한 예제이다.</p>

<ul>
<li>이전 <a href="http://mohwa.github.io/blog/javascript/2016/01/22/menu/">Menu UI</a> 와의 (구현 상)가장 큰 차이점으로는 (대치될)메뉴를 위한 사용자 정의 태그가 따로 존재하며, 또 그것을 바탕으로한 새로운 엘리먼트 영역을 구현한다는 점이다.<p></li>
<li>즉 <a href="http://www.qaupot.com/wordpress/?p=2078">전 처리</a> 과정을 통해, 사용자가 정의한 Semantic(의미 있는) 태그를 새로운 태그로 대치시킨다는 말이다.<p></li>
<li>또한, 대치될 Selectmenu 엘리먼트의 focus 이벤트 처리를 위해, 최상단 엘리먼트(<code>$(&#39;.select-menu-container&#39;)</code>)에 <code>tabindex=&quot;0&quot;</code> 속성 값을 할당한다.(blur 이벤트를 사용하기 위한 구현) </li>
</ul></li>
<li><p>구현 1(각 메뉴 영역을 border 값으로 구분지은 구성)</p>

<iframe height='300' scrolling='no' src='http://codepen.io/yanione/embed/OMEGbq/?height=300&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/OMEGbq/'>OMEGbq</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe></li>
<li><p>구현 2(각 메뉴 영역을 구분짓지않는 패턴(이는 요구 사항에 따라 얼마든지 변경될 수 있다))</p>

<iframe height='300' scrolling='no' src='//codepen.io/yanione/embed/wMXZyw/?height=300&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/wMXZyw/'>wMXZyw</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe>    </li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/02/01/select-box/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/01/22/menu/">JQuery UI Menu 구현</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-01-22">
                Jan 22, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <ul>
<li><p><a href="https://jqueryui.com/menu/">JQuery UI</a> 에서 제공하고 있는 widgets 중 하나인 (Util)Menu 를 구현한 예제이다.</p>

<ul>
<li>이전 <a href="http://mohwa.github.io/blog/javascript/2016/01/18/accordion-menu/">Accordion Menu</a>와 달리, JS 로직에 대한 비중보다는, HTML 설계에 따라 전체적인 구현 복잡도가 달라지는듯 하다.<p>

<ul>
<li><em>그 만큼 최초 HTML 설계가 중요하다고 할 수 있다.</em></li>
</ul></li>
<li><p>(기능 설계에 따라 달라지지만)실 구현 로직은 크게 어렵지 않으며, 코드 주석을 통해 어렵지않게 이해할 수 있을것이다.</p>

<iframe height='300' scrolling='no' src='http://codepen.io/yanione/embed/mVXdVa/?height=300&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'></iframe></li>
</ul></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/01/22/menu/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
      <li>
          <header class="post-header">
            <h1 itemprop="name" class="post-title">
              <a itemprop="url" class="post-link" href="/blog/javascript/2016/01/18/accordion-menu/">slideUp, slideDown, slideLeft, slideRight 함수 구현</a>
            </h1>
            <div class="tags cf">
              
                <a href="/blog/search/?category=javascript">javascript</a>&nbsp;
              
              <time itemprop="datePublished" datetime="2016-01-18">
                Jan 18, 2016
              </time>
            </div>
        </header>

        <article style="position: relative; width: 100%; height: 400px; overflow-y: hidden; margin-bottom: 15px;">
          <ul>
<li><p>JQuery 함수인 <a href="http://api.jquery.com/slideup/">slideUp</a> / <a href="http://api.jquery.com/slideDown/">slidedDown</a> 함수와 Accordion Menu 를 직접 구현한 예제이다.</p>

<ul>
<li><p><strong>코어</strong>(재귀를 통한 Animation 처리) 로직을 직접 구현해보기위한 예제이므로, 그 외 로직(<a href="http://mohwa.github.io/blog/architecture/2015/12/10/dom/">DOM</a> 처리, 조작 등)에서는 JQuery 를 사용하였다.<p></p>

<iframe height='300' scrolling='no' src='//codepen.io/yanione/embed/wMPvLr/?height=300&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/wMPvLr/'>wMPvLr</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe></li>
<li><p><strong>부드러운 움직임</strong>을 위한, 다향한 <a href="http://upshots.org/actionscript/jsas-understanding-easing">Easing</a> 기능이 추가된 예제이다.</p>

<ul>
<li><p><em>즉 Easing 을 통해 <strong>부드러운 움직임</strong>을 위한 <span style="color:#c11f1f">가속도</span>(사람은 속도에는 둔감해도 <span style="color:#c11f1f">가속도</span>에는 민감하다)를 적용할 수 있다.</em><p></p>
<div class="highlight"><pre><code class="language-html" data-lang="html">  속도에는 둔감하고 가속도에는 민감한 예를 들자면 차가 일정한 속도로 달리고 있을 때 우리는 이 차가 얼마나 빨리 움직이는 것인지 잘 모른다. 
  일정한 속도라면(즉, 가속도가 0이라면) 차안에서 가만히 서있을 수 있다. 하지만 급정거나 급출발하면 어떤가? 아무리 살짝(?) 급정거, 급출발을 해도 우리는 곧바로 느낄 수 있다. 
  우리 몸이 힘을 맞았기 때문이다. UI 애니메이션에서 easing은 이런 가속도를 매끄럽게 해주는 일을 한다.
</code></pre></div></li>
<li><p><a href="http://start.goodtime.co.kr/2015/02/%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-easing%EC%97%90-%EC%88%A8%EC%9D%80-%EB%B9%84%EB%B0%80/">애니메이션-easing에-숨은-비밀</a><p></p></li>
<li><p><a href="http://gizma.com/easing/">easing 테스트</a></p></li>
<li><p><a href="http://easings.net/">easing 함수 generator</a></p></li>
</ul>

<iframe height='300' scrolling='no' src='//codepen.io/yanione/embed/obogvX/?height=300&theme-id=0&default-tab=reslut' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/obogvX/'>obogvX</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe></li>
</ul></li>
<li><p>위 slideUp / Down 함수를 응용하여 slideRight / slidedLeft 함수를 구현한 예제이다.</p>

<ul>
<li><p><strong>코어</strong> 로직 중 Animation 처리를 위한 속성인 <span style="color:#6298c1">height</span> 속성이 <span style="color:#6298c1">width</span> 속성으로 변경된점을 제외하고는 <strong>동일</strong>하다.</p>

<iframe height='300' scrolling='no' src='//codepen.io/yanione/embed/adVzNo/?height=300&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/adVzNo/'>adVzNo</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe></li>
</ul></li>
<li><p>마지막으로 Menu Animation 이 구현된 예제이다.</p>

<iframe height='300' scrolling='no' src='//codepen.io/yanione/embed/JGOoOX/?height=300&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/JGOoOX/'>JGOoOX</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe></li>
</ul>

<h2 id="url">참고 URL</h2>

<ul>
<li><p><a href="http://upshots.org/actionscript/jsas-understanding-easing">Easing 처리에 대한 이해를 돕기위한 포스트</a></p></li>
<li><p><a href="http://shinluckyarchive.tistory.com/26">부드러운 모션 + 동적인 움직임</a></p></li>
<li><p><a href="http://www.kirupa.com/html5/animating_with_easing_functions_in_javascript.htm">Animating with Robert Penner&#39;s Easing Functions</a></p></li>
<li><p><a href="http://e-rooms.tistory.com/entry/Accodian-Pattern-Collection%EC%95%84%EC%BD%94%EB%94%94%EC%96%B8-%EB%A9%94%EB%89%B4">아코디언 메뉴 타입 모음</a></p></li>
</ul>

        </article>
        <p style="text-align: right"><a href="/blog/javascript/2016/01/18/accordion-menu/">Read more</a></p>
        <hr style="margin-bottom:30px; border:0; border-bottom: 1px dotted #ccc;" />
    </li>
  
  </ul>
</section>
<section class="pagination">
  <!-- Pagination links -->
  <ul class="pagination clearfix">
    
    <li><span class="disabled">Prev</span></li>
    
    
    <li><span class="active">1</span></li>
    
    
    
    <li><a href="/blog/page2">2</a></li>
    
    
    
    <li><a href="/blog/page3">3</a></li>
    
    
    
    <li><a href="/blog/page2">Next</a></li>
    
</ul>

</section>

      <div class="separator"></div>
    </div>
  </div>
  <footer>
    <section>
  <ul class="links">
      <li><a href="https://twitter.com/yanione" title="follow me" target="_blank"><i class="icon-twitter"></i></a></li>
      <li><a href="https://github.com/mohwa" title="github page" target="_blank"><i class="icon-github"></i></a></li>
  </ul>
<section>

  </footer>
  <script>
    <!-- Google Analytics -->
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-30470280-2', 'auto');
    ga('send', 'pageview');

    // include jekyll full text search
    // https://github.com/christian-fei/Simple-Jekyll-Search
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: '/blog/search.json',
      searchResultTemplate: '<li><a href="{href}">{title}</a>&nbsp;&nbsp;&nbsp;{date}</li>',
      noResultsText: 'No results found'
    });

  </script>
  <script src="http://b.readtrend.com/j/s.js"></script>
</body>
</html>
