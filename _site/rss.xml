<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
>

<channel>
    <title><![CDATA[Mohwa blog]]></title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <link href="/" />
    <description><![CDATA[]]></description>
    <lastBuildDate>Fri, 07 Aug 2015 17:35:23 +0900</lastBuildDate>
    <language>en-US</language>
    <generator uri="http://octopress.org/">Octopress</generator>

    
        <item>
            <title><![CDATA[Struct in JS]]></title>
            <link>/designpattern/2015/08/07/struct-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/struct-inJS/</guid>
            <description>
                <![CDATA[1. 정의 C 와 C++(또는 C# 등) 에서 구조화 된 데이터를 처리할 때, struct 를 사용하는데 이를 구조체라 부른다. 최초의 구조체는 C 언어에서 다양한 자료구조를 하나의 집합으로 만들어 관리하기위해 만들어졌다. 구조체는 하나 이상의 자료구조를 가진 또 하나의 데이터 타입을 정의한다. 구조화란? 정보를 쉽게 인출할 수 있도록 편성된 방식을 말한다. http://terms.naver.com/entry.nhn?docId=838410&amp;cid=42344&amp;categoryId=42344...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li><p>C 와 C++(또는 C# 등) 에서 <strong>구조화 된 데이터</strong>를 처리할 때, <strong>struct</strong> 를 사용하는데 이를 <a href="https://ko.wikipedia.org/wiki/Struct">구조체</a>라 부른다.</p>

<ul>
<li><p>최초의 <strong>구조체</strong>는 C 언어에서 다양한 <strong>자료구조</strong>를 하나의 <strong>집합</strong>으로 만들어 <strong>관리</strong>하기위해 만들어졌다.</p>

<ul>
<li>구조체는 하나 이상의 <strong>자료구조</strong>를 가진 또 하나의 <strong>데이터 타입</strong>을 정의한다.</li>
</ul></li>
<li><p><strong>구조화란?</strong> 정보를 쉽게 인출할 수 있도록 <strong>편성된 방식</strong>을 말한다.</p>

<ul>
<li><a href="http://terms.naver.com/entry.nhn?docId=838410&amp;cid=42344&amp;categoryId=42344">http://terms.naver.com/entry.nhn?docId=838410&amp;cid=42344&amp;categoryId=42344</a></li>
</ul></li>
<li><p>이 글은 <strong>구조체</strong>를 다루는 여러 언어 중 <strong>[<u>C# 구조체]</u></strong> 를 기준으로 다루고있다.</p></li>
</ul>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/struct_diagram.jpg?2" alt=""><br>
- 코드화</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">struct</span> <span class="nc">Song</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">yearRecorded</span><span class="p">;</span>

    <span class="c1">// 생성자</span>
    <span class="k">public</span> <span class="nf">Song</span><span class="p">(</span><span class="kt">int</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lengthInSeconds</span> <span class="p">=</span> <span class="n">p1</span><span class="p">;</span>
        <span class="n">yearRecorded</span> <span class="p">=</span> <span class="n">p2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestSong</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Initialize:</span>
        <span class="c1">// stack 메모리 영역에 객체가 할당된다.</span>
        <span class="n">Song</span> <span class="n">song1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Song</span><span class="p">(</span><span class="m">213</span><span class="p">,</span> <span class="m">1994</span><span class="p">);</span>
        <span class="n">Song</span> <span class="n">song2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Song</span><span class="p">(</span><span class="m">248</span><span class="p">,</span> <span class="m">1988</span><span class="p">);</span>

        <span class="c1">// Display results:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;lengthInSeconds = {0}, yearRecorded = {1}&quot;</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">yearRecorded</span><span class="p">);</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;lengthInSeconds = {0}, yearRecorded = {1}&quot;</span><span class="p">,</span> <span class="n">song2</span><span class="p">.</span><span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">song2</span><span class="p">.</span><span class="n">yearRecorded</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Output:</span>
<span class="cm">    lengthInSeconds = 213, yearRecorded = 1994</span>
<span class="cm">    lengthInSeconds = 248, yearRecorded = 1988</span>
<span class="cm">*/</span>
</code></pre></div>
<ul>
<li><p><strong>구조체</strong>는 <strong>Class</strong> 와 같이 여러 특성(생성자, 상수, 필드, 메서드, 속성, 인덱서, 연산자, 이벤트 등)들을 <strong>그룹화</strong> 하는데 사용된다.</p>

<ul>
<li><strong>구조체</strong>와 <strong>클래스</strong>는 매우 비슷한 <strong>구조</strong>를 가지고 있으며, <strong><u>사용 방법 및 적용 이유</u></strong>가 <strong>유사</strong>하다.</li>
</ul></li>
</ul></li>
</ul>

<h2>2. C# 구조체의 특징</h2>

<ul>
<li><p><strong><u>값 타입</u></strong>이다.</p>

<ul>
<li>값 형식 및 참조 형식

<ul>
<li><a href="https://msdn.microsoft.com/ko-kr/library/4d43ts61(v=vs.90).aspx">https://msdn.microsoft.com/ko-kr/library/4d43ts61(v=vs.90).aspx</a></li>
</ul></li>
<li><p>[Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing]</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/memoryDiagram.jpg?2" alt=""></p>

<ul>
<li><a href="http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-">http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-</a></li>
</ul></li>
</ul></li>
<li><p><strong>구조체</strong>는 보통 <u>작은 데이터</u>를 다루는데 <strong>적합</strong>하다.</p>

<ul>
<li><p>하지만 <strong>이것</strong>을 기존의 <strong>클래스</strong>로 <span style="color:red">표현할 수 없는 것</span>은 아니다.</p>

<ul>
<li><em>그럼에도 불구하고 *</em>구조체*<em>를 써야하는 이유는 <u>분명 존재</u>할 것이다.</em></li>
</ul></li>
</ul></li>
<li><p><strong>new</strong> 연산자를 사용하지 않고도 <strong>인스턴스화</strong>할 수 있다.</p>

<ul>
<li>생성된 <strong>객체</strong>는 <strong>Stack</strong> 영역에 할당된다.</li>
<li><u><strong>생성자</strong>를 호출하지 않으므로</u>, 선언된 맴버를 따로 <strong>초기화</strong> 해야하는 <span style="color:red">불편함</span>이 있다.</li>
<li>만약 <strong>new</strong> 연산자를 통해 <strong>인스턴스</strong>를 생성하더라도, <u><strong>Heap</strong> 영역이 아닌 <strong>Stack</strong> 영역에 <strong>객체</strong>가 할당된다.</u></li>
</ul>
<div class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">struct</span> <span class="nc">Song</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">yearRecorded</span><span class="p">;</span>

    <span class="c1">// 생성자</span>
    <span class="k">public</span> <span class="nf">Song</span><span class="p">(</span><span class="kt">int</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lengthInSeconds</span> <span class="p">=</span> <span class="n">p1</span><span class="p">;</span>
        <span class="n">yearRecorded</span> <span class="p">=</span> <span class="n">p2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestSongNoNew</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// new 연산자 없이 인스턴스를 생성한다.</span>
        <span class="c1">// stack 메모리 영역에 객체가 할당된다.</span>
        <span class="c1">// 생성자를 호출하지 않는다.</span>
        <span class="n">Song</span> <span class="n">song1</span><span class="p">;</span>

        <span class="c1">// 맴버 초기화</span>
        <span class="n">song1</span><span class="p">.</span><span class="n">lengthInSeconds</span> <span class="p">=</span> <span class="m">213</span><span class="p">;</span>
        <span class="n">song1</span><span class="p">.</span><span class="n">yearRecorded</span> <span class="p">=</span> <span class="m">1994</span><span class="p">;</span>

        <span class="c1">// Display results:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;lengthInSeconds = {0}, yearRecorded = {1}&quot;</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">yearRecorded</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Output:</span>
<span class="cm">    lengthInSeconds = 213, yearRecorded = 1994</span>
<span class="cm">*/</span>
</code></pre></div></li>
<li><p><strong>구조체</strong>는 <strong>구조체</strong> 또는 <strong>클래스</strong>에서 <u>상속될 수 없으며</u>, 클래스의 기본 클래스가 될 수 없다.</p>

<ul>
<li><strong>클래스</strong>와 달리, <u>상속 구조를 표현할 수 없다.</u></li>
</ul></li>
<li><p><strong>클래스</strong>와 같이 <u><strong>인터페이스</strong>를 구현할 수 있다.</u></p></li>
<li><p>구조체는 <strong>Stack</strong> 영역에 할당되는 <strong><span style="color:red">값 타입</span></strong>이고, 클래스는 <strong>Heap</strong> 영역에 할당되는 <strong><span style="color:red">참조 타입</span></strong>이다.</p>

<ul>
<li><p><strong>Stack</strong> 영역(<span style="color:red">정적 할당</span>)이란?</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/struct_stack.jpg" alt=""></p></li>
<li><p><strong>Stack</strong> 영역은 <strong>컴파일 시점</strong>에서 크기가 <strong>결정</strong>되는 요소들이 저장되는 <strong>메모리 영역</strong>이다.</p>

<ul>
<li>함수 내부 <strong>지역 변수</strong> 와 <strong>매개 변수</strong>는 <strong>Stack</strong> 영역에 할당되며, 함수 종료 시 <strong>소멸</strong>된다.</li>
</ul></li>
<li><p><strong>Stack</strong> 영역은 <strong>LIFO</strong>(Last In First out)라는 <strong>자료구조</strong> 가진다.</p>

<ul>
<li><p><em>즉 마지막에 넣은(Push) 데이터가 *</em>가장 먼저** 나가는것을(Pop) 의미한다.*</p>

<ul>
<li><p>Stack Push 순서:</p>

<ul>
<li>A &gt; B &gt; C &gt; D &gt; E</li>
</ul></li>
<li><p>Stack Pop 순서:</p>

<ul>
<li>E &gt; D &gt; C &gt; B &gt; A</li>
</ul></li>
</ul></li>
<li><p>그럼 <strong>JS Stack</strong> 은?</p>

<ul>
<li><p>JS 는 <a href="https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4"><strong>동적 언어</strong></a> 이므로 <strong>컴파일 시점</strong>이 아닌 <strong>런타임 시점</strong>에서 메모리가 <strong>할당</strong>(allocation)된다.</p>

<ul>
<li>C, C++, C#(<strong>정적 언어</strong>)</li>
</ul></li>
<li><p>JS <strong>원시 타입</strong>(string, number, boolean, undefined, null)은 <strong>고정된 크기</strong>를 가지며, <strong>Stack</strong> 메모리 영역에 할당된다.</p></li>
<li><p>JS 의 모든 <strong>실행 컨텍스트</strong>는 <span style="color:red">ECStack</span>(일종의 <a href="https://ko.wikipedia.org/wiki/%EC%BD%9C_%EC%8A%A4%ED%83%9D">Call Stack</a> 이다) 내부로 할당된다.</p>

<ul>
<li><span style="color:red">ECStack</span> 대한 <strong>상세 내용</strong>은 아래 <strong>링크</strong>로 대신하며, <u>꼭 한번 읽어 보길 바란다.</u></li>
<li>아래와 같은 방법으로 <strong>ECStack</strong> Count 를 셀 수 있다.</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getStackCount</span><span class="p">(){</span>

    <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">try</span><span class="p">{</span>
        <span class="p">(</span><span class="kd">function</span> <span class="nx">_stack</span><span class="p">(){</span>

            <span class="o">++</span><span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">();</span>
        <span class="p">})();</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>

        <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// get call stack count</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;call stack count: &#39;</span> <span class="o">+</span> <span class="nx">getStackCount</span><span class="p">());</span>

<span class="cm">/* output</span>

<span class="cm"> Maximum call stack size exceeded</span>

<span class="cm"> // 15,745 번 함수 호출 후 Stack overflow 가 발생했다.</span>
<span class="cm"> call stack count: 15745</span>

<span class="cm"> */</span>
</code></pre></div></li>
</ul></li>
</ul></li>
<li><p><strong>Heap</strong> 영역(<span style="color:red">동적 할당</span>)이란?</p>

<ul>
<li><strong>Heap</strong> 영역은 <strong>런타임 시점</strong>에서 크기가 <strong>결정</strong>되는 요소들이 저장되는 <strong>메모리 영역</strong>이다.

<ul>
<li><strong>Object</strong> 와 <strong>Array</strong> Data Type 등을 가진다.</li>
</ul></li>
<li><strong>Heap</strong> 영역은 <strong>런타임 시점</strong>에서 메모리를 <u><strong>가변적</strong>으로 <strong>동적 할당</strong> 및 <strong>반환</strong> 시키는 구조</u>이다.</li>
<li><p><strong>GC</strong>는 <strong>할당</strong>된 <strong>Heap</strong> 메모리 영역의 <span style="color:red">반환</span>(de-allocated)을 담당한다.</p>

<ul>
<li><p>[x] <strong>GC</strong>(Garbage Collection)란?</p>

<ul>
<li><strong>자동 메모리 관리</strong>의 한 형태이며, 프로세스 수행 중, 더 이상 필요가 없어진 <strong>객체</strong>가 점유하는 <u>메모리에 대해 <span style="color:red">반환</span> 작업을 수행</u>한다.</li>
<li><p>프로그래머가 직접 메모리를 <span style="color:red">반환</span>할 수 없다.(반드시 **GC**를 통해 반환된다)</p>

<ul>
<li></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>[x] JS <strong>Heap</strong> 메모리 영역 테스트 해보기!!</p>

<ul>
<li><p>JS <strong>Handle scope</strong> Diagram</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/handleV8.jpg" alt=""></p></li>
<li><p>아래 코드는 <strong>Heap</strong> 메모리 영역에 <strong>객체</strong>를 <span style="color:red">할당</span>하는 예제이다.</p></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="c1">// 전역 실행 컨텍스트에서 함수 객체를 하나 선언한다.</span>

<span class="c1">// 선언된 함수 객체는 Heap 메모리 영역에 할당된다.</span>
<span class="kd">function</span> <span class="nx">globalA</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">init</span><span class="p">(){</span>

    <span class="c1">// _global 전역 변수에 생성된 인스턴스를 할당한다.</span>
    <span class="c1">// 이때 전역 변수(참조 변수)는 Heap 메모리 영역에 할당된 객체를 참조하게된다.</span>

    <span class="nx">_global</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">globalA</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">init</span><span class="p">();</span>
</code></pre></div>
<ul>
<li><p><strong>전역 실행 컨텍스트</strong>에서 선언된 <strong>globalA</strong> 함수 객체의 <strong>Heap</strong> 메모리 영역.</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/heapSnapshot0.jpg?1" alt=""></p></li>
<li><p><strong>_global</strong> 전역 변수가 참조하는 <strong>객체</strong>의 <strong>Heap</strong> 메모리 영역.</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/heapSnapshot1.jpg?1" alt=""></p></li>
<li><p>개발 툴(<span style="color:red">Chrome Inspector</span>)을 통해 할당된 <strong>Heap 메모리 영역</strong>을 살펴볼 수 있다.</p>

<ul>
<li><a href="http://stackoverflow.com/questions/20697298/understanding-chrome-heap-profile">understanding chrome heap profile</a></li>
</ul></li>
<li><p>만약 함수 내부 <strong>지역 변수</strong>에 <strong>객체</strong>를 할당했다면, 그 객체(<strong>Heap</strong> 영역)의 메모리 <strong><span style="color:red">반환</span></strong> <strong>시점</strong>은 언제일까?</p>

<ul>
<li><p><em>결론: *</em>지역 변수<strong>에 할당된 **객체</strong> 메모리 <span style="color:red">반환</span> 시점은 <u><strong>함수 종료 시점</strong></u>이 된다.*</p>

<ul>
<li><p>테스트 1: **전역 변수**와 함수 내부 **지역 변수**에 동일한 **객체**를 할당해본 후 **Profile** 을 통해 **Heap** 영역을 관찰해본다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="c1">// 전역 실행 컨텍스트에서 함수 객체를 하나 선언한다.</span>

<span class="c1">// 선언된 함수 객체는 Heap 메모리 영역에 할당된다.</span>
<span class="kd">function</span> <span class="nx">globalA</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">init</span><span class="p">(){</span>

    <span class="c1">// _district 지역 변수에 생성된 인스턴스를 할당한다.</span>
    <span class="c1">// 이때 지역 변수(참조 변수)는 Heap 메모리 영역에 할당된 객체를 참조하게된다.</span>

    <span class="c1">// 단 지역 변수에 할당된 객체의 &quot;메모리 반환 시점&quot;은, 함수 종료 시점(함수 실행 컨텍스트 종료 시점)이 된다.</span>

    <span class="kd">var</span> <span class="nx">_district</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">globalA</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">init</span><span class="p">();</span>
</code></pre></div></li>
<li><p><code>지역 변수</code>에 할당된 <code>객체</code>는 <code>Heap</code> 메모리 영역에서 <span style="color:red">반환</span>되어 보이지 않는다.</p></li>
</ul>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/heapSnapshot2.jpg?1" alt=""></p></li>
</ul></li>
</ul></li>
<li><p><a href="http://dsnight.tistory.com/50">C언어의 메모리 구조</a></p></li>
<li><p><a href="http://egloos.zum.com/recipes/v/5057426">STACK, HEAP에 관한 소고</a></p></li>
<li><p><a href="https://kldp.org/node/44714">도대체 [구조체]가 [클래스]보다 좋은점이 뭔가요?</a></p></li>
<li><p><a href="https://opentutorials.org/course/1720/9735">메모리 구조</a></p></li>
<li><p><a href="http://adibong.tistory.com/169">프로그램과 메모리 , 스택과 힙</a></p>

<ul>
<li><em>개인적으로 이런 글을 좋아한다.(다양한 생각들을 들을 수 있으며, 그로인해 많은 *</em>영감*<em>을 얻기도 한다)</em></li>
</ul></li>
</ul></li>
</ul>

<h2>3. JS 로 구조체 구현해보기</h2>

<ul>
<li><p>위에서 나열한 <strong>구조체</strong>의 <strong>특징</strong> 중 <strong>클래스</strong>와 <strong>본질</strong>적으로 다른 부분인, <u><strong>데이터 생성</strong></u>에 대한 부분을 JS 를 통해 구현해 보았다.</p>

<ul>
<li>구조체: <strong>값</strong> 타입(<strong>Stack</strong> 메모리 영역에 할당되며, 값이 <span style="color:red">복사</span>되어 할당된다)</li>
<li>클래스: <strong>참조</strong> 타입(<strong>Heap</strong> 메모리 영역에 할당되며, <span style="color:red">참조</span> 값이 할당된다)</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Struct</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> <span class="o">||</span>
        <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="o">||</span>
        <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;boolean&#39;</span> <span class="o">||</span>
        <span class="nx">val</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span>
        <span class="nx">val</span> <span class="o">===</span> <span class="kc">undefined</span>
    <span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;primitive type value: &#39;</span> <span class="o">+</span> <span class="nx">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">_copy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>

        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">constructor</span> <span class="o">=</span> <span class="nx">val</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">){</span>

            <span class="c1">// 함수(상황에 따라 생성자 함수가 될 수도 있다) 객체 내부 this 값을 apply 함수를 통해 초기화 시키고, 그 결과를 반환하는 함수를 생성한다.</span>
            <span class="nx">ret</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$F</span><span class="p">(){</span>

                <span class="c1">// this === global or $F of instance object</span>
                <span class="k">return</span> <span class="nx">val</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
            <span class="p">};</span>

            <span class="c1">// 전달된 함수 객체의 prototype(객체 원형)을 할당한다.</span>
            <span class="nx">ret</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">val</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">String</span> <span class="o">||</span> <span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Number</span> <span class="o">||</span> <span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Boolean</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">constructor</span><span class="p">(</span><span class="nx">val</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Date</span><span class="p">){</span>
            <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">constructor</span><span class="p">(</span><span class="nx">val</span><span class="p">.</span><span class="nx">getTime</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Object</span> <span class="o">||</span> <span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Array</span><span class="p">){</span>

            <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">constructor</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">n</span> <span class="k">in</span> <span class="nx">val</span><span class="p">){</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">val</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">n</span><span class="p">)){</span>
                    <span class="nx">ret</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>

    <span class="p">}(</span><span class="nx">val</span><span class="p">)</span> <span class="o">||</span> <span class="nx">val</span><span class="p">;</span>


    <span class="k">return</span> <span class="nx">_copy</span><span class="p">;</span>
<span class="p">}</span>

    <span class="c1">// 5 가지의 원시 타입 값 할당</span>
<span class="nx">Struct</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">);</span> <span class="c1">// test</span>
<span class="nx">Struct</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">Struct</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">Struct</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">Struct</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// null</span>

<span class="cm">/*</span>
<span class="cm">    모든 경우(모든 타입)에 전달된 원본 값(객체)이 아닌 복사 된 값을 반환한다.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm"> 함수 객체 선언</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">$$</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">$$</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">_$$</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">_$$</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 나를통해 생성될 객체 원형에 새로운 객체를 할당한다.</span>
    <span class="nx">_$$</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">getX</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="nx">$$</span><span class="p">.</span><span class="nx">staticMethod</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>

    <span class="k">return</span> <span class="nx">$$</span><span class="p">;</span>
<span class="p">}();</span>

<span class="cm">/*</span>
<span class="cm"> 다른 유형의 함수 객체 선언</span>
<span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">Plus</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">){</span>

    <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

    <span class="kd">var</span> <span class="nx">originalFn</span> <span class="o">=</span> <span class="nx">$$</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">structFn</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="nx">$$</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn</span><span class="p">);</span> <span class="c1">// function</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn</span><span class="p">);</span> <span class="c1">// function</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn</span><span class="p">());</span> <span class="c1">// object</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn</span><span class="p">());</span> <span class="c1">// object</span>

    <span class="kd">var</span> <span class="nx">originalFn1</span> <span class="o">=</span> <span class="nx">Plus</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">structFn1</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="nx">Plus</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn1</span><span class="p">);</span> <span class="c1">// function</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn1</span><span class="p">);</span> <span class="c1">// function</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// 4</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// 5</span>

    <span class="kd">var</span> <span class="nx">structStr</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">));</span>
    <span class="kd">var</span> <span class="nx">structNum</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structStr</span><span class="p">);</span> <span class="c1">// string object</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structNum</span><span class="p">);</span> <span class="c1">// number object</span>

    <span class="kd">var</span> <span class="nx">structObject</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">});</span>
    <span class="kd">var</span> <span class="nx">structArray</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structObject</span><span class="p">);</span> <span class="c1">// object</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structArray</span><span class="p">);</span> <span class="c1">// array</span>

    <span class="kd">var</span> <span class="nx">structBoolean</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">));</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structBoolean</span><span class="p">);</span> <span class="c1">// boolean object</span>


    <span class="kd">var</span> <span class="nx">structDate</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">());</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structDate</span><span class="p">);</span> <span class="c1">// date object</span>
</code></pre></div>
<h2>4. 정리하며</h2>

<ul>
<li><p>그럼 언제 사용하면될까?</p>

<ul>
<li><p>개인적인 생각으로는 이럴때가 아닌가 싶다?</p>

<ul>
<li><p>클래스로 만들기에는 너무 간단한 구조인 경우.</p>

<ul>
<li><p>사실 이 경우, 반드시 <strong>구조</strong> 만의 문제는 아닐 수 있다.</p>

<ul>
<li>만약 모든 경우에 <strong>클래스</strong>를 사용한다면, 위에서 언급한 봐와같이 <strong>객체</strong>는 <strong>Heap</strong> 영역에 <span style="color:red">할당</span>될 것이며, 결국 <strong>GC</strong> 는 그 메모리 <strong>반환</strong>을 위해 쓸때 없는 리소스를 <strong>낭비</strong>하게 될 것이다.</li>
</ul></li>
</ul></li>
<li><p><strong>상속 구조</strong>를 만들 필요가 없는 경우.</p></li>
</ul></li>
<li><p>하지만, 이 두 가지 특징 모두 <strong><span style="color:red">각 언어</span></strong>(C/C++/C# 등 구조체를 가진 모든 언어)가 가지는 <strong><span style="color:red">특성</span></strong>에 따라 충분히 변할 수 있는 부분이므로 모든 언어에 <strong>적용</strong>된다고 말할 수는 없다.</p>

<ul>
<li><em>간단히 말해, 특정 <code>언어</code>가 <code>구조체</code>를 어떤 방식으로 <code>구현</code>하느냐에 따라, <code>사용 범위</code>도 크게 달라질 수 있다는 말과 같다.</em></li>
</ul></li>
</ul></li>
</ul>

<h2>5. 참고 URL</h2>

<ul>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/0taef578.aspx">C# 구조체 설명</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/0b0thckt.aspx">C# 클래스 설명</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/13266616/primitive-value-vs-reference-value">primitive value vs reference value</a></p></li>
<li><p><a href="http://codingnuri.com/javascript-tutorial/javascript-primitive-types-and-reference-types.html">원시 타입과 참조 타입</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/4d43ts61(v=vs.90).aspx">값 형식 및 참조 형식(Visual C# Express)</a></p></li>
<li><p><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/">What is the Execution Context &amp; Stack in JavaScript?</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/11148353/javascript-scope-and-execution-context">javascript-scope-and-execution-context</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[ObjectPool in JS]]></title>
            <link>/designpattern/2015/08/07/objectpool-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/objectpool-inJS/</guid>
            <description>
                <![CDATA[1. 정의 생성된 객체들을 별도의 Pool 안에 저장 후 재사용 하는 방법으로, 불필요한 객체 생성 및 반환(GC에 의한)을 최소화하는 디자인 패턴중 하나 이다. 객체 재사용을 위해, 생성된 객체를 Pool 안에 저장시켜 놓는다. 새로운 객체가 필요할때는, 무조건 새로 생성하는것이 아니라, Pool 안에 반환된 객체가 존재한다면, 그 중 하나를 재사용 한다. 객체...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li><p>생성된 <strong>객체</strong>들을 별도의 <strong>Pool</strong> 안에 저장 후 <span style="color:#c11f1f">재사용</span> 하는 방법으로, 불필요한 객체 <strong>생성</strong> 및 <strong>반환</strong>(<strong>GC</strong>에 의한)을 <span style="color:#c11f1f">최소화</span>하는 <u><strong>디자인 패턴</strong></u>중 하나 이다.</p>

<ul>
<li><strong>객체</strong>  <span style="color:#c11f1f">재사용</span>을 위해, 생성된 <strong>객체</strong>를 <strong>Pool</strong> 안에 저장시켜 놓는다.</li>
<li><p>새로운 <strong>객체</strong>가 필요할때는, <u>무조건 새로 <span style="color:#c11f1f">생성</span></u>하는것이 아니라, <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>된 <strong>객체</strong>가 존재한다면, <u>그 중 하나를 <span style="color:#c11f1f">재사용</span> 한다.</u></p>

<ul>
<li><em>객체 <span style="color:#c11f1f">재사용</span>으로 Heap 메모리 사용을 <span style="color:#c11f1f">최소화</span>한다.</em></li>
</ul></li>
<li><p>사용(객체)이 끝난 후에는 <u>다시 <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>시킨다.</u></p></li>
</ul></li>
</ul>

<h2>2. 특징</h2>

<ul>
<li><p>정해진 <strong>범위</strong>내에서 개발자가 직접 <u><strong>Heap 메모리</strong>를 관리(객체 <span style="color:#c11f1f">생성</span> 및 <span style="color:#c11f1f">반환</span>)</u>할 수 있다.</p>

<ul>
<li><p><u><strong>객체 생성 비용</strong></u>을 줄일 수 있다.(Heap 메모리 사용을 줄일 수 있다)</p>

<ul>
<li><em>당연한 말이겠지만, 생성되는 객체 <span style="color:#c11f1f">크기</span> 및 그 <span style="color:#c11f1f">수</span>에 따라, <u>더 많은 비용을 줄일 수도 있다.</u></em></li>
</ul></li>
<li><p><strong>GC</strong> 를 통해 일어나는, <u>메모리 <span style="color:#c11f1f">반환</span>(반환 시 일어나는 일련의 작업들)) <strong>비용</strong>을 줄일 수 있다.</u></p>

<ul>
<li>보통 이 과정(메모리 반환 과정)을 처리하는 동안에는, <strong>프로그램 실행</strong> 이 중단된다.</li>
<li>또한, 이 과정은 <u>프로그램 실행 중 <span style="color:#c11f1f">임의의 시간</span>에, <span style="color:#c11f1f">임의의 시간동안</span> 언제라도 일어날 수 있다.</u></li>
<li>개발자는 이 <strong>과정</strong>을 <u><span style="color:#c11f1f">제어</span>할 수 없다.</u></li>
</ul>

<p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
</ul></li>
<li><p><span style="color:#c11f1f">재사용</span>되는 <strong>객체</strong>는 <u>모두 <strong>동일한 타입</strong>을 갖는다.</u></p></li>
</ul>

<h2>3. JS 로 동적 ObjetPool 구현해보기</h2>

<iframe height='540' scrolling='no' src='http://codepen.io/yanione/embed/jPdzWB/?height=540&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/jPdzWB/'>jPdzWB</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe>

<ul>
<li>일반적인 동적 <strong>Objet Pool</strong> 기능을 만드는 방법은 위 코드와 같이 크게 어렵지 않다.(물론 지원하는 기능의 범위에 따라, 구현 수준은 크게 달라질 수 있다)</li>
</ul>

<h2>4. ObjectPool 적용 테스트</h2>

<ul>
<li><p>Click 버튼을 <span style="color:#c11f1f">10</span>번 누른 후 <strong>Profiles(in Chrome Tool) 패널</strong>을 통해, <strong>Heap Memory</strong> 를 체크하면 <span style="color:#c11f1f">적용</span> <strong>유/무</strong>에 따른 결과를 얻을 수 있다.</p>

<ul>
<li><p><strong>Object Pool</strong> 적용 전</p>

<ul>
<li><p><span style="color:#c11f1f">Ball</span> 생성자 함수를 통해 객체를 <strong>300</strong>개 할당했다.</p>

<ul>
<li>30 * 10 = 300(무조건 새로운 객체를 Heap 메모리에 할당했다)</li>
</ul></li>
</ul>

<p><img src="/blog/assets/images/posts/ballHeap.jpg" alt=""></p></li>
<li><p><strong>Object Pool</strong> 적용 후</p>

<ul>
<li><p><span style="color:#c11f1f">$F</span> 생성자 함수를 통해 <strong>93</strong>개의 객체를 할당했다.</p>

<ul>
<li><span style="color:#c11f1f">$F</span>: <strong>Object Pool</strong> 라이브러리상에서 만든 생성자 함수.</li>
<li>적용 후에는 총 <strong>93</strong>개의 객체를 <span style="color:#c11f1f">할당</span>했으며, <strong>207</strong>개의 객체를 <span style="color:#c11f1f">재사용</span>하였다.</li>
</ul></li>
</ul>

<p><img src="/blog/assets/images/posts/ballHeap2.jpg" alt=""></p></li>
</ul></li>
</ul>

<h2>5. 정리하며</h2>

<ul>
<li><p>즉 지나친 객체 <span style="color:#c11f1f">생성</span> 및 <span style="color`:#c11f1f">반환</span>을 <strong>최소화</strong> 하는것이, <strong>어플리케이션</strong>상에 <span style="color:#c11f1f">메모리 변동</span>을 줄이는 방법이며, 이로인해 사용자 경험까지 최적화할 수 있다.</p></li>
<li><p>일반적인 <strong>웹</strong>상에서는 적용할 일이 거의 없어보이지만, <strong>게임 어플리케이션</strong>이라면, 적용 범위가 꽤 많을 듯 하다.</p></li>
</ul>

<h2>6. 참고 URL</h2>

<ul>
<li><p><a href="http://ufx.kr/blog/591">액션스크립트의 객체 재사용을 위한 오브젝트 풀(Object Pool)</a></p></li>
<li><p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
<li><p><a href="http://beej.us/blog/data/object-pool/">Object Pools</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Interface in JS]]></title>
            <link>/designpattern/2015/08/07/interface-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/interface-inJS/</guid>
            <description>
                <![CDATA[1. 정의 가장 큰 범위의 인터페이스 정의는 사물 간 또는 사물과 인간 간(User Interface)의 의사소통을 위한 중간 매개체다. 즉 서로간의 의사소통을 위해 정해진 약속이 존재하며, 이를 표준 규격 이라 말할 수 있는것이다. 2. 의미 인터페이스(DB Interface): 구현 클래스가 공통적으로 가져야할 필수 특성(connect, disconnect 등)들을 선언함으로써, 해당 구현 클래스들에게 사용자(User Class)와의...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li>가장 큰 범위의 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">인터페이스</a> <code>정의</code>는 사물 간 또는 사물과 인간 간(<a href="https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">User Interface</a>)의 의사소통을 위한 중간 <span style="color:#c11f1f">매개체</span>다. 즉 서로간의 의사소통을 위해 정해진 약속이 존재하며, 이를 <code>표준 규격</code> 이라 말할 수 있는것이다.</li>
</ul>

<h2>2. 의미</h2>

<p><img src="/blog/assets/images/posts/interface_diagram.png" alt=""></p>

<ul>
<li><p><strong>인터페이스</strong>(<code>DB Interface</code>):</p>

<ul>
<li><p><strong>구현 클래스</strong>가 공통적으로 가져야할 필수 <span style="color:#c11f1f">특성</span>(connect, disconnect 등)들을 <strong>선언</strong>함으로써, 해당 구현 클래스들에게 <strong>사용자</strong>(<code>User Class</code>)와의 <strong>의사 소통</strong> 방침(<span style="color:#c11f1f">표준 규격</span>)을 알리는데 목적이 있다.</p>

<ul>
<li>[x] <em>인터페이스 내부에 선언된 모든 특성은 구현 클래스를 통해 반드시 구현되어야 한다.</em></li>
</ul></li>
</ul></li>
<li><p><strong>구현 클래스</strong>(<code>MSSQL, ORACLE API Class 등</code>):</p>

<ul>
<li><p>사용자(<code>User Class</code>)와의 의사소통을 위해 인터페이스 내부에 선언된 모든 특성들을 충실히 구현한다.</p>

<ul>
<li><p><em>이때 <code>사용자</code> 입장에서는 특정 구현 클래스 <code>명세</code> 없이도, 인터페이스 명세에 따라 제공받은 모든 API 를 사용할 수 있다는 장점이 존재한다.</em></p>

<ul>
<li>[x] <em>정확히 말하자면, 특정 API 의 모든 기능이 아닌 인터페이스를 구현한 기능에 한정된다.</em></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h2>3. 상황에 따른 의미</h2>

<ul>
<li><p>만약 운영중인 어플리케이션의 DB 플랫폼이 <strong>MSSQL</strong> 에서 <strong>PostgreSQL</strong> 로 변경된다고 가정해보자.(오랜 기간 운영중인 어플리케이션의 경우 이런저런 이유로 이와 같은 상황이 충분히 올 수 있다)</p>

<p>이때 위 다이어그과 같은 <code>인터페이스 설계</code>가 되어있는 상태라면, <strong>PostgreSQL</strong> 규격에 따라, 구현 클래스만 작성하면 최소 비용으로 기능을 <span style="color:#c11f1f">확장</span>할 수 있을 것이다.</p>

<ul>
<li><em>또 <code>사용자 입장</code>에서보면, 인터페이스를 통해 구현된, 공통적인 기능 만큼은 기존 코드를 <span style="color:#c11f1f">재사용</span>할 수 있다는 큰 장점까지 갖게 되는 것이다.(어플리케이션 유지보수 비용 최소화)</em></li>
</ul></li>
</ul>

<h2>4. JS 로 인터페이스 구현해보기</h2>

<iframe width="100%" height="1000" src="http://jsfiddle.net/mohwa/jzu5r06e/3/embedded/js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>인터페이스 <code>구현</code>은 아래 <strong>C# 인터페이스 가이드</strong>에 맞춰 구현되었으며, JS 코드에 대한 자세한 설명은 따로 하지 않겠다.(만약 JS 에 대해 어느정도 알고 있는 상황이라면, 코드를 분석해보길 권장한다)</p>

<ul>
<li><p>아래는 구현에 대한 간략한 설명이다.</p>

<ul>
<li><p>인터페이스 선언을 위한 인터페이스 함수 객체를 구현한다.</p>

<ul>
<li>인터페이스 [이벤트] 선언을 위해 <strong>Observer</strong> 기능을 구현한다.</li>
<li><a href="https://msdn.microsoft.com/ko-kr/library/awbftdfh.aspx">C# 이벤트 선언</a></li>
</ul></li>
<li><p>인터페이스를 상속받은 <strong>구현 클래스</strong>를 검증(상속받은 인터페이스를 모두 구현했는지에 대한 검증)하는 함수 객체(Interface.ensureImplement)를 구현한다.</p></li>
<li><p>위 다이어그램과 같이 <strong>인터페이스</strong> 및 각 <strong>클래스</strong>(구현 클래스)들을 구현한다.</p></li>
</ul></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/ms173156.aspx">C# 인터페이스</a>(인터페이스 <code>정의</code>는 각 언어마다 조금씩 차이를 보인다(모든 언어에 동일하게 구현되어있지 않다))</p></li>
</ul>

<h2>5. 정리하며</h2>

<ul>
<li><p><strong>인터페이스</strong>는 개발 중인 어플케이션 규모 및 설계에 따라 적용 범위가 얼마든지 달라질 수 있다.(또는 사용이 불필요할 수 도 있다(간혹 팀내에서의 <strong>관행</strong>적인 적용이 있다는 말을 들은적이 있는데 이건 정말 아닌듯 하다;;;))</p>

<ul>
<li><em>너무 당연한 말일 수 도 있지만, 인터페이스와 같은 모든 디자인 패턴은 적재 적소에 활용해야만 득이되는 것이다.</em></li>
</ul></li>
<li><p>위에서 언급한 내용과 다른 <strong>적용 사례</strong>에 대해(<em>인터페이스를 구현하는 상황이 또 모가 있을까?) 한번쯤 심도있게 생각해보길 바란다</em></p></li>
</ul>

<h2>6. 참고 URL</h2>

<ul>
<li><p><a href="http://woonohyo.tistory.com/22">DI란?</a></p></li>
<li><p><a href="http://okky.kr/article/161248">인터페이스 사용이유</a></p></li>
<li><p><a href="http://masamune.tistory.com/16">인터페이스란</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/tkyhsw31.aspx">C# 인터페이스 인덱서</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/64syzecx.aspx">C# 인터페이스 속성</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/ak9w5846.aspx">C# 인터페이스 이벤트</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    

</channel>

</rss>