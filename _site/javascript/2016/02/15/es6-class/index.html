<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <!-- viewport 설정 -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- keyword 설정 -->
    <meta name="keywords" content="javascript">
    <!-- description 설정 -->
    <meta name="description" content="ES6 Class #1" />

    <!-- open graph 설정 -->
    <meta property="og:type" content="mohwa blog">
    <meta property="og:title" content="ES6 Class #1">
    <meta property="og:description" content="ES6 Class #1">
    <!--<meta property="og:image" content="http://mysite.com/myimage.jpg">-->
    <meta property="og:url" content="/blog">

    <meta name="copyright" content="by mohwa" />

    <!--<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />-->

    <!-- google search console 설정 -->
    <link rel="alternate" hreflang="ko" href="http://mohwa.github.io" />
    <link rel="alternate" hreflang="ko" href="https://mohwa.github.io" />

    <link rel="stylesheet" href="/blog/assets/css/site.css" />
    <link rel="stylesheet" href="/blog/bower_components/highlightjs/styles/darkula.css">

    <script src="/blog/bower_components/jquery/dist/jquery.min.js" type="text/javascript"></script>
    <script src="/blog/bower_components/highlightjs/highlight.pack.min.js" type="text/javascript"></script>
    <script src="/blog/bower_components/purl/purl.js" type="text/javascript"></script>
    <!-- Script pointing to jekyll-search.js -->
    <script src="/blog/bower_components/simple-jekyll-search/dest/jekyll-search.js" type="text/javascript"></script>

    <title>ES6 Class #1</title>

    <script type="text/javascript">

        // code highlight 적용
        // https://highlightjs.org/static/demo/
        $(document).ready(function() {
            $('pre code').each(function(i, block) {
                hljs.highlightBlock(block);
            });
        });
    </script>
</head>

<body>

  <div class="top-bar"></div>

  <div class="container">
    <div class="site">
      <header>
        <nav>
    <span style="float:left;">
        <a class="" href="/blog/">Home</a>
        <!--<a class="" href="/archive/">전체글</a>-->
        <!--<a class="" href="//github.com/nolboo/nolboo.github.io/wiki">번역글 위키</a>-->
    </span>
    <span style="float:right;">
        <div id="search-container" class="search-container">
            <input type="text" id="search-input" class="search-input" placeholder="search...">
        </div>
    </span>
</nav>

        <div class="pull-right right logo">
          <div class="name"></div>
          <!--<a href="/feed.xml"><img class="avatar" src="/images/rss.jpg" alt="RSS" /></a>-->
        </div>
      </header>
      <div class="separator"></div>
      <ul id="results-container" class="results-container"></ul>
      <article>
  <h1>
    ES6 Class #1
  </h1>
  <div class="center">
    <p class="meta">15 Feb 2016</p>
  </div>



  <div class="post">
  <h2 id="1">1. 글에 대해</h2>

<ul>
<li><p>이 글은 <a href="https://www.facebook.com/hika00?fref=nf">Hika Maeng 님</a>이 추천해주신 <a href="http://www.yes24.com/24/goods/23904865">ECMAScript 6 길들이기</a>라는 책과 개인적인 테스트를 통해 작성되었습니다.</p></li>
<li><p>또한 모든 결과는 <strong>Chrome 브라우저</strong>를 통해 테스트된 결과입니다.</p></li>
</ul>

<h2 id="2">2. 클래스 선언 및 표현식</h2>

<ul>
<li><h3 id="es6-es5">ES6 클래스는 ES5 가 가진 <span style="color:#c11f1f"><a href="http://mohwa.github.io/blog/javascript/2016/02/05/proto/">객체 지향 모델</a></span>을 좀더 <span style="color:#c11f1f">명시적</span>으로 다룰수 있도록 개선된 새로운 모델이다.<br></h3></li>
<li><h3 id=">클래스 선언식</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// [&#39;yanione&#39;]</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

              <span class="c1">// ES6 클래스 body 는 기본적으로 strict mode 위에서 동작한다.</span>

              <span class="c1">// &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode functions</span>
              <span class="c1">// or the arguments objects for calls to them</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 프로토타입 맴버 선언</span>
      <span class="nx">getId</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 선언된 클래스는 기존 함수 객체와 거의 유사한 구조를 가지고 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// 선언된 클래스는 function 데이터 타입을 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// function</span>

  <span class="c1">// 선언된 클래스의 constructor 속성은 Function (생성자)함수 객체를 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// Function function object</span>

  <span class="c1">// 선언된 클래스가 가진 원형 객체</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

  <span class="c1">// 선언된 클래스의 prototype 객체 프로퍼티는 getId 맴버를 포함하고 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span><span class="p">);</span> <span class="c1">// getId function object</span>

  <span class="c1">// newAObject 객체를 생성한다.</span>
  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

  <span class="c1">// newAObject 객체의 __proto__ (내부)속성은, A.prototype (원형)객체를 참조하고있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

  <span class="c1">// newAObject 객체의 prototype chain 에는 A.prototype 객체가 존재하므로 아래 코드를 통해 true 를 반환하게 된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">);</span> <span class="c1">// true</span>

  <span class="c1">// newAObject 객체의 (생성자)함수(클래스)인 A 함수(클래스) 객체를 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// A class</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">newAObject</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// function</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// yanione</span>

  <span class="c1">// newAObject 객체는, ES5 의 (생성자)함수 객체를 통해 생성된 객체와 동일한 구조를 가지고있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p>선언된 클래스 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-1.png" alt=""></p>

<p>newAObject 객체 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_05.png" alt=""></p>

<p><h2>정리</h2></p>

<ul>
<li><span style="color:#c11f1f">A</span> 클래스는 기존 <span style="color:#c11f1f">함수</span> 객체와 거의 <span style="color:#c11f1f">유사한 구조</span>를 가지고 있다.<p></li>
<li><span style="color:#c11f1f">A</span> 클래스는 <span style="color:#c11f1f">function</span> 데이터 타입을 <span style="color:#c11f1f">반환</span>한다.<p></li>
<li><span style="color:#c11f1f">A</span> 클래스의 prototype 객체 프로퍼티는 선언된 <span style="color:#c11f1f">프로토타입 맴버</span>인 getId 메서드를 포함하고 있다.<p></li>
<li>newAObject.constructor 속성은 (생성자)함수인 <span style="color:#c11f1f">A</span> 함수(클래스) 객체를 참조하고 있다.<p></li>
<li>newAObject 객체는, ES5 의 (생성자)<span style="color:#c11f1f">함수</span> 객체를 통해 생성된 객체와 <span style="color:#c11f1f">동일한 구조</span>를 가지고있다.<br><br><br><br></li>
</ul></li>
<li><h3 id=">그밖의 테스트</h3>

<ul>
<li><p>클래스 <span style="color:#c11f1f">선언식</span>은 <span style="color:#c11f1f">EC 진입</span> 및 <span style="color:#c11f1f">실행 코드 처리</span> 후에도 <span style="color:#c11f1f">VO</span> 의 새로운 속성으로 추가되지않는다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// ec 진입 시 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// A is not defined</span>
  <span class="p">}</span>

  <span class="c1">// 클래스 선언식</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 실행 코드 처리후에도 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// undefined </span>
</code></pre></div></li>
<li><p>일반적인 <span style="color:#c11f1f">함수 호출</span>의 경우 아래와 같은 <span style="color:#c11f1f">예외</span>가 발생하게된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 일반적인 함수 호출의 경우 아래와 같은 예외가 발생하게된다.</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// call, apply, bind 메서드를 통해 호출한 경우에도 동일한 에러가 발생하게된다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">({});</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">.</span><span class="nx">apply</span><span class="p">({});</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">_A</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">bind</span><span class="p">({});</span>
      <span class="nx">_A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ES5</span> 에서 <span style="color:#c11f1f">ES6</span> 클래스와 같이, 일반적인 <span style="color:#c11f1f">함수 호출</span>을 <strong>막는 방법</strong>은 아래와 같다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

      <span class="c1">// this 값 내부 prototype chain 에 A.prototype 이 존재하지 않는 경우</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">)){</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Uncaught TypeError: Class constructors cannot be invoked without \&#39;new\&#39;&#39;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// 인스턴스 맴버를 정의한다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>

      <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 일반적인 함수 호출의 경우, 초기화된 this 값(global Object) 내부 prototype chain 에는 A.prototype 이 존재하지 않는다.(즉 예외가 발생하게된다)</span>
  <span class="nx">A</span><span class="p">();</span> <span class="c1">// Uncaught TypeError: Class constructors cannot be invoked without new\</span>

  <span class="c1">// 하지만 call(or apply, bind) 메서드를 통해, A.prototype 이 포함한 객체를 전달할 경우, (new 연산자가 생략된)일반적인 함수 호출을 막을수는 없다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span><span class="nx">age</span><span class="o">:</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="mi">18</span><span class="p">}}),</span> <span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">));</span> <span class="c1">// Object {id: &quot;yanione&quot;, name: &quot;mohwa&quot;, age: 18}</span>
</code></pre></div></li>
<li><p>선언된 클래스와 동일한 <strong>식별자 이름</strong>으로 선언 시 아래와 같은 에러가 발생한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언식</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 선언된 클래스와 동일한 식별자 이름으로 선언 시 아래와 같은 에러가 발생한다.</span>

  <span class="c1">// Uncaught SyntaxError: Identifier &#39;A&#39; has already been declared</span>
  <span class="c1">// var A;</span>
</code></pre></div>
<p><br><br><br><br>                    </p></li>
</ul></li>
<li><h3 id=">클래스 표현식</h3>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 표현식</span>
  <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span><span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// [&#39;yanione&#39;]</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

              <span class="c1">// ES6 클래스는 기본적으로 strict mode 위에서 동작한다.</span>

              <span class="c1">// &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode functions</span>
              <span class="c1">// or the arguments objects for calls to them</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 프로토타입 맴버 선언</span>
      <span class="nx">getId</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 표현식에서 클래스명은 생략 가능하다.</span>
  <span class="kd">var</span> <span class="nx">_A</span> <span class="o">=</span> <span class="kr">class</span><span class="p">{</span>
      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// [&#39;yanione&#39;]</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

              <span class="c1">// ES6 클래스는 기본적으로 strict mode 위에서 동작한다.</span>

              <span class="c1">// &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode functions</span>
              <span class="c1">// or the arguments objects for calls to them</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 프로토타입 맴버 선언</span>
      <span class="nx">getId</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>     

  <span class="c1">// 선언된 클래스는 기존 함수 객체와 거의 유사한 구조를 가지고 있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// 일반적인 함수 호출의 경우 함수 선언식과 동일한 예외가 발생하게된다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">new_AObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">_A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">);</span>
</code></pre></div>
<p>선언된 클래스 내부(<em>이전 <span style="color:#c11f1f">클래스 선언식</span>과 달리 &lt;function scope&gt; 내부에 <span style="color:#c11f1f">Script 속성</span>이 포함되지 않았다</em>)</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-2.png" alt=""></p>

<p>(기명) 클래스 표현식 결과</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_14.png" alt=""></p>

<p>(익명) 클래스 표현식 결과</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">new_AObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">_A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_15.png" alt=""></p>

<p><h2>정리</h2></p>

<ul>
<li>클래스 표현식은 클래스명에 대한 <span style="color:#c11f1f">기명</span> / <span style="color:#c11f1f">익명</span> 표현이 가능하다.<br><br><br><br><br></li>
</ul></li>
<li><h3 id=">그밖의 테스트</h3>

<ul>
<li><p>클래스 <span style="color:#c11f1f">표현식</span>은 <span style="color:#c11f1f">EC 진입</span> 시 <span style="color:#c11f1f">VO</span> 의 새로운 속성으로 추가되지않는다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// ec 진입 시 VO 의 새로운 속성으로 추가되지않는다.</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// A is not defined</span>
  <span class="p">}</span>

  <span class="c1">// 표현식에서 클래스명은 생략 가능하다.</span>
  <span class="kd">var</span> <span class="nx">_A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span><span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 실행 코드 처리 후</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// undefined</span>

  <span class="c1">// 선언된 _A 변수에 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">_A</span><span class="p">);</span> <span class="c1">// A class</span>
</code></pre></div></li>
<li><p>선언된 클래스를 (<span style="color:#c11f1f">new</span> 연산자를 생략 후)<span style="color:#c11f1f"> 호출</span> 하면 에러가 발생한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="k">try</span><span class="p">{</span>
      <span class="c1">// 함수 호출</span>
      <span class="nx">A</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// Class constructors cannot be invoked without &#39;new&#39;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul></li>
</ul>

<h2 id="3">3. 접근자 선언</h2>

<ul>
<li><p>접근자 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
          <span class="c1">// 접근자 사용을 위해 내부 속성인 __id__ 속성을 선언한다.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 접근자 생성 시 A.prototype 객체 내부에는 id 속성과 get/set 접근자 메서드가 생성되어있다.</span>
      <span class="nx">get</span> <span class="nx">id</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">set</span> <span class="nx">id</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
          <span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// A class</span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="c1">// get</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>

  <span class="c1">// set</span>
  <span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione2&#39;</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione2</span>
</code></pre></div>
<p>접근자 생성시 A.prototype 객체 내부에는 <span style="color:#c11f1f">id</span> 속성과 get/set <span style="color:#c11f1f">접근자</span> 메서드가 생성되어있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_06.png" alt=""></p>

<p>newAObject 객체 내부(newAObject 객체의 <span style="color:#c11f1f">인스턴스 맴버</span>로 <span style="color:#c11f1f">id</span> 속성이 추가된것을 볼 수 있다)     </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_07.png" alt=""><br><br><br><br></p></li>
<li><p>ES5 <span style="color:#c11f1f">인스턴스 맴버</span>를 통한 <span style="color:#c11f1f">접근자</span> 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">__id__</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// 객체(this) prototype chain 에 A.prototype 이 존재하는지 않는 경우         </span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

      <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">__id__</span><span class="p">;</span>

      <span class="c1">// ES5 에서는 오직 Object.defineProperty 메서드를 통해서만 접근자를 생성할 수 있다.</span>
      <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">id</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">id</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">});</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">new_AObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>

  <span class="nx">new_AObject</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione2&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">new_AObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione2</span>
</code></pre></div>
<p>newAObject 객체 내부(이 경우 선언된 <strong>접근자 프로퍼티</strong>에 대한, 모든 <span style="color:#c11f1f">접근자</span> 메서드들이 <span style="color:#c11f1f">인스턴스 맴버</span>로 포함되는 <span style="color:#c11f1f">단점</span>(메모리)이 존재한다)</p>

<ul>
<li><p>즉 <span style="color:#c11f1f">new</span> 연산자를 통해 생성되는, 모든 객체에 선언된 모든 <span style="color:#c11f1f">접근자</span> 메서드가 생성되며, 그로인해 메모리가 낭비되는 <span style="color:#c11f1f">단점</span>이 존재한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// new 연산자를 통해 생성되는 모든 객체(인스턴스)에 선언된, 접근자 메서드가 생성되며, 그로인해 메모리가 낭비되는 단점이 존재한다.</span>
  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">newAObject2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject2</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_09.png" alt=""><br><br><br><br></p></li>
</ul></li>
<li><p>ES5 <span style="color:#c11f1f">프로토타입 맴버</span>를 통한 <span style="color:#c11f1f">접근자</span> 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 선언한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">A</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// A.prototype 객체에 id 속성에 대한 get/set 접근자 메서드를 생성한다.</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">,{</span>
      <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
          <span class="c1">// 내부 속성인 __id__ 속성을 통해 접근자에 접근한다.</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span>
      <span class="p">},</span>
      <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">__id__</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">});</span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="s1">&#39;yanione&#39;</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// yanione</span>
</code></pre></div>
<p>Object.defineProperty 메서드를 통한, 접근자 생성시 A.prototype 객체 내부에는 <span style="color:#c11f1f">id</span> 속성과 get/set <span style="color:#c11f1f">접근자</span> 메서드가 생성되어있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_0-7.png" alt=""></p>

<p>newAObject 객체 내부(이 경우 ES6 에서의 <span style="color:#c11f1f">접근자 생성</span>과 같이, 선언된 모든 <span style="color:#c11f1f">접근자 메서드</span>들이 A.prototype 객체에 <span style="color:#c11f1f">할당</span>되며, 이전에 가졌던 (메모리 낭비에 대한)<span style="color:#c11f1f">단점</span>을 피할 수 있다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_0-6.png" alt=""><br><br><br><br>        </p></li>
</ul>

<h2 id="4">4. 정적 메서드 선언</h2>

<ul>
<li><p>정적 메서드 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(){</span>
      <span class="p">}</span>

      <span class="c1">// 정적 메서드 선언</span>
      <span class="kr">static</span> <span class="nx">post</span><span class="p">(</span><span class="nx">url</span><span class="p">){</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">url</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// A.post 메서드는 function 데이터 타입을 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// function</span>

  <span class="c1">// 선언된 정적 메서드는 해당 클래스의 새로운 속성으로 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// post function object</span>

  <span class="c1">// A.post.constructor 속성은 Function (생성자)함수 객체를 참조하고있다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// Function function object</span>

  <span class="c1">// A.post 정적 메서드는 prototype 객체 프로퍼티를 갖지않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// undefined</span>

  <span class="c1">// (생성자)함수 객체로 호출 시 아래와 같은 에러가 발생한다.</span>
  <span class="k">try</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;http://mohwa.com&#39;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="cm">/*</span>
<span class="cm">       Uncaught TypeError: post(url){</span>
<span class="cm">       this.url = url;</span>
<span class="cm">       } is not a constructor</span>
<span class="cm">      */</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_10.png" alt=""><br><br><br><br>                  </p></li>
<li><p>ES5 를 통한 정적 메서드 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">post</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="p">};</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// A function object</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// post function object</span>

  <span class="c1">// (생성자)함수 객체로 호출 시 새로운 객체가 생성된다.</span>
  <span class="kd">var</span> <span class="nx">newAPostObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;http://mohwa.com&#39;</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAPostObject</span><span class="p">);</span>
</code></pre></div>
<p>A 함수 객체 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_11.png" alt=""><p></p>

<p>newAPostObject 객체 내부</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-3.png" alt=""><br><br><br><br></p></li>
</ul>

<h2 id="5">5. 제네레이트 메서드 선언</h2>

<ul>
<li><p>제네레이트 메서드 선언</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// 클래스 선언</span>
  <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(){</span>
      <span class="p">}</span>

      <span class="c1">// 제네레이터 메서드 선언</span>
      <span class="o">*</span> <span class="nx">post</span><span class="p">(){</span>
          <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
          <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span>

  <span class="c1">// 선언된 제네레이터 메서드는 A 클래스의 prototype 객체 프로퍼티에 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">post</span><span class="p">);</span> <span class="c1">// post function object</span>

  <span class="c1">// 제네레이터 메서드의 (생성자)함수 객체로 GeneratorFunction 함수 객체를 반환한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">post</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span> <span class="c1">// GeneratorFunction function object </span>

  <span class="kd">var</span> <span class="nx">newAObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">generator</span> <span class="o">=</span> <span class="nx">newAObject</span><span class="p">.</span><span class="nx">post</span><span class="p">();</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">newAObject</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// 1</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// 2</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// 3</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">generator</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">done</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>
<p><span style="color:#c11f1f">A</span> 클래스 내부(선언된 제네레이터 메서드는 A 클래스의 prototype 객체 프로퍼티에 할당된다)</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-5.png" alt=""><p></p>

<p>newAObject 객체 내부(제네레이터 메서드의 (생성자)함수 객체로 <span style="color:#c11f1f">GeneratorFunction</span> 함수 객체를 반환한다)</p>

<p><img src="/blog/assets/images/posts/20160203/class_0-4.png" alt=""><p>                   </p></li>
</ul>

<h2 id="6">6. 클래스 상속</h2>

<ul>
<li><p>ES6 에서는 <span style="color:#c11f1f">extends</span> 절 및 <span style="color:#c11f1f">super</span> 키워드를 통해 상속을 구현할 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
      <span class="c1">// 이 경우 this 는 new C 를 통해 생성된 객체를 가리킨다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// 클래스가 아닌 함수 객체에 대한 상속도 가능하다.</span>
  <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

          <span class="c1">// super 키워드를 통해 인스턴스 맴버 초기화 및 위임 과정이 발생한다.</span>
          <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>

          <span class="c1">// 이 경우 this 는 new C 를 통해 생성된 객체를 가리킨다.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">getName</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 클래스 상속</span>
  <span class="kr">class</span> <span class="nx">C</span> <span class="kr">extends</span> <span class="nx">B</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>

          <span class="c1">// super 키워드를 통해 인스턴스 맴버 초기화 및 위임 과정이 발생한다.</span>
          <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>

          <span class="c1">// 이 경우 this 는 new C 를 통해 생성된 객체를 가리킨다.</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">getAge</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">,</span> <span class="mi">35</span><span class="p">));</span>
</code></pre></div></li>
<li><p><s><strong>chrome 48 버전</strong>의 결과</s></p>

<p><img src="/blog/assets/images/posts/20160203/class_12.png" alt=""><br><br><br><br></p></li>
<li><p><strong>chrome 49 버전</strong>을 통해 다시 확인해본결과, 이전 결과와 달라진것을 볼 수 있다.</p>

<ul>
<li><strong>인스턴스 이름</strong>이 <strong>A</strong> ==&gt; <strong>C</strong> 로 바뀐것은 맞는듯한데, 그 하위의 <strong>prototype chain 이름</strong>들이 상이?한듯 하다.(즉 <strong>C 인스턴스</strong>의 __proto__ 속성이 <strong>C.prototype</strong> 이 아닌, <strong>B.prototype</strong> 을 참조하고 있다고 출력하고 있다.(하지만 보여지는 <strong>prototype 객체</strong> 내부에는, <strong>C 클래스</strong>의 프로토타입 메서드인 <strong>getAge</strong> 를 포함하고 있는것을 볼 수 있다))</li>
</ul>

<p><img src="/blog/assets/images/posts/20160203/class_12_1.png" alt=""><br><br><br><br>                  </p></li>
<li><p><span style="color:#c11f1f">ES5</span> 를 통해 <span style="color:#c11f1f">클래스 상속</span>을 구현해본 예(ES6 에서의 <span style="color:#c11f1f">super</span> 키워드는 아래 <code>this.__proto__.constructor.call</code> 과 같은 일종의 <span style="color:#c11f1f"><a href="https://ko.wikipedia.org/wiki/%EB%A7%A4%ED%81%AC%EB%A1%9C_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">매크로</a></span> 구현으로 볼 수 있다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

      <span class="c1">// call 메서드를 통해 A (생성자)함수 객체(this.__proto__.__proto__.__proto__)가 가진 인스턴스 맴버를 초기화한다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span>  <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// B.prototype 객체 프로퍼티에 A.prototype (원형)객체를 포함한 새로운 객체를 할당한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">B</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">C</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>

      <span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>

      <span class="c1">// call 메서드를 통해 B (생성자)함수 객체(this.__proto__.__proto__)가 가진 인스턴스 맴버를 초기화한다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// C.prototype 객체 프로퍼티에 B.prototype (원형)객체를 포함한 새로운 객체를 할당한다.</span>
  <span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
  <span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getAge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nx">C</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">C</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">newCObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">,</span> <span class="mi">35</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">.</span><span class="nx">getId</span><span class="p">());</span> <span class="c1">// yanione</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// mohwa</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">.</span><span class="nx">getAge</span><span class="p">());</span> <span class="c1">// 35</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newCObject</span><span class="p">);</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20160203/class_13.png" alt=""><br><br><br><br></p></li>
<li><p><strong>파생 클래스</strong>의 <strong>constructor</strong>(생성자) 내부에서는 반드시 <span style="color:#c11f1f">super</span> 키워드가 호출되어야한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// 클래스가 아닌 함수 객체에 대한 상속도 가능하다.</span>
  <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

          <span class="c1">// 파생 클래스의 constructor 내부에서는 super 키워드만을 사용(호출)하거나, this 키워드 사용전에 반드시 호출되어야한다.</span>
          <span class="c1">// 즉 constructor 내부에서는 super 키워드가 반드시 호출되어야한다.</span>
      <span class="p">}</span>

      <span class="nx">getName</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">try</span><span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="c1">// 아래와 같은 예외가 발생한다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// this is not defined</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">super</span> 키워드가 <span style="color:#c11f1f">this</span> 처리 후에 호출될 경우, 예외가 발생된다.(반드시 <span style="color:#c11f1f">this</span> 사용전에 호출되어야한다)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span>  <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getId</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// 클래스가 아닌 함수 객체에 대한 상속도 가능하다.</span>
  <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

      <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

          <span class="c1">// 반드시 this 사용전에 호출되어야한다.</span>
          <span class="c1">// super(id);</span>

          <span class="k">try</span><span class="p">{</span>
              <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
              <span class="c1">// Uncaught ReferenceError: this is not defined</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="c1">// 이 경우 super 키워드는 처리되지 않는다.</span>
          <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="nx">getName</span><span class="p">(){</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">));</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">super</span> 키워드를 통해, <strong>부모 클래스</strong>에 선언된 <span style="color:#c11f1f">static method</span> 에 접근 가능하다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kr">static</span> <span class="nx">x</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// 파생 클래스의 constructor 내부에서는 반드시 super 키워드가 호출되어야한다.</span>
      <span class="kr">super</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kr">static</span> <span class="nx">y</span><span class="p">()</span> <span class="p">{</span>

      <span class="c1">// static 메서드 내부 &quot;this&quot; 는 &quot;B class&quot; 와 동일하다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// B class</span>

      <span class="c1">// &quot;super&quot; 는 &quot;this.__proto__(A class)&quot; 와 동일하다.</span>

      <span class="c1">// 즉 this.__proto__.x() 메서드를 통해 호출 가능하다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x method</span>

      <span class="c1">// super 를 통한 접근</span>
      <span class="kr">super</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x method</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// var _B = new B();</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ES5</span> 를 통해, 위 <span style="color:#c11f1f">super</span> 키워드의 <strong>특성</strong>을 구현해본 예</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
  <span class="p">}</span>

  <span class="c1">// A 함수 객체의 x static method 를 생성한다.</span>
  <span class="nx">A</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="c1">// B 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">B</span><span class="p">(){</span>
  <span class="p">}</span>

  <span class="c1">// B 함수 객체의 y static method 를 생성한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="c1">// this(B function object).__proto__(A function object).x 메서드에 접근 가능하다.</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// === super.x();</span>
  <span class="p">};</span>

  <span class="c1">// B 함수 객체의 __proto__ 속성은 A 함수 객체를 참조하고있다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">A</span><span class="p">;</span>

  <span class="nx">B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span> <span class="c1">// x method</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">super</span> 키워드를 통해, 부모 클래스에 선언된 <span style="color:#c11f1f">prototype method</span> 에 접근 가능하다.                     </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">x</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="kr">class</span> <span class="nx">B</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>

      <span class="kr">super</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">y</span><span class="p">()</span> <span class="p">{</span>

      <span class="c1">// this.__proto__(B.prototype).__proto__(A.prototype).x()</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// x method</span>

      <span class="c1">// super 키워드는 this.__proto__.__proto__ 와 같다.</span>
      <span class="kr">super</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// === this.__proto__.__proto__.x() === x method</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">_B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">_B</span><span class="p">);</span> <span class="c1">// {id: &quot;yanione&quot;, name: &quot;mohwa&quot;}</span>

  <span class="nx">_B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ES5</span> 를 통해, 위 <span style="color:#c11f1f">super</span> 키워드의 <strong>특성</strong>을 구현해본 예</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// A 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">id</span><span class="p">){</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// A 함수 객체의 x static method 를 생성한다.</span>
  <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;x method&#39;</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="c1">// B 함수 객체를 생성한다.</span>
  <span class="kd">function</span> <span class="nx">B</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>

      <span class="c1">// this.__proto__.__proto__.constructor(A function object)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// B.prototype 에, A.prototype 을 원형으로 갖는 새로운 객체를 할당한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>

  <span class="c1">// y prototype method 를 생성한다.</span>
  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>

      <span class="c1">// this(B instance).__proto__(B.prototype).__proto__(A.prototype).x</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">x</span><span class="p">();</span> <span class="c1">// === super.x 와 같다 === x method</span>
  <span class="p">};</span>

  <span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">B</span><span class="p">;</span>

  <span class="kd">var</span> <span class="nx">_B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span><span class="s1">&#39;yanione&#39;</span><span class="p">,</span> <span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">_B</span><span class="p">);</span> <span class="c1">// {id: &quot;yanione&quot;, name: &quot;mohwa&quot;}</span>

  <span class="nx">_B</span><span class="p">.</span><span class="nx">y</span><span class="p">();</span>
</code></pre></div></li>
</ul>

  </div>
  <div data-count="10" id="recommend-article"></div>
</article>

<section class="post-footer">
  <div class="related-posts">
    <div class="related-posts-title"><h2>Related Posts</h2></div>
    <div class="related-posts-list">
      <ul>
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
              <li><a href="/blog/javascript/2016/04/21/es6-object-literal/" title="ES6 object initializer">ES6 object initializer</a></li>
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
              <li><a href="/blog/javascript/2016/03/24/es6-destructuring-assignment/" title="ES6 Destructuring assignment">ES6 Destructuring assignment</a></li>
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
              <li><a href="/blog/javascript/2016/02/24/es6-const/" title="ES6 const">ES6 const</a></li>
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
              <li><a href="/blog/javascript/2016/02/23/es6-let/" title="ES6 let">ES6 let</a></li>
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
              <li><a href="/blog/javascript/2016/02/18/es6-arrow-function/" title="ES6 Arrow Function & This Test">ES6 Arrow Function & This Test</a></li>
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
              <li><a href="/blog/javascript/2016/02/05/proto/" title="__proto__ 속성과 프로토타입 위임 과정">__proto__ 속성과 프로토타입 위임 과정</a></li>
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
              <li><a href="/blog/javascript/2016/02/01/select-box/" title="JQuery UI Select Box 구현">JQuery UI Select Box 구현</a></li>
          
          
          <!---->
        
      </ul>
    </div>
  </div>
</section>

<section class="comments">
    <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'mohwa'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>



      <div class="separator"></div>
    </div>
  </div>
  <footer>
    <section>
  <ul class="links">
      <li><a href="https://twitter.com/yanione" title="follow me" target="_blank"><i class="icon-twitter"></i></a></li>
      <li><a href="https://github.com/mohwa" title="github page" target="_blank"><i class="icon-github"></i></a></li>
  </ul>
<section>

  </footer>
  <script>
    <!-- Google Analytics -->
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-30470280-2', 'auto');
    ga('send', 'pageview');

    // include jekyll full text search
    // https://github.com/christian-fei/Simple-Jekyll-Search
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: '/blog/search.json',
      searchResultTemplate: '<li><a href="{href}">{title}</a>&nbsp;&nbsp;&nbsp;{date}</li>',
      noResultsText: 'No results found'
    });

  </script>
  <script src="http://b.readtrend.com/j/s.js"></script>
</body>
</html>
