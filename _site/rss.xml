<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
>

<channel>
    <title><![CDATA[Mohwa blog]]></title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <link href="/" />
    <description><![CDATA[]]></description>
    <lastBuildDate>Mon, 31 Aug 2015 23:54:30 +0900</lastBuildDate>
    <language>en-US</language>
    <generator uri="http://octopress.org/">Octopress</generator>

    
        <item>
            <title><![CDATA[JavaScript 를 통해 Binary Data 조작하기]]></title>
            <link>/javascript/2015/08/31/binary-inJS/</link>
            <pubDate>Mon, 31 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[javascript]]></category>
        
        
            <guid>/javascript/2015/08/31/binary-inJS/</guid>
            <description>
                <![CDATA[1. 사전 지식 Blob 정의 Blob 는 일반적으로 미디어(이미지, 사운드, 비디오) 파일과 같은 큰 용량의 파일을 말한다. Blob Object Blob Object 는 File 과 같은 불변 객체를 나타내며, raw data 이다. 추가로 File 인터페이스 는 Blob 인터페이스 의 모든 특성들을 상속받는다. Blob API in MDN Blob in Terms Blob in...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 사전 지식</h2>

<ul>
<li><p><strong>Blob</strong></p>

<ul>
<li>정의

<ul>
<li><code>Blob</code> 는 일반적으로 미디어(이미지, 사운드, 비디오) 파일과 같은 큰 용량의 파일을 말한다.</li>
</ul></li>
<li><p>Blob Object</p>

<ul>
<li><p><code>Blob Object</code> 는 File 과 같은 <code>불변 객체</code>를 나타내며, <code>raw data</code> 이다.</p>

<ul>
<li>추가로 <code>File 인터페이스</code> 는 <code>Blob 인터페이스</code> 의 모든 특성들을 상속받는다.</li>
<li><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_1.jpg" alt=""></li>
</ul></li>
</ul></li>
<li><p><a href="https://developer.mozilla.org/en/docs/Web/API/Blob">Blob API in MDN</a></p></li>
<li><p><a href="http://www.terms.co.kr/BLOB.htm">Blob in Terms</a></p></li>
<li><p><a href="http://caniuse.com/#search=blob">Blob in Can I Use</a></p></li>
</ul></li>
<li><p><strong>JavaScript Typed Array</strong></p>

<ul>
<li><p>정의</p>

<ul>
<li><p><code>Typed Array</code> 는 <code>raw binary data</code> 에 접근하기 위한 방법을 제공한다.</p>

<ul>
<li><em>즉 자바스크립트로 raw binary data 를 다루기 위해 사용한다.</em></li>
</ul></li>
<li><p><strong>유연성</strong>과 <strong>효율성</strong>을 위해 <code>Typed Array</code> 는 <span style="color:#c11f1f">buffer</span> 와 <span style="color:#c11f1f">view</span> 로 나눠 구현되어있다.</p>

<ul>
<li><p>buffer:</p>

<ul>
<li><code>ArrayBuffer</code> 는 고정된 크기의 <code>raw binary data</code> 를 나타내기 위해 사용된다.</li>
<li><code>ArrayBuffer</code> 클래스 통해 생성된  <span style="color:#c11f1f">buffer</span> 는 <code>데이터 청크</code>를 나타내는 객체이다.</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 12 bytes buffer</span>
<span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
</code></pre></div>
<ul>
<li><p><span style="color:#c11f1f">buffer</span> 는 <u>저장된 데이터를 접근하기 위한 방법을 제공하지 않는다.</u></p>

<ul>
<li></li>
<li></li>
</ul></li>
</ul></li>
<li><p>view:</p>

<ul>
<li><p>DataView:</p>

<ul>
<li></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 12 bytes byffer</span>
<span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// 해당 view 가 시작하는 위치를 반환한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">view</span><span class="p">.</span><span class="nx">byteOffset</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div>
<ul>
<li></li>
</ul>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_4.jpg" alt=""></p></li>
<li><p>Typed Array Views:</p>

<ul>
<li></li>
<li></li>
</ul>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_3.jpg" alt=""><br>
- 각 <span style="color:#c11f1f">view</span> 에 따라 나눠지는 메모리 공간 .</p>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_2.jpg" alt=""></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/*</span>

<span class="cm">    ArrayBuffer(20 bytes)</span>
<span class="cm">    8bit == 1 byte</span>

<span class="cm">    ArrayBuffer / 1 byte = 20;</span>

<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="c1">// 부호 없는 1 byte 정수 배열</span>
<span class="kd">var</span> <span class="nx">uint8View</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uint8View</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 20</span>

<span class="cm">/*</span>

<span class="cm"> ArrayBuffer(20 bytes)</span>
<span class="cm"> 32bit == 4 byte</span>

<span class="cm"> ArrayBuffer / 4 byte = 5;</span>

<span class="cm"> */</span>

<span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="c1">// 부호 없는 4 byte 정수 배열</span>
<span class="kd">var</span> <span class="nx">uint32View</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uint32View</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 5</span>
</code></pre></div>
<ul>
<li></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// unsigned int 8(1 bytes)</span>

<span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">uint8View</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

<span class="c1">// 0 ~ 255(unsigned int 8(1 bytes) 로 표현 가능한 수)</span>
<span class="nx">uint8View</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">uint8View</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uint8View</span><span class="p">);</span> <span class="c1">// [0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>

<span class="c1">// signed int 8(1 bytes)</span>

<span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">int8View</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Int8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

<span class="c1">// -127 ~ 128(signed int 8(1 bytes) 로 표현 가능한 수)</span>

<span class="c1">// signed 의 경우 부호(양수/음수)를 나타내기 위해 총 8bit 중 1 비트(0: 양수, 1: 음수) 사용하기 때문에, 나머지 7bit(-127 ~ 128(표현 가능한 수))를 통해 숫자를 표현하게 된다.</span>

<span class="nx">int8View</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span><span class="p">;</span>
<span class="nx">int8View</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">int8View</span><span class="p">);</span> <span class="c1">// [-128, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>

<span class="c1">// unsigned int 16(2 bytes)</span>
<span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">uint16View</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint16Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

<span class="c1">// 0 ~ 65535(unsigned int 16(2 bytes) 로 표현 가능한 수)</span>
<span class="nx">uint16View</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">65535</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uint16View</span><span class="p">);</span> <span class="c1">// [65535, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>
</code></pre></div></li>
</ul></li>
</ul></li>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffer</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView">DataView</a></p></li>
<li><p><a href="http://www.javascripture.com/DataView">DataView API Test</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">JavaScript Typed Arrays</a></p></li>
<li><p><a href="http://ohgyun.com/418">JavaScript Typed Arrays(번역)</a></p></li>
<li><p><a href="http://firejune.com/1791/">signed 와 unsigned 의 차이</a></p></li>
<li><p><a href="http://air802.tistory.com/52">signed 가 음수 표현하는 방법(상세 설명)</a></p></li>
<li><p><a href="http://libsora.so/posts/i-hate-unsigned/">나는 unsigned 가 싫어요</a></p></li>
<li><p><a href="http://blog.naver.com/dud5243_/220415835594">signed or unsigned 자료형의 범위</a></p></li>
<li><p><a href="http://www.binaryconvert.com/index.html">Binary Convert</a></p></li>
</ul></li>
</ul></li>
<li><p><strong>Little-Endian or Big-Endian</strong></p>

<ul>
<li><p>정의</p>

<ul>
<li>컴퓨터에서 데이터가 저장되는 순서(<span style="color:#c11f1f">byte order</span>)를 말한다.</li>
</ul>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_5.jpg" alt=""><br>
- 정리:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">- 메모리는 &lt;span style=&quot;color:#c11f1f&quot;&gt;하위 주소&lt;/span&gt;에서 &lt;span style=&quot;color:#c11f1f&quot;&gt;상위 주소&lt;/span&gt;로 데이터가 저장된다.

- &lt;span style=&quot;color:#c11f1f&quot;&gt;Little Endian&lt;/span&gt;: 하위 바이트부터 데이터가 저장되는 방식.

    - &lt;span style=&quot;color:#c11f1f&quot;&gt;Little Endian&lt;/span&gt; 방식의 장점: 산술연산유닛(ALU)에서 메모리를 읽는 방식이 메모리 주소가 낮은 쪽에서부터 높은 쪽으로 읽기 때문에 산술 연산의 수행이 더 쉽다.(*연산 처리 과정에서 이런 장점이 있는 정도로만 알고 넘어가자...*)

![](/Users/sgjeon/blog_doc/img/bytesManipulation_6.jpg)

- &lt;span style=&quot;color:#c11f1f&quot;&gt;Big Endian&lt;/span&gt;: 상위 바이트부터 데이터가 저장되는 방식.

![](/Users/sgjeon/blog_doc/img/bytesManipulation_7.jpg)
</code></pre></div></li>
<li><p>적용 이유:</p>

<ul>
<li>각 <u><strong>CPU</strong>(Intel / Spac) <strong>타입</strong>에 따라 차이(<strong>데이터 저장 방식에 대한 차이</strong>)를 보이는 <span style="color:#c11f1f">byte order</span></u> 는, 동일한 시스템 안에서만 데이터를 주고 받는다면, <span style="color:#c11f1f">Endian</span> 에 대해 전혀 신경쓸 필요가 없지만, <u>이기종간에 데이터를 주고 받을 경우</u>, 서로간의 <strong>저장 방식 차이</strong>로 인해 전혀 엉뚱한 결과를 반환하게 된다.</li>
</ul></li>
<li><p>서로 다른 Endian 간의 데이터 통신 해결책:</p>

<ul>
<li><p>공통되는 Endian(<u>서로간에 정해진 <span style="color:#c11f1f">Endian</span> 규칙</u>)으로 변환 후, 데이타를 주고/받는 방법.</p>

<ul>
<li>즉 서로간에 사용할 <strong>Endian</strong>(<span style="color:#c11f1f">Little Endian</span> or <span style="color:#c11f1f">Big Endian</span>) 을 하나로 통일시켜 데이터를 주고 받는 것이다.</li>
</ul></li>
<li><p>또 하나의 방법은 <span style="color:#c11f1f">byte order</span>(바이트 저장 순서) 를 신경쓸 필요가 없는, <strong>데이터 타입</strong>을 사용하는 것이다. <span style="color:#c11f1f">char</span> 타입은 <strong>1byte</strong> 의 크기를 가지기때문에, <span style="color:#c11f1f">byte order</span> 에 대해 전혀 신경쓸 필요가 없다. 예를 들면 12345678 을 int 형으로 보내는 대신 <strong>문자열</strong> &quot;12345678&quot; 로 변환시켜서 전송하면 되는 것이다.</p></li>
</ul></li>
<li><p><a href="https://ko.wikipedia.org/wiki/%EC%97%94%EB%94%94%EC%96%B8">엔디언</a></p></li>
<li><p><a href="http://t3zz-so4.tistory.com/entry/Little-Endian-Big-Endian">Little-Endian or Big-Endian(개념 잡기 좋은 문서)</a></p></li>
<li><p><a href="http://firejune.com/1790">Little-Endian or Big-Endian 개념</a></p></li>
<li><p><a href="http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/Network_Programing/Documents/">Endian 에 대해서</a></p></li>
</ul></li>
</ul>

<h2>2. JavaScript 를 통해 Binary Data 조작하기</h2>

<ul>
<li><p>예제 소스에서는 <strong>NodeJS</strong> 및 <strong>Socket.IO</strong> 와 관련된 내용은 최대한 배제 하였습니다.(특별히 포스트 내용과 관련없다고 판단된.)</p>

<ul>
<li><p><strong>파일 업로드</strong></p>

<ul>
<li><p>File 및 FileReader API 를 지원하는 브라우저를 통해 파일 업로드 기능을 만들 수 있다.</p>

<ul>
<li><em>IE(10/11 포함) 브라우저는 지원하지 않는다고 보면된다.</em></li>
<li><p>Source Example</p>

<ul>
<li><p>Cliend Side(use JS)</p>

<ul>
<li></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">    <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;siofu_client.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
</code></pre></div><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// socket 서버에 연결</span>
<span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">connect</span><span class="p">(</span><span class="s1">&#39;http://localhost:9090&#39;</span><span class="p">);</span>

<span class="c1">// socket 객체를 SocketIOFileUpload 클래스로 전달한다.</span>
<span class="kd">var</span> <span class="nx">uploader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SocketIOFileUpload</span><span class="p">(</span><span class="nx">socket</span><span class="p">);</span>

<span class="c1">// listenOnSubmit 메서드에 input[type=&quot;button&quot;] 및 input[type=&quot;file&quot;] Element 를 전달한다.</span>
<span class="nx">uploader</span><span class="p">.</span><span class="nx">listenOnSubmit</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#btn_upload&#39;</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#siofu_input&#39;</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// KiB === byte 단위</span>
<span class="c1">// KB === KByte 단위</span>

<span class="c1">// 한번에 로드될 chunks 파일 사이즈</span>
<span class="c1">// chunkSize 를 0으로 할당하면, chunk 를 사용하지 않게 된다.</span>
<span class="nx">uploader</span><span class="p">.</span><span class="nx">chunkSize</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// 102400 byte 로 chunk 단위를 나눈다.</span>

<span class="nx">uploader</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;started upload of file&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// progress 이벤트를 통해 현재 진행 상황을 볼 수 있다.</span>
<span class="nx">uploader</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;progress&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">percent</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">bytesLoaded</span> <span class="o">/</span> <span class="nx">event</span><span class="p">.</span><span class="nx">file</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;File is&quot;</span><span class="p">,</span> <span class="nx">percent</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;percent loaded&quot;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 파일 업로드가 끝날을때 이벤트가 발생한다.</span>
<span class="nx">uploader</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;complete&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;completed file upload&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></li>
<li><p>Server Side(use nodeJS)</p></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">    <span class="kd">var</span> <span class="nx">uploader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">siofu</span><span class="p">();</span>
    <span class="nx">uploader</span><span class="p">.</span><span class="nx">dir</span> <span class="o">=</span> <span class="s2">&quot;uploads&quot;</span><span class="p">;</span>
    <span class="nx">uploader</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">socket</span><span class="p">);</span>

    <span class="c1">// Do something when a file is saved:</span>
    <span class="nx">uploader</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;saved&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">file</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// Error handler:</span>
    <span class="nx">uploader</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Error from uploader&quot;</span><span class="p">,</span> <span class="nx">event</span><span class="p">);</span>
    <span class="p">});</span>
</code></pre></div></li>
<li><p>참고 사이트</p>

<ul>
<li><a href="https://github.com/vote539/socketio-file-upload#instancelistenoninputinput"></a></li>
<li><a href="http://caniuse.com/#search=file%20api"></a></li>
<li><a href="http://caniuse.com/#search=FileReader"></a></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>이미지 효과</strong></p>

<ul>
<li>서버에서 내려받은 ArrayBuffer(<strong>이미지</strong> 데이터) 로 <span style="color:#c11f1f">view</span>(uInt8Array) 를 생성 후, 버퍼에 저장된 데이터를 조작한다.</li>
<li><p>Source Example</p>

<ul>
<li>Cliend Side(use JS)</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">cw</span> <span class="o">=</span> <span class="mi">327</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">ch</span> <span class="o">=</span> <span class="mi">125</span><span class="p">;</span>

<span class="c1">// canvas Element 를 가져온다.</span>
<span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;canvas&#39;</span><span class="p">);</span>

<span class="c1">// context 를 생성한다.</span>
<span class="kd">var</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s1">&#39;2d&#39;</span><span class="p">);</span>

<span class="c1">// view(부호 없는 1byte 정수 배열)를 생성한다.</span>
<span class="kd">var</span> <span class="nx">uInt8Array</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>

<span class="c1">// view를 통해 Blob Object 를 생성한다.</span>
<span class="kd">var</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">([</span><span class="nx">uInt8Array</span><span class="p">],</span> <span class="p">{</span><span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;image/jpeg&#39;</span><span class="p">});</span>

<span class="kd">var</span> <span class="nx">originalImgData</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="c1">// Blob Object를 참조하는 URL를 생성한다.</span>
<span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">URL</span><span class="p">.</span><span class="nx">createObjectURL</span><span class="p">(</span><span class="nx">blob</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">;</span>

<span class="c1">// 이미지 로드 이벤트</span>
<span class="nx">$</span><span class="p">(</span><span class="nx">img</span><span class="p">).</span><span class="nx">bind</span><span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
    <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>

    <span class="c1">// 캔버스에 해당 이미지를 그린다.</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">drawImage</span><span class="p">(</span><span class="nx">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">img</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">img</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

    <span class="c1">// 각 px 에 대한 정보(r,g,b,a)가 담긴 이미지 데이터를 가져온다.</span>
    <span class="nx">originalImgData</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getImageData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

    <span class="c1">// 반전 효과를 준다.</span>
    <span class="c1">// invert();</span>

    <span class="c1">// 흑백 효과를 준다.</span>
    <span class="nx">empty</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">// Blob 객체를 참조하는 URL을 img.src 에 할당 후 로드한다.</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>

<span class="c1">// px 단위의 이미지 데이터를 조작하여, 반전 효과를 준다.</span>
<span class="kd">function</span> <span class="nx">invert</span><span class="p">(){</span>

    <span class="nx">originalImgData</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getImageData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">originalImgData</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>

        <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">-</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>     <span class="c1">// red</span>
        <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">-</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// green</span>
        <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">-</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span> <span class="c1">// blue</span>
    <span class="p">}</span>

    <span class="nx">ctx</span><span class="p">.</span><span class="nx">putImageData</span><span class="p">(</span><span class="nx">originalImgData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">};</span>

<span class="c1">// px 단위의 이미지 데이터를 조작하여, 흑백 효과를 준다.</span>
<span class="kd">function</span> <span class="nx">empty</span><span class="p">(){</span>

    <span class="nx">originalImgData</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getImageData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">originalImgData</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 각 픽셀의 밝기만 조사하여 R, G, B 색상 요소를 균일하게 만들면 회색이 된다.(색상 정보를 아래 공식(각 요소(R, G, B)가 밝기에 미치는 영향은 29:58:11로 전문가에 의해 계산되어 있다)으로 R,G,B 요소에서 제거한다)</span>

        <span class="c1">// 128 이상은 흰색으로, 128 이하는 검정색으로 만들어 버림으로써, 흰색과 검정색 두 가지만 남긴다. 경계값인 128을 조정하면 밝기가 달라진다.</span>
        <span class="kd">var</span> <span class="nx">gray</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.299</span> <span class="o">+</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.587</span> <span class="o">+</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.114</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">gray</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">){</span>
            <span class="nx">gray</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="nx">gray</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">gray</span><span class="p">;</span>     <span class="c1">// red</span>
        <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">gray</span><span class="p">;</span> <span class="c1">// green</span>
        <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">gray</span><span class="p">;</span> <span class="c1">// blue</span>
    <span class="p">}</span>

    <span class="nx">ctx</span><span class="p">.</span><span class="nx">putImageData</span><span class="p">(</span><span class="nx">originalImgData</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li>Server Side(use nodeJS)</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="c1">// 파일을 읽은 후 클라이언트로 버퍼를 전달한다.</span>
<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./lib/img/nmms_20823487.jpg&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// it&#39;s possible to embed binary data</span>
    <span class="c1">// within arbitrarily-complex objects</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;onSocketMsg&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;resultImageData&#39;</span><span class="p">,</span>
        <span class="nx">payload</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">buffer</span><span class="o">:</span> <span class="nx">buf</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li><p>적용 결과</p>

<ul>
<li>원본 이미지</li>
</ul>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_8.jpg" alt=""><br>
- invert 함수 적용 이미지</p>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_9.jpg" alt=""><br>
- empty 함수 적용 이미지</p>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_10.jpg" alt=""></p></li>
<li><p>참고 사이트</p>

<ul>
<li><a href="chrome://blob-internals/"></a></li>
<li><a href="http://caniuse.com/#search=createObjectURL"></a></li>
<li><a href="http://code.flickr.net/2012/06/01/parsing-exif-client-side-using-javascript-2/"></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas"></a></li>
<li><a href="http://www.phpied.com/pixel-manipulation-in-canvas/"></a></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>ArrayBuffer 로 내려받은 비디오 플레이</strong></p>

<ul>
<li><p>서버에서 내려받은 ArrayBuffer(<strong>영상</strong> 데이터) 로 <span style="color:#c11f1f">view</span>(in Typed Array Views) 를 생성 후, 버퍼에 저장된 데이터를 조작한다.</p>

<ul>
<li><strong>영상</strong> 및 오디오 데이터의 경우, <span style="color:#c11f1f">브라우저 지원 여부</span> 및 <span style="color:#c11f1f">지원 포맷</span>에 대해 반드시 확인해봐야한다.</li>
<li>아래 소스는 Chrome 브라우저에서 <code>*.mp4</code> 및 <code>*.webm</code> 포맷으로만 테스트하였습니다.</li>
</ul></li>
<li><p>Source Example</p>

<ul>
<li>Cliend Side(use JS)</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">vw</span> <span class="o">=</span> <span class="mi">327</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">vh</span> <span class="o">=</span> <span class="mi">125</span><span class="p">;</span>

<span class="c1">// video Element 를 가져온다.</span>
<span class="kd">var</span> <span class="nx">video</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;video&#39;</span><span class="p">);</span>
<span class="nx">video</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">vw</span><span class="p">;</span>
<span class="nx">video</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">vh</span><span class="p">;</span>

<span class="c1">// view(부호 없는 1byte 정수 배열)를 생성한다.</span>
<span class="kd">var</span> <span class="nx">uInt8Array</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>

<span class="c1">// 생성된 view를 통해 Blob Object 를 생성한다.</span>
<span class="c1">// mp4 파일 가능</span>
<span class="kd">var</span> <span class="nx">blob</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">([</span><span class="nx">uInt8Array</span><span class="p">],</span> <span class="p">{</span><span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;video/webm&#39;</span><span class="p">});</span>

<span class="c1">// 생성된 Blob Object를 참조하는 URL 를 생성한다.</span>
<span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">URL</span><span class="p">.</span><span class="nx">createObjectURL</span><span class="p">(</span><span class="nx">blob</span><span class="p">);</span>

<span class="c1">// 생성된 Blob 객체를 참조하는 URL을 video.src 에 할당 후 로드한다.</span>
<span class="nx">video</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>Server Side(use nodeJS)</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;redcliff450.webm&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;onSocketMsg&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;resultVideoData&#39;</span><span class="p">,</span>
        <span class="nx">payload</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">buffer</span><span class="o">:</span> <span class="nx">buf</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></li>
</ul></li>
<li><p><strong>Chunk 방식으로 내려받은 비디오 플레이</strong></p>

<ul>
<li>서버에서 Chunk 방식으로 내려받은 ArrayBuffer(<strong>영상</strong> 데이터) 로 <span style="color:#c11f1f">view</span>(in Typed Array Views) 를 생성 후, 버퍼에 저장된 데이터를 조작한다.</li>
<li>MediaSource API 를 통해 내려받은 영상 데이터를 조작할 수 있다.</li>
<li><strong>영상</strong> 및 오디오 데이터의 경우, <span style="color:#c11f1f">브라우저 지원 여부</span> 및 <span style="color:#c11f1f">지원 포맷</span>에 대해 반드시 확인해봐야한다.</li>
<li>아래 소스는 Chrome 브라우저에서 <code>*.webm</code>(vorbis 및 vp8 코덱) 포맷으로만 테스트하였습니다.</li>
<li><p>Source Example</p>

<ul>
<li><p>Cliend Side(use JS)</p>

<ul>
<li>저장소로 부터 내려받은 파일을 include 한다.</li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">    <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;socket.io-stream.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
</code></pre></div><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// stream 객체에 socket 객체를 전달 후 해당 이벤트를 바인딩한다.</span>
<span class="nx">ss</span><span class="p">(</span><span class="nx">socket</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;onSocketMsg&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span> <span class="o">||</span> <span class="p">{};</span>

    <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">payload</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;resultChunkVideoData&#39;</span><span class="p">)</span> <span class="p">{</span>

        <span class="kd">var</span> <span class="nx">vw</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">vh</span> <span class="o">=</span> <span class="mi">768</span><span class="p">;</span>

        <span class="c1">// video Element 를 가져온다.</span>
        <span class="kd">var</span> <span class="nx">video</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;video&#39;</span><span class="p">);</span>
        <span class="nx">video</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">vw</span><span class="p">;</span>
        <span class="nx">video</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">vh</span><span class="p">;</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">stream</span><span class="p">);</span> <span class="c1">// 내려받은 stream 데이터</span>

        <span class="c1">// MediaSource 객체를 생성한다.</span>
        <span class="kd">var</span> <span class="nx">ms</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MediaSource</span><span class="p">();</span>

        <span class="c1">// 생성된 MediaSource 객체를 참조하는 URL 를 생성한다.</span>
        <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">URL</span><span class="p">.</span><span class="nx">createObjectURL</span><span class="p">(</span><span class="nx">ms</span><span class="p">);</span>

        <span class="c1">// 생성된 MediaSource 객체를 참조하는 URL을 video.src 에 할당 후 로드한다.</span>
        <span class="nx">video</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>

        <span class="c1">// MediaSource 의 각 이벤트를 바인딩 시킨다.</span>
        <span class="nx">ms</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;sourceopen&#39;</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        <span class="c1">// ms.addEventListener(&#39;webkitsourceopen&#39;, callback, false);</span>
        <span class="nx">ms</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;sourceended&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;mediaSource readyState: &#39;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">readyState</span><span class="p">);</span>
        <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

        <span class="kd">function</span> <span class="nx">callback</span><span class="p">()</span> <span class="p">{</span>

            <span class="c1">// 재생하려는 영상 소스를 추가한다.</span>
            <span class="kd">var</span> <span class="nx">sourceBuffer</span> <span class="o">=</span> <span class="nx">ms</span><span class="p">.</span><span class="nx">addSourceBuffer</span><span class="p">(</span><span class="s1">&#39;video/webm; codecs=&quot;vp8&quot;&#39;</span><span class="p">);</span>
            <span class="c1">// var sourceBuffer = ms.addSourceBuffer(&#39;video/webm; codecs=&quot;vp8,vorbis&quot;&#39;);</span>

            <span class="nx">sourceBuffer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;updatestart&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// console.log(&#39;updatestart: &#39; + ms.readyState);</span>
            <span class="p">});</span>

            <span class="nx">sourceBuffer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
                <span class="c1">// console.log(&#39;update: &#39; + ms.readyState);</span>
            <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>

            <span class="nx">sourceBuffer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;updateend&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;updateend: &#39;</span> <span class="o">+</span> <span class="nx">ms</span><span class="p">.</span><span class="nx">readyState</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="nx">sourceBuffer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;error: &#39;</span> <span class="o">+</span> <span class="nx">ms</span><span class="p">.</span><span class="nx">readyState</span><span class="p">);</span>
            <span class="p">});</span>
            <span class="nx">sourceBuffer</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;abort&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;abort: &#39;</span> <span class="o">+</span> <span class="nx">ms</span><span class="p">.</span><span class="nx">readyState</span><span class="p">);</span>
            <span class="p">});</span>

            <span class="nx">payload</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>

                <span class="c1">// chunk data</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>

                <span class="nx">sourceBuffer</span><span class="p">.</span><span class="nx">appendBuffer</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>

            <span class="p">});</span>

            <span class="c1">// 데이터 전송이 완료되었을 경우 발생한다.</span>
            <span class="nx">payload</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;endOfStream call&#39;</span><span class="p">);</span>
                <span class="c1">// 스트림을 종료한다.</span>
                <span class="nx">ms</span><span class="p">.</span><span class="nx">endOfStream</span><span class="p">();</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></li>
<li><p>Server Side(use nodeJS)</p></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">ss</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;socket.io-stream&#39;</span><span class="p">);</span>

<span class="nx">ss</span><span class="p">(</span><span class="nx">socket</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;onSocketMsg&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>

        <span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span> <span class="o">||</span> <span class="p">{};</span>

        <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">type</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">payload</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>

        <span class="kd">var</span> <span class="nx">stream</span> <span class="o">=</span> <span class="nx">ss</span><span class="p">.</span><span class="nx">createStream</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;downloadChunkVideo&#39;</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// webm 포맷의 영상을 가져온다.</span>
            <span class="kd">var</span> <span class="nx">filename</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">basename</span><span class="p">(</span><span class="s1">&#39;feelings_vp9-20130806-244.webm&#39;</span><span class="p">);</span>
            <span class="c1">// 파일 스트림을 생성한다.</span>
            <span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="nx">filename</span><span class="p">).</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">stream</span><span class="p">);</span>

            <span class="nx">ss</span><span class="p">(</span><span class="nx">socket</span><span class="p">).</span><span class="nx">emit</span><span class="p">(</span><span class="s1">&#39;onSocketMsg&#39;</span><span class="p">,</span> <span class="p">{</span>
                <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;resultChunkVideoData&#39;</span><span class="p">,</span>
                <span class="nx">payload</span><span class="o">:</span> <span class="p">{</span>
                    <span class="nx">stream</span><span class="o">:</span> <span class="nx">stream</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">});</span>
</code></pre></div>
<ul>
<li><p>테스트 결과</p>

<p><img src="/Users/sgjeon/blog_doc/img/bytesManipulation_11.jpg" alt=""></p></li>
</ul></li>
<li><p>참고 사이트</p>

<ul>
<li><p>Stream 모듈</p>

<ul>
<li><a href="https://github.com/nkzawa/socket.io-stream"></a></li>
</ul></li>
<li><p><a href="https://ko.wikipedia.org/wiki/WebM">WebM</a></p></li>
<li><p><a href="http://firejune.com/1788/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98+BLOB+%EA%B0%9D%EC%B2%B4?stext=blob">자바스크립트에서의 BLOB 객체</a></p></li>
<li><p><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.1/draft-spec/mediasource-draft-spec.html">Mediasource</a></p></li>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/API/MediaSource">MediaSource in MDN</a></p></li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/dn254959(v=vs.85).aspx">MediaSource Object in MS</a></p></li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/dn594470(v=vs.85).aspx">Media Source Extensions (MSE)</a></p></li>
<li><p><a href="https://html5-demos.appspot.com/static/media-source.html">Mediasource Chunk DEMO</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/Dn551368(v=VS.85).aspx">MPEG-DATA 스트리밍 플레이어 빌드 in MS</a></p></li>
<li><p><a href="https://simpl.info/video/offline/?1">simpl.info offline video</a></p></li>
<li><p><a href="http://megatuto.com/formation-HTML5.php?HTML5-Examples-Code=MediaSource+error:+This+SourceBuffer+has+been+removed+from+the+parent+media+source+Categorie+javascript+html5+media-source&amp;category=&amp;article=18543">MediaSource 소스 예제</a></p></li>
<li><p><a href="https://nodesource.com/blog/understanding-socketio">Socket IO Stream 코드 예제</a></p></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Struct in JS]]></title>
            <link>/designpattern/2015/08/07/struct-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/struct-inJS/</guid>
            <description>
                <![CDATA[1. 정의 C 와 C++(또는 C# 등) 에서 구조화 된 데이터를 처리할 때, Struct 를 사용하는데 이를 구조체라 부른다. 최초의 구조체는 C 언어에서 다양한 자료구조를 하나의 집합으로 만들어 관리하기위해 만들어졌다. 구조체는 하나 이상의 자료구조를 가진 또 하나의 데이터 타입을 정의한다. 이 글은 구조체를 다루는 여러 언어 중 [C# 구조체] 를...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li><p>C 와 C++(또는 C# 등) 에서 <strong>구조화 된 데이터</strong>를 처리할 때, <strong>Struct</strong> 를 사용하는데 이를 <a href="https://ko.wikipedia.org/wiki/Struct">구조체</a>라 부른다.</p>

<ul>
<li><p>최초의 <strong>구조체</strong>는 C 언어에서 다양한 <strong>자료구조</strong>를 하나의 <strong>집합</strong>으로 만들어 <strong>관리</strong>하기위해 만들어졌다.</p>

<ul>
<li>구조체는 하나 이상의 <strong>자료구조</strong>를 가진 또 하나의 <strong>데이터 타입</strong>을 정의한다.</li>
</ul></li>
<li><p>이 글은 <strong>구조체</strong>를 다루는 여러 언어 중 <code>[C# 구조체]</code> 를 기준으로 하고있다.</p></li>
</ul>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/struct_diagram.jpg?2" alt=""><br>
- 코드화</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">struct</span> <span class="nc">Song</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">yearRecorded</span><span class="p">;</span>

    <span class="c1">// 생성자</span>
    <span class="k">public</span> <span class="nf">Song</span><span class="p">(</span><span class="kt">int</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lengthInSeconds</span> <span class="p">=</span> <span class="n">p1</span><span class="p">;</span>
        <span class="n">yearRecorded</span> <span class="p">=</span> <span class="n">p2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestSong</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Initialize:</span>
        <span class="c1">// 생성된 객체는 Stack 메모리에 객체가 할당된다.</span>
        <span class="n">Song</span> <span class="n">song1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Song</span><span class="p">(</span><span class="m">213</span><span class="p">,</span> <span class="m">1994</span><span class="p">);</span>
        <span class="n">Song</span> <span class="n">song2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Song</span><span class="p">(</span><span class="m">248</span><span class="p">,</span> <span class="m">1988</span><span class="p">);</span>

        <span class="c1">// Display results:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;lengthInSeconds = {0}, yearRecorded = {1}&quot;</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">yearRecorded</span><span class="p">);</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;lengthInSeconds = {0}, yearRecorded = {1}&quot;</span><span class="p">,</span> <span class="n">song2</span><span class="p">.</span><span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">song2</span><span class="p">.</span><span class="n">yearRecorded</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Output:</span>
<span class="cm">    lengthInSeconds = 213, yearRecorded = 1994</span>
<span class="cm">    lengthInSeconds = 248, yearRecorded = 1988</span>
<span class="cm">*/</span>
</code></pre></div>
<ul>
<li><p><strong>구조체</strong>는 <strong>Class</strong> 와 같이 여러 특성(생성자, 상수, 필드, 메서드, 속성, 인덱서, 연산자, 이벤트 등)들을 <strong>그룹화</strong> 하는데 사용된다.</p>

<ul>
<li><strong>구조체</strong>와 <strong>클래스</strong>는 매우 비슷한 <strong>구조</strong>를 가지고 있으며, <u><strong>사용 방법</strong> 및 <strong>적용 이유</strong></u>가 유사하다.</li>
</ul></li>
</ul></li>
</ul>

<h2>2. C# 구조체의 특징</h2>

<ul>
<li><p><code>값 타입</code>이다.</p>

<ul>
<li><a href="https://msdn.microsoft.com/ko-kr/library/4d43ts61(v=vs.90).aspx">값 형식 및 참조 형식</a></li>
<li><p>[Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing]</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/memoryDiagram.jpg?2" alt=""></p>

<ul>
<li><a href="http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-">http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-</a></li>
</ul></li>
</ul></li>
<li><p>생성된 객체는 <strong>Stack</strong> 메모리에 할당된다.</p></li>
<li><p><strong>구조체</strong>는 보통 <u>작은 데이터</u>를 다루는데 <strong>적합</strong>하다.</p>

<ul>
<li><p>하지만 <strong>이것</strong>을 <strong>클래스</strong>로 <span style="color:#c11f1f">표현할 수 없는 것</span>은 아니다.(그냥 작은 Class를 만들면 그만이다;;)</p>

<ul>
<li><em>그럼에도 불구하고 <code>구조체</code>를 써야하는 이유는 <u>분명 존재</u>할 것이다.</em></li>
</ul></li>
</ul></li>
<li><p><strong>new</strong> 연산자를 사용하지 않고도 <strong>인스턴스화</strong>할 수 있다.</p>

<ul>
<li>하지만 <u><strong>생성자</strong>를 호출하지 않으므로</u>, 선언된 맴버를 따로 <strong>초기화</strong> 해야하는 <span style="color:#c11f1f">불편함</span>이 존재한다.</li>
</ul>
<div class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">struct</span> <span class="nc">Song</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">yearRecorded</span><span class="p">;</span>

    <span class="c1">// 생성자</span>
    <span class="k">public</span> <span class="nf">Song</span><span class="p">(</span><span class="kt">int</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lengthInSeconds</span> <span class="p">=</span> <span class="n">p1</span><span class="p">;</span>
        <span class="n">yearRecorded</span> <span class="p">=</span> <span class="n">p2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestSongNoNew</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// new 연산자 없이 인스턴스를 생성한다.</span>
        <span class="c1">// Stack 메모리에 객체가 할당된다.</span>
        <span class="c1">// 생성자를 호출하지 않는다.</span>
        <span class="n">Song</span> <span class="n">song1</span><span class="p">;</span>

        <span class="c1">// 속성 초기화</span>
        <span class="n">song1</span><span class="p">.</span><span class="n">lengthInSeconds</span> <span class="p">=</span> <span class="m">213</span><span class="p">;</span>
        <span class="n">song1</span><span class="p">.</span><span class="n">yearRecorded</span> <span class="p">=</span> <span class="m">1994</span><span class="p">;</span>

        <span class="c1">// Display results:</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;lengthInSeconds = {0}, yearRecorded = {1}&quot;</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">lengthInSeconds</span><span class="p">,</span> <span class="n">song1</span><span class="p">.</span><span class="n">yearRecorded</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Output:</span>
<span class="cm">    lengthInSeconds = 213, yearRecorded = 1994</span>
<span class="cm">*/</span>
</code></pre></div></li>
<li><p><strong>구조체</strong>는 <strong>구조체</strong> 또는 <strong>클래스</strong>에서 <u>상속될 수 없으며</u>, 클래스의 기본 클래스가 될 수 없다.</p>

<ul>
<li><strong>클래스</strong>와 달리, 상속 구조를 구현할 수 없다.</li>
</ul></li>
<li><p><strong>클래스</strong>와 같이 <u><strong>인터페이스</strong>를 구현할 수 있다.</u></p></li>
<li><p>구조체는 <strong>Stack</strong> 영역에 할당되는 <strong><span style="color:#c11f1f">값 타입</span></strong>이고, 클래스는 <strong>Heap</strong> 영역에 할당되는 <strong><span style="color:#c11f1f">참조 타입</span></strong>이다.</p>

<ul>
<li><p><strong>Stack</strong> 영역(<span style="color:#c11f1f">정적 할당</span>)이란?</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/struct_stack.jpg" alt=""></p></li>
<li><p><strong>Stack</strong> 영역은 <strong>컴파일 시점</strong>에서 크기가 <strong>결정</strong>되는 요소들이 저장되는 <strong>메모리 영역</strong>이다.</p>

<ul>
<li>함수 내부 <strong>지역 변수</strong> 와 <strong>매개 변수</strong>는 <strong>Stack</strong> 영역에 할당되며, 함수 종료 시 <strong>소멸</strong>된다.</li>
</ul></li>
<li><p><strong>Stack</strong> 영역은 <strong>LIFO</strong>(Last In First out)라는 <strong>자료구조</strong> 가진다.</p>

<ul>
<li><p><em>즉 마지막에 넣은(Push) 데이터가 <code>가장 먼저</code> 나가는것을(Pop) 의미한다.</em></p>

<ul>
<li><p>Stack Push 순서:</p>

<ul>
<li>A &gt; B &gt; C &gt; D &gt; E</li>
</ul></li>
<li><p>Stack Pop 순서:</p>

<ul>
<li>E &gt; D &gt; C &gt; B &gt; A</li>
</ul></li>
</ul></li>
<li><p>그럼 <strong>JS Stack</strong> 은?</p>

<ul>
<li><p>JS 는 <a href="https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4"><strong>동적 언어</strong></a> 이므로 <strong>컴파일 시점</strong>이 아닌 <strong>런타임 시점</strong>에서 메모리가 <strong>할당</strong>(allocation)된다.</p>

<ul>
<li>C, C++, C#(<strong>정적 언어</strong>)</li>
</ul></li>
<li><p>JS <strong>원시 타입</strong>(string, number, boolean, undefined, null)은 <strong>고정된 크기</strong>를 가지며, <strong>Stack</strong> 메모리 영역에 할당된다.</p></li>
<li><p>JS 의 모든 <strong>실행 컨텍스트</strong>는 <span style="color:#c11f1f">ECStack</span>(일종의 <a href="https://ko.wikipedia.org/wiki/%EC%BD%9C_%EC%8A%A4%ED%83%9D">Call Stack</a>) 내부로 할당된다.</p>

<ul>
<li><p>아래와 같은 방법으로 <code>ECStack Count</code> 를 셀 수 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getStackCount</span><span class="p">(){</span>

    <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">try</span><span class="p">{</span>
        <span class="p">(</span><span class="kd">function</span> <span class="nx">_stack</span><span class="p">(){</span>

            <span class="o">++</span><span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">();</span>
        <span class="p">})();</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>

        <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// get call stack count</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;call stack count: &#39;</span> <span class="o">+</span> <span class="nx">getStackCount</span><span class="p">());</span>

<span class="cm">/* output</span>

<span class="cm"> Maximum call stack size exceeded</span>

<span class="cm"> // 15,745 번 함수 호출 후 Stack overflow 가 발생했다.</span>
<span class="cm"> call stack count: 15745</span>

<span class="cm"> */</span>
</code></pre></div></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>Heap</strong> 영역(<span style="color:#c11f1f">동적 할당</span>)이란?</p>

<ul>
<li><p><strong>Heap</strong> 영역은 <strong>런타임 시점</strong>에서 크기가 <strong>결정</strong>되는 요소들이 저장되는 <strong>메모리 영역</strong>이다.</p>

<ul>
<li>Object 또는 Array Data Type 등을 가진다.</li>
</ul></li>
<li><p><strong>Heap</strong> 영역은 <strong>런타임 시점</strong>에서 메모리를 <u><strong>가변적</strong>으로 <strong>동적</strong> <span style="color:#c11f1f">할당</span> 및 <span style="color:#c11f1f">반환</span>(GC를 통해) 시키는 구조</u>를 가진다.</p></li>
<li><p><strong>GC</strong>는 <strong>할당</strong>된 <strong>Heap</strong> 메모리 영역의 <span style="color:#c11f1f">반환</span>(de-allocated(수거))을 담당한다.</p>

<ul>
<li><p><strong>GC</strong>(Garbage Collection)란?</p>

<ul>
<li><strong>자동 메모리 관리</strong>의 한 형태이며, 프로세스 수행 중, 더 이상 필요가 없어진 <strong>객체</strong>가 점유하는 <u>메모리에 대해 <span style="color:#c11f1f">반환</span> 작업을 수행</u>한다.</li>
<li>프로그래머가 직접 메모리를 <span style="color:#c11f1f">반환</span>할 수는 없다.(반드시 <code>GC</code>를 통해 반환된다)</li>
<li><p>단 GC에게 메모리 <u>**반환** 조건</u>을 만들어 줄 수는 있다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span>

<span class="c1">// 메모리 반환 조건을 만들어 준다.</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>JS <strong>Heap</strong> 메모리 영역 테스트 해보기!!</p>

<ul>
<li><p>V8 <strong>Handle scope</strong> Diagram</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/handleV8.jpg" alt=""></p></li>
<li><p>아래 코드는 <strong>Heap</strong> 메모리 영역에 <strong>객체</strong>를 <span style="color:#c11f1f">할당</span>하는 예제이다.</p></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="c1">// 전역 실행 컨텍스트에서 함수 객체를 하나 선언한다.</span>

<span class="c1">// 선언된 함수 객체는 Heap 메모리 영역에 할당된다.</span>
<span class="kd">function</span> <span class="nx">globalA</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">init</span><span class="p">(){</span>

    <span class="c1">// _global 전역 변수에 생성된 인스턴스를 할당한다.</span>
    <span class="c1">// 이때 전역 변수(참조 변수)는 Heap 메모리 영역에 할당된 객체를 참조하게된다.</span>

    <span class="nx">_global</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">globalA</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">init</span><span class="p">();</span>
</code></pre></div>
<ul>
<li><p><strong>전역 실행 컨텍스트</strong>에서 선언된 <strong>globalA</strong> 함수 객체의 <strong>Heap</strong> 메모리 영역.</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/heapSnapShot0.jpg" alt=""></p></li>
<li><p><strong>_global</strong> 전역 변수가 참조하는 <strong>객체</strong>의 <strong>Heap</strong> 메모리 영역.</p>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/heapSnapShot1.jpg" alt=""></p></li>
<li><p><span style="color:#c11f1f">Chrome Inspector</span>를 통해 할당된 <strong>Heap 메모리 영역</strong>을 살펴볼 수 있다.</p>

<ul>
<li><a href="http://stackoverflow.com/questions/20697298/understanding-chrome-heap-profile">understanding chrome heap profile</a></li>
</ul></li>
<li><p>만약 함수 <strong>지역 변수</strong>에 <strong>객체</strong>를 할당했다면, 그 객체(<strong>Heap</strong> 영역)의 메모리 <strong><span style="color:#c11f1f">반환</span></strong> <strong>시점</strong>은 언제일까?</p>

<ul>
<li><p><em>결론: <code>지역 변수</code>에 할당된 객체 메모리 <span style="color:#c11f1f">반환</span> 시점은 <u></em><em>함수 종료 시점</em><em></u>이 된다.</em></p>

<ul>
<li><p>테스트 1: <code>전역 변수</code>와 함수 <code>지역 변수</code>에 동일한 <code>객체</code>를 할당해본 후 <code>Profile</code> 을 통해 <code>Heap</code> 영역을 관찰해본다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="c1">// 전역 실행 컨텍스트에서 함수 객체를 하나 선언한다.</span>

<span class="c1">// 선언된 함수 객체는 Heap 메모리 영역에 할당된다.</span>
<span class="kd">function</span> <span class="nx">globalA</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">init</span><span class="p">(){</span>

    <span class="c1">// _district 지역 변수에 생성된 인스턴스를 할당한다.</span>
    <span class="c1">// 이때 지역 변수(참조 변수)는 Heap 메모리 영역에 할당된 객체를 참조하게된다.</span>

    <span class="c1">// 단 지역 변수에 할당된 객체의 &quot;메모리 반환 시점&quot;은, 함수 종료 시점(함수 실행 컨텍스트 종료 시점)이 된다.</span>

    <span class="kd">var</span> <span class="nx">_district</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">globalA</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">init</span><span class="p">();</span>
</code></pre></div></li>
<li><p><code>지역 변수</code>에 할당된 <code>객체</code>는 <code>Heap</code> 메모리 영역에서 <span style="color:#c11f1f">반환</span>되어 보이지 않는다.</p></li>
</ul>

<p><img src="http://mohwa.github.io/blog/assets/images/posts/heapSnapShot2.jpg" alt=""></p></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h2>3. JS 로 Struct 구현해보기</h2>

<ul>
<li><p>위에서 나열한 <strong>구조체</strong>의 <strong>특징</strong> 중 <strong>클래스</strong>와 <strong>본질</strong>적으로 다른 부분인, <u><strong>데이터 생성</strong></u>에 대한 부분을 JS 를 통해 구현해 보았다.</p>

<ul>
<li>구조체: <strong>값</strong> 타입(<strong>Stack</strong> 메모리 영역에 할당되며, 값이 <span style="color:#c11f1f">복사</span>되어 할당된다)</li>
<li>클래스: <strong>참조</strong> 타입(<strong>Heap</strong> 메모리 영역에 할당되며, <span style="color:#c11f1f">참조</span> 값이 할당된다)</li>
</ul></li>
<li><p><code>구조체</code>의 특징 중 극히 일부를 구현한것이며, 타 언어에서 구현된 구조체라 할 수는 없다.</p></li>
</ul>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Struct</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;string&#39;</span> <span class="o">||</span>
        <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="o">||</span>
        <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;boolean&#39;</span> <span class="o">||</span>
        <span class="nx">val</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span>
        <span class="nx">val</span> <span class="o">===</span> <span class="kc">undefined</span>
    <span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;primitive type value: &#39;</span> <span class="o">+</span> <span class="nx">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">_copy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>

        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">constructor</span> <span class="o">=</span> <span class="nx">val</span><span class="p">.</span><span class="nx">constructor</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">){</span>

            <span class="c1">// 함수(상황에 따라 생성자 함수가 될 수도 있다) 객체 내부 this 값을 apply 함수를 통해 초기화 시키고, 그 결과를 반환하는 함수를 생성한다.</span>
            <span class="nx">ret</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$F</span><span class="p">(){</span>

                <span class="c1">// this === global or $F of instance object</span>
                <span class="k">return</span> <span class="nx">val</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
            <span class="p">};</span>

            <span class="c1">// 전달된 함수 객체의 prototype(객체 원형)을 할당한다.</span>
            <span class="nx">ret</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">val</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">String</span> <span class="o">||</span> <span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Number</span> <span class="o">||</span> <span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Boolean</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">constructor</span><span class="p">(</span><span class="nx">val</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Date</span><span class="p">){</span>
            <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">constructor</span><span class="p">(</span><span class="nx">val</span><span class="p">.</span><span class="nx">getTime</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Object</span> <span class="o">||</span> <span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Array</span><span class="p">){</span>

            <span class="nx">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">constructor</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">n</span> <span class="k">in</span> <span class="nx">val</span><span class="p">){</span>

                <span class="k">if</span> <span class="p">(</span><span class="nx">val</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">n</span><span class="p">)){</span>
                    <span class="nx">ret</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>

    <span class="p">}(</span><span class="nx">val</span><span class="p">)</span> <span class="o">||</span> <span class="nx">val</span><span class="p">;</span>


    <span class="k">return</span> <span class="nx">_copy</span><span class="p">;</span>
<span class="p">}</span>

    <span class="c1">// 5 가지의 원시 타입 값 할당</span>
<span class="nx">Struct</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">);</span> <span class="c1">// test</span>
<span class="nx">Struct</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">Struct</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">Struct</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">Struct</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// null</span>

<span class="cm">/*</span>
<span class="cm">    모든 경우(모든 타입)에 전달된 원본 값(객체)이 아닌 복사 된 값을 반환한다.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm"> 함수 객체 선언</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">$$</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">$$</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">_$$</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">_$$</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 나를통해 생성될 객체 원형에 새로운 객체를 할당한다.</span>
    <span class="nx">_$$</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">getX</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="nx">$$</span><span class="p">.</span><span class="nx">staticMethod</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>

    <span class="k">return</span> <span class="nx">$$</span><span class="p">;</span>
<span class="p">}();</span>

<span class="cm">/*</span>
<span class="cm"> 다른 유형의 함수 객체 선언</span>
<span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">Plus</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">){</span>

    <span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">originalFn</span> <span class="o">=</span> <span class="nx">$$</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">structFn</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="nx">$$</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn</span><span class="p">);</span> <span class="c1">// function</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn</span><span class="p">);</span> <span class="c1">// function</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn</span><span class="p">());</span> <span class="c1">// object</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn</span><span class="p">());</span> <span class="c1">// object</span>

<span class="kd">var</span> <span class="nx">originalFn1</span> <span class="o">=</span> <span class="nx">Plus</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">structFn1</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="nx">Plus</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn1</span><span class="p">);</span> <span class="c1">// function</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn1</span><span class="p">);</span> <span class="c1">// function</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">originalFn1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// 4</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structFn1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// 5</span>

<span class="kd">var</span> <span class="nx">structStr</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">));</span>
<span class="kd">var</span> <span class="nx">structNum</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structStr</span><span class="p">);</span> <span class="c1">// string object</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structNum</span><span class="p">);</span> <span class="c1">// number object</span>

<span class="kd">var</span> <span class="nx">structObject</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">});</span>
<span class="kd">var</span> <span class="nx">structArray</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structObject</span><span class="p">);</span> <span class="c1">// object</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structArray</span><span class="p">);</span> <span class="c1">// array</span>

<span class="kd">var</span> <span class="nx">structBoolean</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structBoolean</span><span class="p">);</span> <span class="c1">// boolean object</span>


<span class="kd">var</span> <span class="nx">structDate</span> <span class="o">=</span> <span class="nx">Struct</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">());</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">structDate</span><span class="p">);</span> <span class="c1">// date object</span>
</code></pre></div>
<h2>4. 정리하며</h2>

<ul>
<li><p>그럼 언제 사용하면될까?</p>

<ul>
<li><p>개인적인 생각으로는 이럴때가 아닌가 싶다?</p>

<ul>
<li><p>클래스로 만들기에는 너무 간단한 구조인 경우.</p>

<ul>
<li><p>사실 이 경우, 반드시 <strong>구조</strong> 만의 문제는 아닐 수 있다.</p>

<ul>
<li>만약 모든 경우에 <strong>클래스</strong>를 사용한다면, 위에서 언급한 봐와같이 <strong>객체</strong>는 <strong>Heap</strong> 영역에 <span style="color:#c11f1f">할당</span>될 것이며, 결국 <strong>GC</strong> 는 그 메모리 <strong>반환</strong>을 위해 쓸때 없는 리소스를 <strong>낭비</strong>하게 될 것이다.</li>
</ul></li>
</ul></li>
<li><p><strong>상속 구조</strong>를 만들 필요가 없는 경우.</p></li>
</ul></li>
<li><p>하지만, 이 두 가지 특징 모두 <strong><span style="color:#c11f1f">각 언어</span></strong>(C/C++/C# 등 구조체를 가진 모든 언어)가 가지는 <strong><span style="color:#c11f1f">특성</span></strong>에 따라 충분히 변할 수 있는 부분이므로 모든 언어에 <strong>적용</strong>된다고 말할 수는 없다.</p>

<ul>
<li><em>간단히 말해, 특정 <code>언어</code>가 <code>구조체</code>를 어떤 방식으로 <code>구현</code>하느냐에 따라, <code>사용 범위</code>도 크게 달라질 수 있다는 말과 같다.</em></li>
</ul></li>
</ul></li>
</ul>

<h2>5. 참고 URL</h2>

<ul>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/0taef578.aspx">C# 구조체 설명</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/0b0thckt.aspx">C# 클래스 설명</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/13266616/primitive-value-vs-reference-value">primitive value vs reference value</a></p></li>
<li><p><a href="http://codingnuri.com/javascript-tutorial/javascript-primitive-types-and-reference-types.html">원시 타입과 참조 타입</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/4d43ts61(v=vs.90).aspx">값 형식 및 참조 형식(Visual C# Express)</a></p></li>
<li><p><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/">What is the Execution Context &amp; Stack in JavaScript?</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/11148353/javascript-scope-and-execution-context">javascript-scope-and-execution-context</a>=</p></li>
<li><p><a href="http://dsnight.tistory.com/50">C언어의 메모리 구조</a></p></li>
<li><p><a href="http://egloos.zum.com/recipes/v/5057426">STACK, HEAP에 관한 소고</a></p></li>
<li><p><a href="https://kldp.org/node/44714">도대체 [구조체]가 [클래스]보다 좋은점이 뭔가요?</a></p>

<ul>
<li><em>개인적으로 이런 글을 좋아한다.(다양한 생각들을 들을 수 있으며, 그로인해 많은 <code>영감</code>을 얻기도 한다)</em></li>
</ul></li>
<li><p><a href="https://opentutorials.org/course/1720/9735">메모리 구조</a></p></li>
<li><p><a href="http://adibong.tistory.com/169">프로그램과 메모리 , 스택과 힙</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[ObjectPool in JS]]></title>
            <link>/designpattern/2015/08/07/objectpool-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/objectpool-inJS/</guid>
            <description>
                <![CDATA[1. 정의 생성된 객체들을 별도의 Pool 안에 저장 후 재사용 하는 방법으로, 불필요한 객체 생성 및 반환(GC에 의한)을 최소화하는 디자인 패턴중 하나 이다. 객체 재사용을 위해, 생성된 객체를 Pool 안에 저장시켜 놓는다. 새로운 객체가 필요할때는, 무조건 새로 생성하는것이 아니라, Pool 안에 반환된 객체가 존재한다면, 그 중 하나를 재사용 한다. 객체...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li><p>생성된 <strong>객체</strong>들을 별도의 <strong>Pool</strong> 안에 저장 후 <span style="color:#c11f1f">재사용</span> 하는 방법으로, 불필요한 객체 <strong>생성</strong> 및 <strong>반환</strong>(<strong>GC</strong>에 의한)을 <span style="color:#c11f1f">최소화</span>하는 <u><strong>디자인 패턴</strong></u>중 하나 이다.</p>

<ul>
<li><strong>객체</strong>  <span style="color:#c11f1f">재사용</span>을 위해, 생성된 <strong>객체</strong>를 <strong>Pool</strong> 안에 저장시켜 놓는다.</li>
<li><p>새로운 <strong>객체</strong>가 필요할때는, <u>무조건 새로 <span style="color:#c11f1f">생성</span></u>하는것이 아니라, <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>된 <strong>객체</strong>가 존재한다면, <u>그 중 하나를 <span style="color:#c11f1f">재사용</span> 한다.</u></p>

<ul>
<li><em>객체 <span style="color:#c11f1f">재사용</span>으로 Heap 메모리 사용을 <span style="color:#c11f1f">최소화</span>한다.</em></li>
</ul></li>
<li><p>사용(객체)이 끝난 후에는 <u>다시 <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>시킨다.</u></p></li>
</ul></li>
</ul>

<h2>2. 특징</h2>

<ul>
<li><p>정해진 <strong>범위</strong>내에서 개발자가 직접 <u><strong>Heap 메모리</strong>를 관리(객체 <span style="color:#c11f1f">생성</span> 및 <span style="color:#c11f1f">반환</span>)</u>할 수 있다.</p>

<ul>
<li><p><u><strong>객체 생성 비용</strong></u>을 줄일 수 있다.(Heap 메모리 사용을 줄일 수 있다)</p>

<ul>
<li><em>당연한 말이겠지만, 생성되는 객체 <span style="color:#c11f1f">크기</span> 및 그 <span style="color:#c11f1f">수</span>에 따라, <u>더 많은 비용을 줄일 수도 있다.</u></em></li>
</ul></li>
<li><p><strong>GC</strong> 를 통해 일어나는, <u>메모리 <span style="color:#c11f1f">반환</span>(반환 시 일어나는 일련의 작업들)) <strong>비용</strong>을 줄일 수 있다.</u></p>

<ul>
<li>보통 이 과정(메모리 반환 과정)을 처리하는 동안에는, <strong>프로그램 실행</strong> 이 중단된다.</li>
<li>또한, 이 과정은 <u>프로그램 실행 중 <span style="color:#c11f1f">임의의 시간</span>에, <span style="color:#c11f1f">임의의 시간동안</span> 언제라도 일어날 수 있다.</u></li>
<li>개발자는 이 <strong>과정</strong>을 <u><span style="color:#c11f1f">제어</span>할 수 없다.</u></li>
</ul>

<p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
</ul></li>
<li><p><span style="color:#c11f1f">재사용</span>되는 <strong>객체</strong>는 <u>모두 <strong>동일한 타입</strong>을 갖는다.</u></p></li>
</ul>

<h2>3. JS 로 동적 ObjetPool 구현해보기</h2>

<iframe height='540' scrolling='no' src='http://codepen.io/yanione/embed/jPdzWB/?height=540&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/jPdzWB/'>jPdzWB</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe>

<ul>
<li>일반적인 동적 <strong>Objet Pool</strong> 기능을 만드는 방법은 위 코드와 같이 크게 어렵지 않다.(물론 지원하는 기능의 범위에 따라, 구현 수준은 크게 달라질 수 있다)</li>
</ul>

<h2>4. ObjectPool 적용 테스트</h2>

<ul>
<li><p>Click 버튼을 <span style="color:#c11f1f">10</span>번 누른 후 <strong>Profiles(in Chrome Tool) 패널</strong>을 통해, <strong>Heap Memory</strong> 를 체크하면 <span style="color:#c11f1f">적용</span> <strong>유/무</strong>에 따른 결과를 얻을 수 있다.</p>

<ul>
<li><p><strong>Object Pool</strong> 적용 전</p>

<ul>
<li><p><span style="color:#c11f1f">Ball</span> 생성자 함수를 통해 객체를 <strong>300</strong>개 할당했다.</p>

<ul>
<li>30 * 10 = 300(무조건 새로운 객체를 Heap 메모리에 할당했다)</li>
</ul></li>
</ul>

<p><img src="/blog/assets/images/posts/ballHeap.jpg" alt=""></p></li>
<li><p><strong>Object Pool</strong> 적용 후</p>

<ul>
<li><p><span style="color:#c11f1f">$F</span> 생성자 함수를 통해 <strong>93</strong>개의 객체를 할당했다.</p>

<ul>
<li><span style="color:#c11f1f">$F</span>: <strong>Object Pool</strong> 라이브러리상에서 만든 생성자 함수.</li>
<li>적용 후에는 총 <strong>93</strong>개의 객체를 <span style="color:#c11f1f">할당</span>했으며, <strong>207</strong>개의 객체를 <span style="color:#c11f1f">재사용</span>하였다.</li>
</ul></li>
</ul>

<p><img src="/blog/assets/images/posts/ballHeap2.jpg" alt=""></p></li>
</ul></li>
</ul>

<h2>5. 정리하며</h2>

<ul>
<li><p>즉 지나친 객체 <span style="color:#c11f1f">생성</span> 및 <span style="color`:#c11f1f">반환</span>을 <strong>최소화</strong> 하는것이, <strong>어플리케이션</strong>상에 <span style="color:#c11f1f">메모리 변동</span>을 줄이는 방법이며, 이로인해 사용자 경험까지 최적화할 수 있다.</p></li>
<li><p>일반적인 <strong>웹</strong>상에서는 적용할 일이 거의 없어보이지만, <strong>게임 어플리케이션</strong>이라면, 적용 범위가 꽤 많을 듯 하다.</p></li>
</ul>

<h2>6. 참고 URL</h2>

<ul>
<li><p><a href="http://ufx.kr/blog/591">액션스크립트의 객체 재사용을 위한 오브젝트 풀(Object Pool)</a></p></li>
<li><p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
<li><p><a href="http://beej.us/blog/data/object-pool/">Object Pools</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Interface in JS]]></title>
            <link>/designpattern/2015/08/07/interface-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/interface-inJS/</guid>
            <description>
                <![CDATA[1. 정의 가장 큰 범위의 인터페이스 정의는 사물 간 또는 사물과 인간 간(User Interface)의 의사소통을 위한 중간 매개체다. 즉 서로간의 의사소통을 위해 정해진 약속이 존재하며, 이를 표준 규격 이라 말할 수 있는것이다. 2. 의미 인터페이스(DB Interface): 구현 클래스가 공통적으로 가져야할 필수 특성(connect, disconnect 등)들을 선언함으로써, 해당 구현 클래스들에게 사용자(User Class)와의...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li>가장 큰 범위의 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">인터페이스</a> <code>정의</code>는 사물 간 또는 사물과 인간 간(<a href="https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">User Interface</a>)의 의사소통을 위한 중간 <span style="color:#c11f1f">매개체</span>다. 즉 서로간의 의사소통을 위해 정해진 약속이 존재하며, 이를 <code>표준 규격</code> 이라 말할 수 있는것이다.</li>
</ul>

<h2>2. 의미</h2>

<p><img src="/blog/assets/images/posts/interface_diagram.png" alt=""></p>

<ul>
<li><p><strong>인터페이스</strong>(<code>DB Interface</code>):</p>

<ul>
<li><p><strong>구현 클래스</strong>가 공통적으로 가져야할 필수 <span style="color:#c11f1f">특성</span>(connect, disconnect 등)들을 <strong>선언</strong>함으로써, 해당 구현 클래스들에게 <strong>사용자</strong>(<code>User Class</code>)와의 <strong>의사 소통</strong> 방침(<span style="color:#c11f1f">표준 규격</span>)을 알리는데 목적이 있다.</p>

<ul>
<li>[x] <em>인터페이스 내부에 선언된 모든 특성은 구현 클래스를 통해 반드시 구현되어야 한다.</em></li>
</ul></li>
</ul></li>
<li><p><strong>구현 클래스</strong>(<code>MSSQL, ORACLE API Class 등</code>):</p>

<ul>
<li><p>사용자(<code>User Class</code>)와의 의사소통을 위해 인터페이스 내부에 선언된 모든 특성들을 충실히 구현한다.</p>

<ul>
<li><p><em>이때 <code>사용자</code> 입장에서는 특정 구현 클래스 <code>명세</code> 없이도, 인터페이스 명세에 따라 제공받은 모든 API 를 사용할 수 있다는 장점이 존재한다.</em></p>

<ul>
<li>[x] <em>정확히 말하자면, 특정 API 의 모든 기능이 아닌 인터페이스를 구현한 기능에 한정된다.</em></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h2>3. 상황에 따른 의미</h2>

<ul>
<li><p>만약 운영중인 어플리케이션의 DB 플랫폼이 <strong>MSSQL</strong> 에서 <strong>PostgreSQL</strong> 로 변경된다고 가정해보자.(오랜 기간 운영중인 어플리케이션의 경우 이런저런 이유로 이와 같은 상황이 충분히 올 수 있다)</p>

<p>이때 위 다이어그과 같은 <code>인터페이스 설계</code>가 되어있는 상태라면, <strong>PostgreSQL</strong> 규격에 따라, 구현 클래스만 작성하면 최소 비용으로 기능을 <span style="color:#c11f1f">확장</span>할 수 있을 것이다.</p>

<ul>
<li><em>또 <code>사용자 입장</code>에서보면, 인터페이스를 통해 구현된, 공통적인 기능 만큼은 기존 코드를 <span style="color:#c11f1f">재사용</span>할 수 있다는 큰 장점까지 갖게 되는 것이다.(어플리케이션 유지보수 비용 최소화)</em></li>
</ul></li>
</ul>

<h2>4. JS 로 인터페이스 구현해보기</h2>

<iframe width="100%" height="1000" src="http://jsfiddle.net/mohwa/jzu5r06e/3/embedded/js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>인터페이스 <code>구현</code>은 아래 <strong>C# 인터페이스 가이드</strong>에 맞춰 구현되었으며, JS 코드에 대한 자세한 설명은 따로 하지 않겠다.(만약 JS 에 대해 어느정도 알고 있는 상황이라면, 코드를 분석해보길 권장한다)</p>

<ul>
<li><p>아래는 구현에 대한 간략한 설명이다.</p>

<ul>
<li><p>인터페이스 선언을 위한 인터페이스 함수 객체를 구현한다.</p>

<ul>
<li>인터페이스 [이벤트] 선언을 위해 <strong>Observer</strong> 기능을 구현한다.</li>
<li><a href="https://msdn.microsoft.com/ko-kr/library/awbftdfh.aspx">C# 이벤트 선언</a></li>
</ul></li>
<li><p>인터페이스를 상속받은 <strong>구현 클래스</strong>를 검증(상속받은 인터페이스를 모두 구현했는지에 대한 검증)하는 함수 객체(Interface.ensureImplement)를 구현한다.</p></li>
<li><p>위 다이어그램과 같이 <strong>인터페이스</strong> 및 각 <strong>클래스</strong>(구현 클래스)들을 구현한다.</p></li>
</ul></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/ms173156.aspx">C# 인터페이스</a>(인터페이스 <code>정의</code>는 각 언어마다 조금씩 차이를 보인다(모든 언어에 동일하게 구현되어있지 않다))</p></li>
</ul>

<h2>5. 정리하며</h2>

<ul>
<li><p><strong>인터페이스</strong>는 개발 중인 어플케이션 규모 및 설계에 따라 적용 범위가 얼마든지 달라질 수 있다.(또는 사용이 불필요할 수 도 있다(간혹 팀내에서의 <strong>관행</strong>적인 적용이 있다는 말을 들은적이 있는데 이건 정말 아닌듯 하다;;;))</p>

<ul>
<li><em>너무 당연한 말일 수 도 있지만, 인터페이스와 같은 모든 디자인 패턴은 적재 적소에 활용해야만 득이되는 것이다.</em></li>
</ul></li>
<li><p>위에서 언급한 내용과 다른 <strong>적용 사례</strong>에 대해(<em>인터페이스를 구현하는 상황이 또 모가 있을까?) 한번쯤 심도있게 생각해보길 바란다</em></p></li>
</ul>

<h2>6. 참고 URL</h2>

<ul>
<li><p><a href="http://woonohyo.tistory.com/22">DI란?</a></p></li>
<li><p><a href="http://okky.kr/article/161248">인터페이스 사용이유</a></p></li>
<li><p><a href="http://masamune.tistory.com/16">인터페이스란</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/tkyhsw31.aspx">C# 인터페이스 인덱서</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/64syzecx.aspx">C# 인터페이스 속성</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/ak9w5846.aspx">C# 인터페이스 이벤트</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    

</channel>

</rss>