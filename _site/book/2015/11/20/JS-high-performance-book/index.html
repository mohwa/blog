<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <!-- viewport 설정 -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- keyword 설정 -->
    <meta name="keywords" content="book">
    <!-- description 설정 -->
    <meta name="description" content="Javascript 성능 최적화 책을 읽고.. - 데이터 접근 -" />

    <!-- open graph 설정 -->
    <meta property="og:type" content="mohwa blog">
    <meta property="og:title" content="Javascript 성능 최적화 책을 읽고.. - 데이터 접근 -">
    <meta property="og:description" content="Javascript 성능 최적화 책을 읽고.. - 데이터 접근 -">
    <!--<meta property="og:image" content="http://mysite.com/myimage.jpg">-->
    <meta property="og:url" content="/blog">

    <meta name="copyright" content="by mohwa" />

    <!--<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />-->

    <!-- google search console 설정 -->
    <link rel="alternate" hreflang="ko" href="http://mohwa.github.io" />
    <link rel="alternate" hreflang="ko" href="https://mohwa.github.io" />

    <link rel="stylesheet" href="/blog/assets/css/site.css" />
    <link rel="stylesheet" href="/blog/bower_components/highlightjs/styles/darkula.css">

    <script src="/blog/bower_components/jquery/dist/jquery.min.js" type="text/javascript"></script>
    <script src="/blog/bower_components/highlightjs/highlight.pack.min.js" type="text/javascript"></script>
    <script src="/blog/bower_components/purl/purl.js" type="text/javascript"></script>
    <!-- Script pointing to jekyll-search.js -->
    <script src="/blog/bower_components/simple-jekyll-search/dest/jekyll-search.js" type="text/javascript"></script>

    <title>Javascript 성능 최적화 책을 읽고.. - 데이터 접근 -</title>

    <script type="text/javascript">

        // code highlight 적용
        // https://highlightjs.org/static/demo/
        $(document).ready(function() {
            $('pre code').each(function(i, block) {
                hljs.highlightBlock(block);
            });
        });
    </script>
</head>

<body>

  <div class="top-bar"></div>

  <div class="container">
    <div class="site">
      <header>
        <nav>
    <span style="float:left;">
        <a class="" href="/blog/">Home</a>
        <!--<a class="" href="/archive/">전체글</a>-->
        <!--<a class="" href="//github.com/nolboo/nolboo.github.io/wiki">번역글 위키</a>-->
    </span>
    <span style="float:right;">
        <div id="search-container" class="search-container">
            <input type="text" id="search-input" class="search-input" placeholder="search...">
        </div>
    </span>
</nav>

        <div class="pull-right right logo">
          <div class="name"></div>
          <!--<a href="/feed.xml"><img class="avatar" src="/images/rss.jpg" alt="RSS" /></a>-->
        </div>
      </header>
      <div class="separator"></div>
      <ul id="results-container" class="results-container"></ul>
      <article>
  <h1>
    Javascript 성능 최적화 책을 읽고.. - 데이터 접근 -
  </h1>
  <div class="center">
    <p class="meta">20 Nov 2015</p>
  </div>



  <div class="post">
  <p>꽤 오래전에 구입했었던, <a href="http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-855-8">JavaScript 성능 최적화</a>라는 책을 다시 한번 읽어보며, 책 내용 중 개인적으로 중요하다고 느꼈던 부분과, 당시 <a href="http://krdic.naver.com/detail.nhn?docid=13706300">모호</a>했었던 부분들을, 이 포스트를 통해, 다시한번 정리해나갈 생각이다. 아마 이 책을 소지하고계신 분이라면, 책 내용을 이해하는데, 조금은 도움이될 듯 합니다.</p>

<h2 id=">글에 대해</h2>

<ul>
<li>자주 언급되는 특정 <span style="color:#c11f1f"><a href="http://mohwa.github.io/blog/search/?category=javascript">JS 용어</a></span>(<strong>VO</strong>, <strong>AO</strong>, <strong>Scope Chain</strong> 등)에 대해서는 따로 설명하지 않으며, <strong>링크</strong>된 <strong>블로그 글</strong>을 통해 찾아볼 수 있을것이다.</li>
</ul>

<h2 id=">데이터 접근</h2>

<ul>
<li><h3>원글: <em><strong>리터널 값</strong>이란? 단순히 자신을 나타낼 뿐이며, 특정 장소에 저장되지 않는 <strong>모든 값</strong>입니다. JS 에서는 문자열, 숫자, 불리언, 객체, 배열, <span style="color:#c11f1f">함수</span>, 정규 표현식, 특별한 값인 null 과 undefined 가 <strong>리터널</strong>입니다.</em></h3>

<ul>
<li><p>여기서 말하는 <span style="color:#c11f1f">함수</span>는 <strong>함수 선언식</strong>이 아닌, <span style="color:#c11f1f">함수 표현식</span>만을 <strong>의미</strong>한다.</p>

<ul>
<li><p><strong>함수 선언식</strong>은 단순히 <u>함수를 정의하는 <strong>문장</strong>으로 해석</u>되며, 실행 코드 처리 시 <span style="color:#c11f1f">값</span>으로 평가되지않는다.</p>

<ul>
<li><p>함수 선언식</p>

<p><img src="/blog/assets/images/posts/20151019/performance_1.png" alt=""></p></li>
</ul></li>
<li><p><span style="color:#c11f1f">함수 표현식</span>은 <span style="color:#c11f1f">값</span>으로 평가된다.</p>

<ul>
<li><p>함수 표현식</p>

<p><img src="/blog/assets/images/posts/20151019/performance_3.png" alt=""></p></li>
</ul></li>
<li><p><span style="color:#c11f1f">함수 선언식</span>은 <strong>함수 표현식</strong>과 달리, 반드시 <strong>함수 이름</strong>을 가져야한다.(즉 <strong>익명 함수</strong>가 허용되지 않는다)</p>

<ul>
<li><em>The main difference between a function expression and a function statement is the function name, which can be omitted in function expressions to create anonymous functions.</em></li>
<li><p>함수 선언식</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="c1">// 함수 선언식은 반드시 함수 이름을 가져야한다.</span>
<span class="kd">function</span> <span class="p">(){</span>

    <span class="c1">// function execution context</span>
<span class="p">}</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20151019/performance_2.png" alt=""></p></li>
<li><p>함수 표현식                  </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="c1">// 익명 함수 표현식(AFE)</span>
<span class="kd">var</span> <span class="nx">fn1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// function execution context</span>
<span class="p">};</span>

<span class="c1">// 기명 함수 표현식(NFE)</span>
<span class="kd">var</span> <span class="nx">fn2</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
    <span class="c1">// function execution context</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span> <span class="c1">// function object</span>
<span class="p">};</span>

<span class="c1">// 괄호 연산자를 통한 익명 함수 표현식</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">(){</span>
    <span class="c1">// function execution context</span>
<span class="p">});</span>

<span class="c1">// 괄호 연산자를 통한 기명 함수 표현식</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">B</span><span class="p">(){</span>
    <span class="c1">// function execution context</span>
<span class="p">});</span>

<span class="c1">// 괄호 연산자를 통한 즉시 실행 함수(익명/기명)</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// function execution context</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;immediately invoked function&#39;</span><span class="p">);</span> <span class="c1">// immediately invoked function</span>
<span class="p">})();</span>

<span class="p">(</span><span class="kd">function</span> <span class="nx">C</span><span class="p">(){</span>
    <span class="c1">// function execution context</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">C</span><span class="p">);</span> <span class="c1">// function object</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;immediately invoked function&#39;</span><span class="p">);</span> <span class="c1">// immediately invoked function</span>
<span class="p">})();</span>

<span class="c1">// 그밖의 함수 표현식들</span>

<span class="c1">// 하지만 아래 표현식들은 의도된 함수 반환 값을 가질 수 없다는 단점이 존재한다.</span>
<span class="c1">// 즉 아래 함수 표현식들은 실제 코드상에서 사용하지 않는 편이 좋다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}());</span> <span class="c1">// 0 1</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">!</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}());</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">!</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}());</span> <span class="c1">// true</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">~</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}());</span> <span class="c1">// -2</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">-</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="o">-</span><span class="mi">100</span><span class="p">;</span> <span class="p">}());</span> <span class="c1">// 100</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">+</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="o">-</span><span class="mi">100</span><span class="p">;</span> <span class="p">}());</span> <span class="c1">// -100</span>

<span class="c1">// 위에서 언급했던것처럼 함수 표현식은 값으로 평가된다. </span>
<span class="c1">// 즉 아래, 함수 표현식들은 값으로 평가되어 new 연산자를 통해, 새로운 객체를 생성하게된다.</span>
<span class="k">new</span> <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// function object</span>
<span class="p">};</span> <span class="c1">// === new A;</span>

<span class="k">new</span> <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// function object</span>
<span class="p">}();</span> <span class="c1">// === new A();                </span>
</code></pre></div></li>
</ul></li>
</ul></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/15/function-inJS/">Function in JS</a></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/14/vo-inJS/">Variable Object in JS</a></p></li>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Literals">문법과 타입</a></p></li>
<li><p><a href="http://www.tutorialspoint.com/javascript/javascript_function_literals.htm">JavaScript Function Literals</a></p></li>
<li><p><a href="http://docstore.mik.ua/orelly/webprog/jscript/ch03_04.htm">3.4. Functions</a></p></li>
<li><p><a href="http://insanehong.kr/post/javascript-function/">Function Declarations(함수선언) vs Function Expressions(함수표현)</a></p></li>
<li><p><a href="https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/">Function Declarations vs. Function Expressions</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function">function expression</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/1013385/what-is-the-difference-between-a-function-expression-vs-declaration-in-javascrip">What is the difference between a function expression vs declaration in JavaScript?</a></p></li>
<li><p><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a></p></li>
</ul></li>
<li><h3>원글: <em><strong>변수</strong>는 데이터를 저장할 목적으로, <u><span style="color:#c11f1f">var</span> 키워드를 써서 만든</u>, 개발자가 정의한 위치입니다.</em></h3>

<ul>
<li><strike><em>&quot;개발자가 정의한 위치&quot;</em> 라는 <strong>표현</strong>은 왜 썼는지 이해가 되지 않는다.</strike><p /></li>
<li>글 공개 후, 지인을 통해 <span style="color:#c11f1f">&quot;개발자가 정의한 위치&quot;</span> 라는 표현은 <strong>스코프</strong>를 말하는 것이 아닐까?&quot; 라는 말을 들었다.<p /></li>
<li>내 생각도 그것과 크게 다르지 않으나, 구지 <strong>Scope</strong> 라는 큰 범위의 의미를 <strong>변수</strong>를 설명하기 위한 이 <strong>한 문장</strong>에 꼭 넣어야 했을까? 라는 생각이 들기도 한다...<p /></li>
<li><p><strong>변수</strong>는 오직 <span style="color:#c11f1f">var</span> 키워드를 통해서만 선언된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global Execution Context</span>

  <span class="c1">// var 키워드를 통한(변수 선언식) x 변수는 execution context 진입 시 VO 의 속성으로 추가되며, undefined 로 초기화된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// undefined</span>

  <span class="k">try</span><span class="p">{</span>
      <span class="c1">// var 키워드가 생략된 y 속성은 execution context 진입 시 VO 의 속성으로 추가되지않는다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span> <span class="p">(</span><span class="nx">ex</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ex</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// y is not defined</span>
  <span class="p">}</span>

  <span class="c1">// var 키워드를 통한 x 변수</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// var 키워드가 생략된 y 속성</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// var 키워드를 통한 x 변수는 non-configurable(DontDelete) 로 정의된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">));</span> <span class="c1">// Object {value: 1, writable: true, enumerable: true, configurable: false}</span>

  <span class="c1">// var 키워드가 생략된 y 속성은 configurable 로 정의된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">));</span> <span class="c1">// Object {value: 2, writable: true, enumerable: true, configurable: true}</span>

  <span class="c1">// 실행 코드 처리 후 1 이 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1 === this.x</span>

  <span class="c1">// 실행 코드 처리 후 2 가 할당된다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// 2 === this.y</span>

  <span class="c1">// non-configurable(DontDelete) 속성으로 정의된 x 변수는 delete 연산자를 통해 삭제되지 않는다.</span>
  <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>

  <span class="c1">// configurable 속성으로 정의된 y 속성은 delete 연산자를 통해 삭제된다.</span>
  <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>

  <span class="c1">// delete 연산자를 통해 삭제되지 않았다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1 === this.x</span>

  <span class="k">try</span><span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span> <span class="p">(</span><span class="nx">ex</span><span class="p">){</span>
      <span class="c1">// delete 연산자를 통해 삭제되었다.</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ex</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// y is not defined</span>
  <span class="p">}</span>
</code></pre></div></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/14/variable-inJS/">Variable in JS</a></p></li>
</ul></li>
</ul>

<h2 id="scope-chain"><strong>Scope Chain</strong> 과 <strong>식별자 해석</strong></h2>

<ul>
<li><h3>원글: <em><u>JS 함수는 <strong>객체</strong>이고, 엄밀히 말해 <span style="color:#c11f1f">Function</span> 의 인스턴스 입니다.</u> 함수 객체는 다른 모든 객체와 마찬가지로 속성이 있는데, 이 속성은 프로그램에서 접근할 수 있는 속성과 JS 엔진에서 사용되며, 코드(개발자가 직접)에서 접근할 수 없는 <strong>내부 속성</strong>으로 나뉩니다. 이러한 <strong>내부 속성</strong> 중 하나가 ECMA-262 세 번째 판에서 정의한 [[Scope]] 속성 입니다.</em></h3>

<ul>
<li><p>JS 함수는 <span style="color:#c11f1f">Function</span> <strong>생성자 함수 객체</strong>로 만든 또 다른 <strong>함수 객체</strong> 이다.</p>

<ul>
<li><p>이전에 작성했었던, <a href="http://mohwa.github.io/blog/javascript/2015/10/16/prototype/">객체 지향 언어의 두 가지 줄기</a>라는 글에서, <strong>inifnite regress problem of classes</strong> 라는 말을 언급한적이있었다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="err">프로토타입</span> <span class="err">기반</span> <span class="nx">OO</span><span class="err">는</span> <span class="err">객체를</span> <span class="err">직접</span> <span class="err">이용하는데</span> <span class="err">비해</span><span class="p">,</span> <span class="err">클래스</span> <span class="err">기반의</span> <span class="nx">OO</span><span class="err">는</span> <span class="err">클래스라는</span> <span class="err">틀을</span> <span class="err">이용해서</span> <span class="err">객체를</span> <span class="err">생성하죠</span><span class="p">.</span>

  <span class="err">자연스럽게</span> <span class="err">나오는</span> <span class="err">질문은</span> <span class="s2">&quot;그럼 클래스는 대체 어디서 나온 것인가?&quot;</span><span class="err">라는</span> <span class="err">거죠</span><span class="p">.</span>

  <span class="err">대표적</span> <span class="err">클래스</span> <span class="err">기반</span> <span class="nx">OO</span><span class="err">인</span> <span class="nx">Java</span><span class="err">는</span> <span class="err">클래스도</span> <span class="err">객체로</span> <span class="err">봅니다</span><span class="p">.</span> <span class="err">그런데</span> <span class="err">클래스가</span> <span class="err">객체면</span> <span class="err">클래스를</span> <span class="err">찍어낸</span> <span class="err">클래스가</span> <span class="err">있어야</span> <span class="err">합니다</span><span class="p">.</span> <span class="err">클래스를</span> <span class="err">찍어낸</span> <span class="err">클래스도</span> <span class="err">객체이므로</span><span class="p">,</span> <span class="err">클래스를</span> <span class="err">찍어낸</span> <span class="err">클래스를</span> <span class="err">만드는</span> <span class="err">클래스도</span> <span class="err">있어야</span> <span class="err">합니다</span><span class="p">.</span> 

  <span class="err">이렇게</span> <span class="err">무한히</span> <span class="err">반복</span> <span class="err">되기</span> <span class="err">때문에</span> <span class="s2">&quot;inifnite regress problem of classes&quot;</span><span class="err">라고</span> <span class="err">불리는</span> <span class="err">것이죠</span><span class="p">.</span>

  <span class="nx">Java</span><span class="err">는</span> <span class="err">이</span> <span class="err">문제를</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nx">Class</span><span class="err">가</span> <span class="err">모든</span> <span class="err">클래스의</span> <span class="err">틀이라고</span> <span class="err">이야기하면서</span><span class="p">,</span> <span class="err">은근</span> <span class="err">슬쩍</span> <span class="err">넘어갔지만</span> <span class="err">여기에</span> <span class="err">숨은</span> <span class="err">논리적인</span> <span class="err">문제를</span> <span class="err">확실히</span> <span class="err">못풀고</span> <span class="s2">&quot;태초에 Class가 있었다&quot;</span><span class="err">라는</span> <span class="err">해법이</span> <span class="err">나와버리는거죠</span><span class="p">.</span>

  <span class="err">다른</span> <span class="err">접근</span> <span class="err">방법을</span> <span class="err">취한</span> <span class="err">언어가</span> <span class="err">있는지</span> <span class="err">모르겠지만</span><span class="p">,</span> <span class="err">대부분의</span> <span class="err">클래스</span> <span class="err">기반</span> <span class="err">언어는</span> <span class="err">클래스는</span> <span class="nx">second</span><span class="o">-</span><span class="nx">order</span> <span class="nx">citizen</span><span class="err">으로</span> <span class="err">특별히</span> <span class="err">취급해서</span> <span class="err">찍어낼</span> <span class="err">수</span> <span class="err">있는</span> <span class="err">틀은</span> <span class="err">원래</span> <span class="err">있었다라고</span> <span class="err">얘기하게</span> <span class="err">되는거죠</span><span class="p">.</span>

  <span class="err">그</span> <span class="err">대상이</span> <span class="err">클래스라는</span> <span class="err">거만</span> <span class="err">제외하면</span> <span class="err">접근</span> <span class="err">방법은</span> <span class="err">프로토타입</span> <span class="err">방식과</span> <span class="err">크게</span> <span class="err">다르지</span> <span class="err">않은</span> <span class="err">거고요</span><span class="p">.</span> 
</code></pre></div></li>
<li><p>이 말은 JS <strong>함수 객체</strong>에서도 동일하게 적용될 수 있다. 즉 <strong>함수</strong>를 생성하는 <span style="color:#c11f1f">Function</span> <strong>생성자 함수 객체</strong>를 생성하기 위해서는, 또 다른 <span style="color:#c11f1f">Function</span> <strong>생성자 함수 객체</strong>가 무한히 반복되기 때문이다.</p>

<p><img src="/blog/assets/images/posts/20151019/performance_4.png" alt=""></p></li>
</ul></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/14/vo-inJS/">Variable Object in JS</a>             </p></li>
</ul></li>
<li><h3>원글: <em>함수가 만들어질 때(함수 생성 시), 함수가 생성된 스코프에서 접근할 수 있는, 데이터를 나타내는 객체(<span style="color:#c11f1f">VO</span>)와 함께 <strong>Scope Chain</strong>이 만들어집니다.</em></h3>

<ul>
<li>원글과 달리, <strong>Scope Chain</strong> 은 <u><span style="color:#c11f1f">함수 생성 시점</span></u>이 아닌, <u><span style="color:#c11f1f">함수 호출 시점</span></u>에서 해당 Function Execution Context 내부에 <strong>생성</strong>된다.</li>
<li><p><span style="color:#c11f1f">함수 생성 시에는</span>, 해당 Function Execution Context 상위에 있는, <strong>모든 부모 계층</strong>의 <span style="color:#c11f1f">VO</span> 들을 [[Scope]] 속성으로 <strong>할당</strong>시킨다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global Execution Context</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
      <span class="c1">// function Execution Context</span>
      <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>          
</code></pre></div></li>
<li><p>생성된 <strong>함수 객체</strong> 내부</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">    <span class="nx">A</span><span class="o">:</span> <span class="p">{</span>
    <span class="p">[[</span><span class="nx">Scope</span><span class="p">]]</span><span class="o">:</span> <span class="p">[</span>
      <span class="c1">// [[Scope]] 속성에는 해당 function execution context 상위에 있는, 모든 부모 계층의 VO 가 할당된다.</span>
      <span class="nx">globalExecutionContext</span><span class="p">.</span><span class="nx">VO</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">A</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul></li>
<li><h3>원글: <em>실행 문맥도 식별자 해석에 쓸 자기만의 <strong>Scope Chain</strong> 이 있습니다. 실행 문맥이 만들어질 때 이 문맥의 <strong>Scope Chain</strong>은 실행 중인 함수의 [[Scope]] 속성에 있는 <strong>객체로 초기화</strong>됩니다. 이 과정이 끝나면 활성화 객체(<span style="color:#c11f1f">AO</span>)라고 부르는 새로운 객체가 실행 문맥에 생성됩니다. 활성화 객체(<span style="color:#c11f1f">AO</span>)는 이 실행에 대해 변수 객체(<span style="color:#c11f1f">VO</span>) 구실을 하며, 모든 지역 변수, 명명된 매개변수, arguments 집합, this 항목을 포함합니다.</em></h3></li>
<li><h3><em>활성화 객체(<span style="color:#c11f1f">AO</span>)는 <strong>Scope Chain</strong> 의 앞에 자리 잡습니다. 실행 문맥이 파괴될 때, 활성화 객체(<span style="color:#c11f1f">AO</span>)도 같이 파괴됩니다.</em></h3>

<ul>
<li><p><span style="color:#c11f1f">함수 호출 시</span>, 함수 [[Scope]] 속성과, Function Execution Context 내부 <span style="color:#c11f1f">AO</span>(VO) 를 포함하는, <strong>Scope Chain</strong> 이 생성된다.</p>

<ul>
<li> [<span style="color:#c11f1f">AO</span>(VO), [[Scope]]] = <strong>Scope Chain</strong></li>
<li><p><span style="color:#c11f1f">AO</span> 는 <strong>Scope Chain</strong> 의 가장 <span style="color:#c11f1f">앞</span>(ScopeChain[0])에 추가되며, <strong>식별자 검색</strong> 시 가장 먼저 검색된다.<p></p>

<p><img src="http://figures.oreilly.com/tagoreillycom20090601oreillybooks300541I_book_d1e1/figs/I_mediaobject7_d1e6895-web.png" alt=""></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global Execution Context</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// VO.x</span>

  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
      <span class="c1">// function Execution Context</span>
      <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// AO(VO).y</span>
  <span class="p">}</span>  

  <span class="c1">// A 함수객체를 호출한다.     </span>
  <span class="nx">A</span><span class="p">();</span>                  
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ECStack</span> 내부</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">ECStack</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">// A function execution context</span>
    <span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="nx">functionExecutionContext</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">AO</span><span class="p">(</span><span class="nx">VO</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span>
      <span class="p">},</span>
      <span class="nx">Scope</span><span class="p">(</span><span class="nx">Scope</span> <span class="nx">Chain</span><span class="p">)</span><span class="o">:</span> <span class="p">[</span>
        <span class="c1">// 함수 호출 시, 생성된 AO(VO) 는 Scope Chain 의 가장 앞에(ScopeChain[0]) 추가되며, 식별자 검색 시, 가장 먼저 검색된다.</span>
        <span class="nx">AO</span><span class="p">(</span><span class="nx">VO</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span>
        <span class="p">},</span>              
        <span class="c1">// 함수 생성 시, [[Scope]] 속성에 추가되었던, globalExecutionContext 의 VO</span>
        <span class="nx">globalExecutionContext</span><span class="p">.</span><span class="nx">VO</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
          <span class="nx">A</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span>
        <span class="p">}</span>
      <span class="p">],</span>
      <span class="k">this</span><span class="o">:</span> <span class="nx">global</span> <span class="nx">object</span>              
    <span class="p">},</span>
    <span class="c1">// global execution context</span>
    <span class="nx">globalExecutionContext</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">VO</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">A</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span>        
      <span class="p">},</span>
      <span class="nx">Scope</span><span class="p">(</span><span class="nx">Scope</span> <span class="nx">Chain</span><span class="p">)</span><span class="o">:</span> <span class="p">[</span>
        <span class="c1">// global execution context 내부 Scope Chain 에는 globalExecutionContext.VO 만 포함된다.</span>
        <span class="nx">globalExecutionContext</span><span class="p">.</span><span class="nx">VO</span>
      <span class="p">],</span>
      <span class="k">this</span><span class="o">:</span> <span class="nx">global</span> <span class="nx">object</span>                            
    <span class="p">}</span>
  <span class="p">];</span>
</code></pre></div></li>
</ul></li>
</ul></li>
<li><h3>원글: <em><span style="color:#c11f1f">식별자 검색</span>을 통해, 끝까지 찾지 못하면 <strong>변수</strong>가 선언되지 않은 것으로 간주합니다.</em></h3>

<ul>
<li><p><strong>런타임 오류</strong>가 발생된다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>

<span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

    <span class="c1">// function execution context</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">A</span><span class="p">();</span>
</code></pre></div>
<p><img src="/blog/assets/images/posts/20151019/performance_7.png" alt=""></p></li>
</ul></li>
<li><h3>원글: <em>함수 스코프 바깥에 있는 값을 한번 이상 사용할 거라면, 항상 지역 변수에 저장한다는 원칙을 가지는게 좋습니다. 만약 수십 개의 <strong>전역 변수</strong>에 반복해서 접근해야하는 큰 함수일경우, 성능이 비약적으로 좋아질것입니다.</em></h3>

<ul>
<li>이 말은, <span style="color:#c11f1f">식별자 검색</span>이 <strong>JS 엔진</strong>에 의해, <strong>최적화</strong>되지않은 <strong>상황</strong>을 고려해야한다는 말이다.(즉 <strong>APP</strong> 이 오래된 브라우저(IE 7 ~ 8 등)를 지원해야하는 경우를 말한다)<p></li>
<li><a href="http://mohwa.github.io/blog/tool/2015/11/12/scope-chain-search-test/">식별자 검색 테스트</a><br></li>
</ul></li>
<li><h3>원글: <em>실행 중에 with 문을 만나면 실행 문맥의 <strong>Scope Chain</strong> 이 임시로 확장되면서, 명시한 객체의 속성 전체를 포함하는 새로운 변수 객체(<span style="color:#c11f1f">VO</span>)가 만들어집니다.</em></h3></li>
<li><h3><em>만약 document 객체를 with 문에 전달하면 document 객체의 속성을 모두 포함하는 새로운 객체(<span style="color:#c11f1f">VO</span>)가 <strong>Scope Chain</strong>의 가장 앞에 삽입됩니다. 이렇게하면 document 객체 속성에는 매우 빠르게 접근할 수 있지만, 함수 <strong>지역 변수</strong>에 접근하는것은 느려집니다.</em></h3>

<ul>
<li><p>사실, 이 <strong>시나리오</strong>로 인해, <strong>식별자 검색</strong>이 느려지는 <strong>상황</strong>은 아마 거의 없을것이다.(<strong>production code</strong> 코드를 작정하고 느려지게 만들지 않는한은...)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global execution context</span>

  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// function execution context</span>

      <span class="c1">// 지역 변수</span>
      <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="c1">// with 문에 document 객체를 전달한다.</span>
      <span class="kd">with</span> <span class="p">(</span><span class="nb">document</span><span class="p">){</span>

          <span class="c1">// 전달된 document 객체 속성을 수정한다.</span>
          <span class="nx">getElementById</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">);</span> <span class="c1">// null</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">();</span>
</code></pre></div></li>
<li><p><span style="color:#c11f1f">ECStack</span> 내부</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">ECStack</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">// A function execution context</span>
    <span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="nx">functionExecutionContext</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">AO</span><span class="p">(</span><span class="nx">VO</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span>
      <span class="p">},</span>
      <span class="nx">Scope</span><span class="p">(</span><span class="nx">Scope</span> <span class="nx">Chain</span><span class="p">)</span><span class="o">:</span> <span class="p">[</span>
        <span class="c1">// with 문으로 인해, 해당 Scope Chain 이 확장된다.</span>
        <span class="kd">with</span><span class="p">(</span><span class="nx">VO</span><span class="p">(</span><span class="nb">document</span> <span class="nx">object</span><span class="p">))</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">getElementById</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
          <span class="p">...</span>
        <span class="p">},</span>
        <span class="c1">// 확장된 Scope Chain 으로 인해, AO(VO) 에 대한 접근이 느려진다.</span>
        <span class="nx">AO</span><span class="p">(</span><span class="nx">VO</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span>
        <span class="p">},</span>              
        <span class="nx">globalExecutionContext</span><span class="p">.</span><span class="nx">VO</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">A</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span>
        <span class="p">}</span>
      <span class="p">],</span>
      <span class="k">this</span><span class="o">:</span> <span class="nx">global</span> <span class="nx">object</span>              
    <span class="p">},</span>
    <span class="c1">// global execution context</span>
    <span class="nx">globalExecutionContext</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">VO</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">A</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span>        
      <span class="p">},</span>
      <span class="nx">Scope</span><span class="p">(</span><span class="nx">Scope</span> <span class="nx">Chain</span><span class="p">)</span><span class="o">:</span> <span class="p">[</span>
        <span class="nx">globalExecutionContext</span><span class="p">.</span><span class="nx">VO</span>
      <span class="p">],</span>
      <span class="k">this</span><span class="o">:</span> <span class="nx">global</span> <span class="nx">object</span>                            
    <span class="p">}</span>
  <span class="p">];</span>
</code></pre></div></li>
</ul></li>
<li><h3>원글: <em><span style="color:#c11f1f">동적 스코프</span>는 with 문, catch 절, eval() 함수와 같이 <span style="color:#c11f1f">실행 코드 처리</span>시, <strong>동적</strong>으로 해당 <strong>Scope Chain</strong> 이 변경되는 <strong>환경</strong>을 의미합니다.</em></h3></li>
<li><h3><em><strong>최적화</strong>된 브라우저 엔진의 경우, 전통적인 <strong>Scope Chain</strong> 을 참조를 하지 않고, <strong>식별자 색인</strong>을 따로 만들어 식별자를 더 빠르게 해석합니다. 하지만 코드에 <span style="color:#c11f1f">동적 스코프</span>가 있다면, 이런 식으로 최적화할 수 없습니다. 따라서 <span style="color:#c11f1f">동적 스코프</span>는 꼭 필요할때만 쓰길 권장합니다.</em></h3>

<ul>
<li><p><span style="color:#6298c1">eval</span> 함수를 활용한 <strong>동적 스코프</strong></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global execution context</span>

  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>

      <span class="c1">// function execution context</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 1</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">B</span><span class="p">(){</span>

      <span class="c1">// function execution context</span>

      <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

      <span class="c1">// eval execution context 는 calling context 의 Scope Chain 을 갖는다.</span>
      <span class="c1">// evalExecutionContext.Scope ==&gt; BFunctionExecutionContext.Scope</span>
      <span class="c1">// 여기서 callingContext 는 BFunctionExecutionContext 를 가리킨다.</span>
      <span class="nb">eval</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="nx">A</span><span class="p">));</span>

      <span class="nx">A</span><span class="p">();</span> <span class="c1">// 2</span>
  <span class="p">}</span>

  <span class="nx">A</span><span class="p">();</span>

  <span class="nx">B</span><span class="p">();</span>
</code></pre></div></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/11/scope-chain-inJS/">Scope Chain 그리고 Closure</a>          </p></li>
</ul></li>
<li><h3>원글: <em>클로저란? 함수가 자신의 스코프 밖에 있는 데이터에 접근할 수 있게 하는 <strong>환경</strong>을 말한다.</em></h3>

<ul>
<li>클로저란? <strong>Scope Chain</strong> 매커니즘을 통해, 해당 Function Execution Context 상위에 있는 <strong>모든 부모 계층</strong>의 <span style="color:#c11f1f">VO</span> 에 접근하는 <strong>환경</strong>을 말한다.</li>
<li><p>클로저 <strong>환경</strong>으로 인한, <strong>메모리 누수</strong></p>

<ul>
<li><p>즉, makeAdder 함수 종료 시, 소멸되는 <span style="color:#c11f1f">AO</span>(VO) 가, <strong>반환</strong>되는 <strong>함수</strong> [[Scope]] 속성에, 영구적으로 보관되는 <strong>환경</strong>을 말한다.(<strong>메모리 누수의 원인</strong>)</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript">  <span class="c1">// global execution context</span>

  <span class="kd">function</span> <span class="nx">makeAdder</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// &lt;makeAdder&gt; function execution context</span>

    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// &lt;anonymous&gt; function execution context</span>

      <span class="c1">// 반환되는 익명 함수의 [[Scope]] 속성에는, &lt;anonymous&gt; function execution context 상위에 있는 모든 부모 계층의 VO 가 포함되어있다.</span>
      <span class="c1">// 다시 말해, 해당 함수의 [[Scope]] 속성에는, &lt;makeAdder&gt; function execution context 내부 AO(VO) 가 포함된다는 것이다.</span>

      <span class="c1">// 해당 Scope Chain 의 식별자 검색을 통해, 부모 계층의 AO.x 속성을 접근할 수 있다.</span>

      <span class="c1">// anonymousFunctionExecutionContext.scopeChain.makeAdderFunctionExecutionContext.AO.x</span>
      <span class="c1">// anonymousFunctionExecutionContext.scopeChain.AO.y</span>
      <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// 결국 반환되는 함수 [[Scope]] 속성에서는 makeAdderFunctionExecutionContext.AO 가 영구적으로 남게된다.(메모리 누수의 원인) </span>
  <span class="kd">var</span> <span class="nx">add5</span> <span class="o">=</span> <span class="nx">makeAdder</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

  <span class="c1">// 반환받은 익명 함수를 실행한다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add5</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>  <span class="c1">// 7</span>
</code></pre></div></li>
<li><p>anonymousFunction(<span style="color:#c11f1f">add5</span>) 함수의 [[Scope]] 속성 내부</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"> <span class="nx">anonymousFunction</span><span class="p">(</span><span class="nx">add5</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
  <span class="p">[[</span><span class="nx">Scope</span><span class="p">]]</span><span class="o">:</span> <span class="p">[</span>
    <span class="o">&lt;</span><span class="nx">makeAdder</span><span class="o">&gt;</span> <span class="nx">functionExecutionContext</span><span class="p">.</span><span class="nx">AO</span><span class="p">(</span><span class="nx">VO</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">arguments</span><span class="o">:</span> <span class="p">{</span>
        <span class="mi">0</span><span class="o">:</span> <span class="mi">5</span>                
      <span class="p">},</span>
      <span class="nx">x</span><span class="o">:</span> <span class="mi">5</span>
    <span class="p">},</span>
    <span class="nx">globalExecutionContext</span><span class="p">.</span><span class="nx">VO</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">makeAdder</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span><span class="p">,</span>
      <span class="nx">add5</span><span class="o">:</span> <span class="kc">undefined</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p>anonymousFunction(<span style="color:#c11f1f">add5</span>) 함수 실행 시, 생성되는 <strong>Scope Chain</strong> 내부</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"> <span class="nx">anonymousFunctionExecutionContext</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">AO</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">arguments</span><span class="o">:</span> <span class="p">{</span>
        <span class="mi">0</span><span class="o">:</span> <span class="mi">2</span>                
      <span class="p">},</span>
      <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span>                
    <span class="p">},</span>             
  <span class="nx">Scope</span><span class="p">(</span><span class="nx">Scope</span> <span class="nx">Chain</span><span class="p">)</span><span class="o">:</span> <span class="p">[</span>
    <span class="nx">AO</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">arguments</span><span class="o">:</span> <span class="p">{</span>
        <span class="mi">0</span><span class="o">:</span> <span class="mi">2</span>                
      <span class="p">},</span>
      <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span>                
    <span class="p">},</span>
    <span class="o">&lt;</span><span class="nx">makeAdder</span><span class="o">&gt;</span> <span class="nx">functionExecutionContext</span><span class="p">.</span><span class="nx">AO</span><span class="p">(</span><span class="nx">VO</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">arguments</span><span class="o">:</span> <span class="p">{</span>
        <span class="mi">0</span><span class="o">:</span> <span class="mi">5</span>                
      <span class="p">},</span>
      <span class="nx">x</span><span class="o">:</span> <span class="mi">5</span>
    <span class="p">},</span>
    <span class="nx">globalExecutionContext</span><span class="p">.</span><span class="nx">VO</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">makeAdder</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span><span class="p">,</span>
      <span class="nx">add5</span><span class="o">:</span> <span class="o">&lt;</span> <span class="nx">reference</span> <span class="nx">to</span> <span class="kd">function</span> <span class="o">&gt;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></div></li>
</ul></li>
</ul></li>
</ul>

<h2 id=">프로토타입 체인</h2>

<ul>
<li><h3>원글: <em><strong>프로토타입</strong>이란? 다른 객체의 <strong>기반</strong>이 되는 객체이고, 새 객체가 가져야 할 <strong>맴버</strong>를 정의하고 구현합니다.</em></h3>

<ul>
<li><p>생성된 A 함수 <strong>객체</strong>는, Function 생성자 함수 객체의 <strong>원형</strong>을 위임 받는다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// global execution context</span>
<span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
<span class="p">}</span>

<span class="c1">// A 함수 객체의 __proto__ 속성은, 자신을 만든 Function 생성자 함수 객체의 원형(Function.prototype)과 동일하다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></li>
<li><p>A 생성자 함수 객체를 통해 생성될, 새로운 <strong>객체</strong>가 가져야 할 <strong>맴버</strong>를 정의하고 구현한다.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// A 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>

    <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

    <span class="c1">// name 속성</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 새로운 객체(objA)가 가져야할 맴버를 구성하고 구현한다.</span>
<span class="c1">// 즉 A 생성자 함수 객체로 만들어질, 새로운 객체의 특성을 A.prototype 객체를 통해, 구현한다.</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// name 속성을 반환환다.</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// new 연산자를 통해 새로운 객체를 생성한다.</span>
<span class="kd">var</span> <span class="nx">objA</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="s1">&#39;mohwa&#39;</span><span class="p">);</span>

<span class="c1">// 위임받은 특성을 통해, name 속성을 반환한다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">objA</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// mohwa</span>
</code></pre></div></li>
</ul></li>
<li><h3>원글: <em><strong>객체</strong>는 내부 속성(__proto__)을 통해, 자신의 <strong>프로토타입</strong>에 묶입니다. FF, Safari, Chrome 은 이 속성을 <span style="color:#c11f1f">__proto__</span> 라는 이름으로 노출하므로, 개발자가 사용할 수 있지만, 다른 브라우저는 스크립트로 이 속성에 접근할 수 없습니다.</em></h3>

<p><img src="http://dmitrysoshnikov.com/wp-content/uploads/basic-object.png" alt=""></p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// A 함수 객체를 선언한다.</span>
<span class="kd">function</span> <span class="nx">A</span><span class="p">(){</span>
<span class="p">}</span>

<span class="c1">// new 연산자를 통해 새로운 객체를 생성한다.</span>
<span class="kd">var</span> <span class="nx">objA</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>

<span class="c1">// A.prototype: 나를 통해 생성될, 객체(objA)가 위임받을 원형</span>
<span class="c1">// objA.__proto__: 나를 만든 생성자 함수 객체의 원형(A.prototype)</span>

<span class="c1">// objA.__proto__ === A.prototype</span>

<span class="c1">// 결국 objA.__proto__ 속성은 A.prototype 을 가리키게 된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">objA</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></li>
<li><h3>원글: <em>예를들어 <strong>Date</strong> 나 <strong>Array</strong> 같은 객체 인스턴스를 새로 만들면 인스턴스의 <strong>프로토타입</strong>은 자동으로 <strong>Object</strong> 가 됩니다.</em></h3>

<ul>
<li><p>원글의 의미가 이해가 가지 않는다.;;</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Date 생성자 함수 객체로 생성된 새로운 객체의 __proto__ 속성은, 생성자 함수 객체의 원형인 Date.prototype 을 위임받는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>

<span class="c1">// Array 생성자 함수 객체로 생성된 새로운 객체의 __proto__ 속성은, 생성자 함수 객체의 원형인 Array.prototype 을 위임받는다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="k">new</span> <span class="nb">Array</span><span class="p">().</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div></li>
</ul></li>
<li><h3>원글: <em>객체 맴버 해석은 변수 해석과 매우 비슷합니다. book.toString() 을 호출하면, 먼저 객체 인스턴스에서 toString 맴버를 찾습니다. 하지만 book 객체에는 toString 맴버가 없으므로 <strong>프로토타입</strong> 객체를 검색해서 toString() 메서드를 찾아 실행합니다.</em></h3>

<ul>
<li><p>위임 받은 <strong>자식 객체</strong>(obj)는 원하는 특징(속성 or 메서드)에 도달하기위해, <strong>객체</strong>가 가진 원형을 연속적으로 따라가 검색하게된다.(<strong>프로토타입 체인 검색</strong>) </p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 모든 객체는 Object 생성자 함수 객체를 통해 만든 새로운 객체이다.</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// 1. 먼저 obj 객체를 통해, toString 메서드를 검색한다.</span>
<span class="c1">// 2. 하지만 obj 객체에는 toString 메서드가 존재하지 않으므로, 위임 받은 부모 객체(obj.__proto__ ==&gt; Object.prototype)의 원형을 검색한다.</span>
<span class="c1">// 3. 부모 객체의 원형(Object.prototype)에는 toString 메서드가 존재하므로, 해당 메서드를 반환하게된다.</span>

<span class="c1">// obj 객체에는 toString 맴버가 존재하지않으므로, 위임받은 원형 객체(Object.prototype)을 통해, toString 메서드를 찾아 실행하게된다.</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">toString</span><span class="p">);</span> <span class="c1">// toString function object</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">);</span> <span class="c1">// toString function object </span>
</code></pre></div></li>
</ul></li>
<li><h3>원글: <em>찾는 맴버가 프로토타입 체인 깊숙이 있을수록 접근 시간이 늘어납니다.</em></h3>

<ul>
<li><strong>프로토타입 체인 검색 테스트</strong><p></li>
<li>테스트(모던 브라우저를 통한) 후 알게된 사실이지만, <strong>Chrome</strong>(<span style="color:#c11f1f">46.0.2490.86</span> (64-bit)) or <strong>FF</strong>(<span style="color:#c11f1f">42.0</span>) 는 <strong>프로토타입 체인 검색</strong>을 통한, <strong>쓰기</strong> 과정이 <strong>읽기</strong> 보다 더욱 빨랐다...(하지만 <strong>Safari</strong>(<span style="color:#c11f1f">9.0.1</span>(10601.2.7.2)) 의 경우, 예상했던대로 <strong>읽기 과정</strong>이 더 빨랐다.;;)<p></li>
<li>위의 <a href="http://mohwa.github.io/blog/tool/2015/11/12/scope-chain-search-test/">식별자 검색 테스트</a>와 같이 모던 브라우저상에서는, <strong>성능</strong>상 <strong>큰 이슈</strong>가 되지 않을듯 하다.</li>
<li><p>하지만 <strong>오래된 브라우저</strong>상에서도 이에 대한 <strong>성능 이슈</strong>를 피하고 싶다면, <strong>반복 검색</strong>해야하는 <strong>객체 맴버</strong>를 <strong>변수</strong>를 통해, <strong>접근</strong>하는것이 좋다.</p>

<p><iframe height='368' scrolling='no' src='http://codepen.io/yanione/embed/QjPbRM/?height=368&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/QjPbRM/'>QjPbRM</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/16/prototype/">객체 지향 언어의 두 가지 줄기</a></p></li>
<li><p><a href="http://mohwa.github.io/blog/javascript/2015/10/09/enumerable-inJS/">JS Enumerable(열거자) or Nonenumerable(비 열거자)</a></p></li>
</ul></li>
</ul>

<h2 id=">글을 마치며</h2>

<ul>
<li><strong>말머리</strong>에서 <strong>언급</strong>한바와같이, 이 글은 책의 내용을 <strong>비판</strong>하고자하는 목적이 아닌, 책 내용중 개인적으로 중요하다고 판단한 부분과, 의미상 <strong>모호</strong>했던 부분을 다시한번 정리해본것이다.</li>
</ul>

  </div>
  <div data-count="10" id="recommend-article"></div>
</article>

<section class="post-footer">
  <div class="related-posts">
    <div class="related-posts-title"><h2>Related Posts</h2></div>
    <div class="related-posts-list">
      <ul>
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
          
          <!---->
        
          <!-- match 를 false 로 초기화한다 -->
          <!---->
          
          <!-- 현재 page.categories === category 와 동일하다면. -->
          
          
          <!---->
        
      </ul>
    </div>
  </div>
</section>

<section class="comments">
    <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'mohwa'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</section>



      <div class="separator"></div>
    </div>
  </div>
  <footer>
    <section>
  <ul class="links">
      <li><a href="https://twitter.com/yanione" title="follow me" target="_blank"><i class="icon-twitter"></i></a></li>
      <li><a href="https://github.com/mohwa" title="github page" target="_blank"><i class="icon-github"></i></a></li>
  </ul>
<section>

  </footer>
  <script>
    <!-- Google Analytics -->
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-30470280-2', 'auto');
    ga('send', 'pageview');

    // include jekyll full text search
    // https://github.com/christian-fei/Simple-Jekyll-Search
    SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: '/blog/search.json',
      searchResultTemplate: '<li><a href="{href}">{title}</a>&nbsp;&nbsp;&nbsp;{date}</li>',
      noResultsText: 'No results found'
    });

  </script>
  <script src="http://b.readtrend.com/j/s.js"></script>
</body>
</html>
