<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
>

<channel>
    <title><![CDATA[Mohwa blog]]></title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <link href="/" />
    <description><![CDATA[]]></description>
    <lastBuildDate>Fri, 07 Aug 2015 15:08:40 +0900</lastBuildDate>
    <language>en-US</language>
    <generator uri="http://octopress.org/">Octopress</generator>

    
        <item>
            <title><![CDATA[ObjectPool in JS]]></title>
            <link>/designpattern/2015/08/07/objectpool-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/objectpool-inJS/</guid>
            <description>
                <![CDATA[1. 정의 생성된 객체들을 별도의 Pool 안에 저장 후 재사용 하는 방법으로, 불필요한 객체 생성 및 반환(GC에 의한)을 최소화하는 디자인 패턴중 하나 이다. 객체 재사용을 위해, 생성된 객체를 Pool 안에 저장시켜 놓는다. 새로운 객체가 필요할때는, 무조건 새로 생성하는것이 아니라, Pool 안에 반환된 객체가 존재한다면, 그 중 하나를 재사용 한다. 객체...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li><p>생성된 <strong>객체</strong>들을 별도의 <strong>Pool</strong> 안에 저장 후 <span style="color:#c11f1f">재사용</span> 하는 방법으로, 불필요한 객체 <strong>생성</strong> 및 <strong>반환</strong>(<strong>GC</strong>에 의한)을 <span style="color:#c11f1f">최소화</span>하는 <u><strong>디자인 패턴</strong></u>중 하나 이다.</p>

<ul>
<li><strong>객체</strong>  <span style="color:#c11f1f">재사용</span>을 위해, 생성된 <strong>객체</strong>를 <strong>Pool</strong> 안에 저장시켜 놓는다.</li>
<li><p>새로운 <strong>객체</strong>가 필요할때는, <u>무조건 새로 <span style="color:#c11f1f">생성</span></u>하는것이 아니라, <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>된 <strong>객체</strong>가 존재한다면, <u>그 중 하나를 <span style="color:#c11f1f">재사용</span> 한다.</u></p>

<ul>
<li><em>객체 <span style="color:#c11f1f">재사용</span>으로 Heap 메모리 사용을 <span style="color:#c11f1f">최소화</span>한다.</em></li>
</ul></li>
<li><p>사용(객체)이 끝난 후에는 <u>다시 <strong>Pool</strong> 안에 <span style="color:#c11f1f">반환</span>시킨다.</u></p></li>
</ul></li>
</ul>

<h2>2. 특징</h2>

<ul>
<li><p>정해진 <strong>범위</strong>내에서 개발자가 직접 <u><strong>Heap 메모리</strong>를 관리(객체 <span style="color:#c11f1f">생성</span> 및 <span style="color:#c11f1f">반환</span>)</u>할 수 있다.</p>

<ul>
<li><p><u><strong>객체 생성 비용</strong></u>을 줄일 수 있다.(Heap 메모리 사용을 줄일 수 있다)</p>

<ul>
<li><em>당연한 말이겠지만, 생성되는 객체 <span style="color:#c11f1f">크기</span> 및 그 <span style="color:#c11f1f">수</span>에 따라, <u>더 많은 비용을 줄일 수도 있다.</u></em></li>
</ul></li>
<li><p><strong>GC</strong> 를 통해 일어나는, <u>메모리 <span style="color:#c11f1f">반환</span>(반환 시 일어나는 일련의 작업들)) <strong>비용</strong>을 줄일 수 있다.</u></p>

<ul>
<li>보통 이 과정(메모리 반환 과정)을 처리하는 동안에는, <strong>프로그램 실행</strong> 이 중단된다.</li>
<li>또한, 이 과정은 <u>프로그램 실행 중 <span style="color:#c11f1f">임의의 시간</span>에, <span style="color:#c11f1f">임의의 시간동안</span> 언제라도 일어날 수 있다.</u></li>
<li>개발자는 이 <strong>과정</strong>을 <u><span style="color:#c11f1f">제어</span>할 수 없다.</u></li>
</ul>

<p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
</ul></li>
<li><p><span style="color:#c11f1f">재사용</span>되는 <strong>객체</strong>는 <u>모두 <strong>동일한 타입</strong>을 갖는다.</u></p></li>
</ul>

<h2>3. JS 로 동적 ObjetPool 구현해보기</h2>

<iframe height='540' scrolling='no' src='http://codepen.io/yanione/embed/jPdzWB/?height=540&theme-id=0&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/yanione/pen/jPdzWB/'>jPdzWB</a> by mohwa (<a href='http://codepen.io/yanione'>@yanione</a>) on <a href='http://codepen.io'>CodePen</a>.
</iframe>

<ul>
<li>일반적인 동적 <strong>Objet Pool</strong> 기능을 만드는 방법은 위 코드와 같이 크게 어렵지 않다.(물론 지원하는 기능의 범위에 따라, 구현 수준은 크게 달라질 수 있다)</li>
</ul>

<h2>4. ObjectPool 적용 테스트</h2>

<ul>
<li><p>Click 버튼을 <span style="color:#c11f1f">10</span>번 누른 후 <strong>Profiles(in Chrome Tool) 패널</strong>을 통해, <strong>Heap Memory</strong> 를 체크하면 <span style="color:#c11f1f">적용</span> <strong>유/무</strong>에 따른 결과를 얻을 수 있다.</p>

<ul>
<li><p><strong>Object Pool</strong> 적용 전</p>

<ul>
<li><p><span style="color:#c11f1f">Ball</span> 생성자 함수를 통해 객체를 <strong>300</strong>개 할당했다.</p>

<ul>
<li>30 * 10 = 300(무조건 새로운 객체를 Heap 메모리에 할당했다)</li>
</ul></li>
</ul>

<p><img src="/blog/assets/images/posts/ballHeap.jpg" alt=""></p></li>
<li><p><strong>Object Pool</strong> 적용 후</p>

<ul>
<li><p><span style="color:#c11f1f">$F</span> 생성자 함수를 통해 <strong>93</strong>개의 객체를 할당했다.</p>

<ul>
<li><span style="color:#c11f1f">$F</span>: <strong>Object Pool</strong> 라이브러리상에서 만든 생성자 함수.</li>
<li>적용 후에는 총 <strong>93</strong>개의 객체를 <span style="color:#c11f1f">할당</span>했으며, <strong>207</strong>개의 객체를 <span style="color:#c11f1f">재사용</span>하였다.</li>
</ul></li>
</ul>

<p><img src="/blog/assets/images/posts/ballHeap2.jpg" alt=""></p></li>
</ul></li>
</ul>

<h2>5. 정리하며</h2>

<ul>
<li><p>즉 지나친 객체 <span style="color:#c11f1f">생성</span> 및 <span style="color`:#c11f1f">반환</span>을 <strong>최소화</strong> 하는것이, <strong>어플리케이션</strong>상에 <span style="color:#c11f1f">메모리 변동</span>을 줄이는 방법이며, 이로인해 사용자 경험까지 최적화할 수 있다.</p></li>
<li><p>일반적인 <strong>웹</strong>상에서는 적용할 일이 거의 없어보이지만, <strong>게임 어플리케이션</strong>이라면, 적용 범위가 꽤 많을 듯 하다.</p></li>
</ul>

<h2>6. 참고 URL</h2>

<ul>
<li><p><a href="http://ufx.kr/blog/591">액션스크립트의 객체 재사용을 위한 오브젝트 풀(Object Pool)</a></p></li>
<li><p><a href="http://www.html5rocks.com/ko/tutorials/speed/static-mem-pools/">Static Memory Javascript with Object Pools</a></p></li>
<li><p><a href="http://beej.us/blog/data/object-pool/">Object Pools</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    
        <item>
            <title><![CDATA[Interface in JS]]></title>
            <link>/designpattern/2015/08/07/interface-inJS/</link>
            <pubDate>Fri, 07 Aug 2015 00:00:00 +0900</pubDate>
            <dc:creator><![CDATA[{"twitter"=>"yanione", "github"=>"mohwa"}]]></dc:creator>
        
            <category><![CDATA[designpattern]]></category>
        
        
            <guid>/designpattern/2015/08/07/interface-inJS/</guid>
            <description>
                <![CDATA[1. 정의 가장 큰 범위의 인터페이스 정의는 사물 간 또는 사물과 인간 간(User Interface)의 의사소통을 위한 중간 매개체다. 즉 서로간의 의사소통을 위해 정해진 약속이 존재하며, 이를 표준 규격 이라 말할 수 있는것이다. 2. 의미 인터페이스(DB Interface): 구현 클래스가 공통적으로 가져야할 필수 특성(connect, disconnect 등)들을 선언함으로써, 해당 구현 클래스들에게 사용자(User Class)와의...]]>
            </description>
            <content:encoded>
                <![CDATA[<h2>1. 정의</h2>

<ul>
<li>가장 큰 범위의 <a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">인터페이스</a> <code>정의</code>는 사물 간 또는 사물과 인간 간(<a href="https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">User Interface</a>)의 의사소통을 위한 중간 <span style="color:#c11f1f">매개체</span>다. 즉 서로간의 의사소통을 위해 정해진 약속이 존재하며, 이를 <code>표준 규격</code> 이라 말할 수 있는것이다.</li>
</ul>

<h2>2. 의미</h2>

<p><img src="/blog/assets/images/posts/interface_diagram.png" alt=""></p>

<ul>
<li><p><strong>인터페이스</strong>(DB Interface):</p>

<ul>
<li><p><strong>구현 클래스</strong>가 공통적으로 가져야할 필수 <span style="color:#c11f1f">특성</span>(connect, disconnect 등)들을 <strong>선언</strong>함으로써, 해당 구현 클래스들에게 <strong>사용자</strong>(User Class)와의 <strong>의사 소통</strong> 방침(<span style="color:#c11f1f">표준 규격</span>)을 알리는데 목적이 있다.</p>

<ul>
<li><em>인터페이스 내부에 선언된 모든 특성은 구현 클래스를 통해 반드시 구현되어야 한다</em></li>
</ul></li>
</ul></li>
<li><p><strong>구현 클래스</strong>(MSSQL, ORACLE API Class 등):</p>

<ul>
<li><p>사용자(User Class)와의 의사소통을 위해 인터페이스 내부에 선언된 모든 특성들을 충실히 구현한다.</p>

<ul>
<li><em>이때 사용자 입장에서는 특정 구현 클래스 명세없이도, 인터페이스 명세에 따라 제공받은 모든 API 를 사용할 수 있다는 장점이 존재한다.</em>(정확히 말하면, 특정 API 의 모든 기능이 아닌 인터페이스를 구현한 기능에 한정된다)</li>
</ul></li>
</ul></li>
</ul>

<h2>3. 상황에 따른 의미</h2>

<ul>
<li><p>만약 운영중인 어플리케이션의 DB 플랫폼이 <strong>MSSQL</strong> 에서 <strong>PostgreSQL</strong> 로 변경된다고 생각해보자.(오랜 기간 운영중인 어플리케이션의 경우 이런저런 이유로 이와 같은 상황이 충분히 올 수 있다)</p>

<p>이때 위와 같은 인터페이스 설계가 되어있다면, <strong>PostgreSQL</strong> 규격에 따라 해당 인터페이스만 구현하면 최소 비용으로 기능을 <strong>확장</strong>할 수 있을 것이다.</p>

<ul>
<li><em>사용자 입장에서보면, 인터페이스를 통해 구현된 공통적인 기능에 대해서 만큼은 기존 코드를 재사용할 수 있다는 큰 장점이 존재하게 되는 것이다.(어플리케이션 유지보수 비용 최소화)</em></li>
</ul></li>
</ul>

<h2>4. JS 로 인터페이스 구현해보기</h2>

<iframe width="100%" height="1000" src="http://jsfiddle.net/mohwa/jzu5r06e/3/embedded/js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<ul>
<li><p>JS 인터페이스 구현은 아래 <strong>C# 인터페이스 가이드</strong>에 맞춰 구현되었으며, JS 코드에 대한 자세한 설명은 따로 하지 않겠다.(만약 JS 에 대해 어느정도 알고 있는 상황이라면, 코드를 분석해보길 권장한다)</p>

<ul>
<li><p>위 코드에 대한 간단한 설명은 아래와 같다.</p>

<ul>
<li><p>인터페이스 선언을 위한 인터페이스 함수 객체를 구현한다.</p>

<ul>
<li>인터페이스 <strong>[이벤트]</strong> 선언을 위해 <strong>Observer</strong> 함수 객체를 구현한다.</li>
<li><a href="https://msdn.microsoft.com/ko-kr/library/awbftdfh.aspx">C# 이벤트 선언</a></li>
</ul></li>
<li><p>인터페이스를 상속받은 <strong>구현 클래스</strong>를 검증(상속받은 인터페이스를 모두 구현했는지에 대한 검증)하는 함수 객체(Interface.ensureImplement)를 구현한다.</p></li>
<li><p>이전 다이어그램과 같이 <strong>인터페이스</strong> 및 각 <strong>클래스</strong>(구현 클래스)들을 구현한다.</p></li>
</ul></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/ms173156.aspx">C# 인터페이스</a>(인터페이스 정의는 각 언어마다 조금씩 차이를 보인다)</p></li>
<li><p><em>위 코드는 JS 인터페이스 구현 뿐 아니라, 이전 다이어그램에 명시된 [인터페이스], [구현 클래스], [사용자 클래스] 부분까지 전부 작성되었다.</em></p></li>
</ul></li>
</ul>

<h2>5. 정리하며</h2>

<ul>
<li><p><strong>인터페이스</strong>는 개발 중인 어플케이션 규모 및 설계에 따라 적용 범위가 얼마든지 달라질 수 있다.(또는 사용이 불필요할 수 도 있다(간혹 팀내에서의 <strong>관행</strong>적인 적용이 있다는 말을 들은적이 있는데 이건 정말 아닌듯 하다;;;))</p>

<ul>
<li><em>너무 당연한 말일 수 도 있지만, 인터페이스와 같은 모든 디자인 패턴은 적재 적소에 활용해야만 득이되는 것이다.</em></li>
</ul></li>
<li><p>위에서 언급한 내용과 다른 <strong>적용 사례</strong>에 대해(<em>그럼 어떤 상황이 더 있을까?) 한번쯤 심도있게 생각해보길 바란다</em></p></li>
</ul>

<h2>6. 참고 URL</h2>

<ul>
<li><p><a href="http://woonohyo.tistory.com/22">DI란?</a></p></li>
<li><p><a href="http://okky.kr/article/161248">인터페이스 사용이유</a></p></li>
<li><p><a href="http://masamune.tistory.com/16">인터페이스란</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/tkyhsw31.aspx">C# 인터페이스 인덱서</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/64syzecx.aspx">C# 인터페이스 속성</a></p></li>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/ak9w5846.aspx">C# 인터페이스 이벤트</a></p></li>
</ul>
]]>
            </content:encoded>
        </item>
    

</channel>

</rss>